<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>前端学习week14</title>
      <link href="/2019/08/04/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0week14/"/>
      <url>/2019/08/04/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0week14/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>​    本周主要学习了正则表达式的基础知识，细节和小知识点非常非常多，看记录的内容就知道了，主要的学习目的还是能看懂和理解正则表达式以及js常用的正则api及其原理，例如正则对象的exec，test以及字符串的match和replace，不强求写出优雅简洁的正则，毕竟智商有限。此外简单介绍了日期类型和es6的增强字符串-反引号</p><p>​    leetcode方面到了265题，这周主要在做正则的题目，没怎么刷，重点是几道回溯法的练习，解数独，八皇后问题等，感觉自己对复杂一些的代码掌控力还不够，写起来比较乱，有思路也写不出来，还是要练习练习练习</p><a id="more"></a><h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><ul><li>正则表达式也是一种对象类型<ul><li>构造函数RegExp<ul><li>用构造函数创建注意反斜杠的规则和字符串相同</li></ul></li><li>字面量创建，两边用斜杠包围<ul><li>斜杠是结束标值，所以表达式包含斜杠时，需要在前面加反斜杠</li></ul></li><li>source属性，包含创建正则表达式的字符串，不包括//及外面的flags</li><li>lastIndex属性，可写属性，控制下一次匹配开始的位置，<strong>只有当使用设置了g的时候才能被更新和修改，且只对exec和test生效</strong>，匹配失败会被重置为0</li></ul></li><li>中括号只匹配一个字符，匹配中括号中任一字符<ul><li>可以用连字符<code>-</code>指定范围，按unicode顺序，单独的<code>-</code>表示它自己</li><li><code>.</code>在中括号中没有其他含义只表示其自己，其他特殊字符也是，比如<code>+ *</code></li><li><code>^</code>脱字符出现在最前面表示取非，不在最前面没有其他含义，<code>[^]</code>表示匹配全集</li></ul></li><li><code>+</code>前面元素至少重复一次，<code>*</code>重复至少0次，<code>?</code>前面元素出现1次或0次，<code>{}</code>内加数字或范围表示重复具体次数，前面的元素加<code>()</code>使多个元素重复</li><li>表达式末尾<code>i</code>表示不区分大小写<code>/xxx/i</code></li><li>表达式末尾<code>g</code>表示全局匹配输入字符串中所有能匹配的项<strong>默认匹配第一个项就结束匹配</strong><code>/xxx/g</code><ul><li>如果匹配的字符串有交叉，例如用<code>/abcabc/g</code>匹配<code>abcabcabc</code>只会匹配第一个匹配项，不会匹配交叉的第二个</li></ul></li><li>脱字符<code>^</code> 用在开头表示输入字符串的起始位置，<code>$</code>表示字符串结束位置，<code>/^xxx$/</code>则输入字符串必须从头至尾满足条件</li><li><code>\bxxxxx\b</code> 单词边界，包裹的元素是一个独立单词，字符串的起始结束位置都是数字/字母/下划线(即<code>\w</code>表示的字符)</li><li><code>(?:)</code>匹配项不会作为分组，结果不会出现在exec的结果数组中</li><li><code>(?&lt;name&gt;)</code>可以给分组命名，只有自命名的分组的匹配项会出现在exec的group属性中</li><li>零宽断言<ul><li>匹配两个符号之间的一个位置而不是符号，宽度为0</li><li>可以对同一个位置执行多个零宽断言匹配</li><li>零宽断言<strong>不是</strong>分组</li><li><code>/(?=foo)/</code>匹配到字符串中foo开始的位置    </li><li><code>/(?!foo)/</code>位置后面不能匹配foo</li><li><code>/(?&lt;=)/</code>位置左边匹配xxxxx<ul><li>回顾断言中有重复符，则贪婪模式是从右向左满足</li><li>分组时和正常一样是从左向右分配和自动命名的的，但反向代理的<code>\n</code>需要放在分组的左边才能生效，即分配时是从左往右，扫描匹配时是从右往左</li></ul></li><li><code>/(?&lt;!)/</code></li><li>例：<ul><li><code>^ === /(?&lt;![^])/</code></li><li><code>$ === /(?![^])/</code></li><li><code>\b === (?&lt;=\w)(?=\W)|(?&lt;=\W)(?=\w)|(?&lt;![^])|(?![^])</code></li></ul></li></ul></li><li>管道符<code>|</code>   表示或，需要用括号来限制其选项范围</li><li>记住正则的实现是从前向后按步进行的，回溯只存在于当前匹配不成功的情况</li></ul><h4 id="反向引用"><a href="#反向引用" class="headerlink" title="反向引用"></a>反向引用</h4><ul><li>前面分组匹配结束时，自动命名的分组可以用<code>\n</code>引用匹配项</li><li>任何情况下都是以正则表达式中<strong>开始括号的顺序</strong>作为分组的顺序，即使用了<code>|</code>运算符</li><li>自命名分组可以用<code>\k&lt;name&gt;</code>反向引用，同时也可以用<code>\n</code></li></ul><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><ul><li>test<ul><li>接受字符串，返回布尔值，存在匹配项就返回true</li></ul></li><li>exec<ul><li>无匹配返回null，否则返回匹配信息对象</li><li>返回的对象是字符串组成的数组，包含整体及所有圆括号的分组，重复分组则保留最后一次，重复0次的保留undefined，增加了index，groups，input属性</li><li>group属性是一个对象包含自命名分组及其匹配项的键值对</li><li>exec设置了全局g也只会先返回第一个匹配项(同时更新lastIndex属性)，继续执行会向后匹配，不设置g多次执行会重复匹配第一项</li></ul></li><li><code>String.prototype.match()</code>是字符串的方法<ul><li>参数里的正则使用g，则返回所有完整匹配项的结果数组（不包含分组），形式和普通数组相同</li><li>不使用g则返回第一项完整的匹配及其<strong>相关</strong>的分组匹配，形式和exec一样</li></ul></li></ul><h4 id="replace"><a href="#replace" class="headerlink" title="replace"></a>replace</h4><ul><li><p>字符串的方法，用第二个参数替换第一个正则参数匹配到的字符串，第二个参数可以为函数，第一个参数也可以是字符串</p></li><li><p>第二个参数为函数时，传入的参数依次为exec执行后的结果数组的元素，依次为整体匹配项，各分组捕获项，匹配的index，命名分组，输入的字符串</p></li><li><p>设置g可以全局匹配，<strong>实际是重复执行匹配直到全部匹配结束</strong></p></li><li><p><code>$n</code>是正则自带的分组匹配到的字符串表示方式，不能把它当做完全的字符串看待，只能做增加字符，换位等操作</p><ul><li><p><code>\n</code>用在分组开始匹配之前相当于匹配任何位置,即分组还没开始匹配</p></li><li><pre><code class="js">/\1/.test(&#39;&#39;)// false/\1()/.test(&#39;&#39;)// true</code></pre></li><li><p>注意正负回顾零宽断言时的这个规则</p></li></ul></li></ul><h4 id="贪婪模式"><a href="#贪婪模式" class="headerlink" title="贪婪模式"></a>贪婪模式</h4><ul><li>模式重复运算符<code>+ * ? {}</code>默认是贪婪的，会匹配尽量多的字符直到不能匹配再回溯</li><li>在模式重复运算符后加<code>?</code>变为非贪婪，会匹配尽量少的字符，只有剩下的模式无法匹配才会继续匹配重复</li><li>使用重复时优先考虑非贪婪</li></ul><h3 id="日期类型"><a href="#日期类型" class="headerlink" title="日期类型"></a>日期类型</h3><ul><li>构造函数Date，默认创建当前时间对象</li><li>自定义时间：月份从0开始，日期从1开始，小时分钟等不设置默认为0</li><li>getTime方法返回1970年开始以毫秒表示的时间戳 ，也可以用时间戳创建对象</li></ul><h3 id="模板字面量"><a href="#模板字面量" class="headerlink" title="模板字面量"></a>模板字面量</h3><ul><li>反引(``)号表示的增强版字符串<ul><li>支持多行，保留所有空白</li><li>也可用\n指示换行位置</li></ul></li><li>变量占位符<ul><li>新增特性，由<code>${}</code>将变量嵌入字符串，中间可以放任意的表达式，包括运算符函数调用等，注意用反斜杠转义可以使其失效</li></ul></li><li>标签模板<ul><li><strong>String.raw``</strong> 反引号内写入字符串不用考虑转义，所见即所得，输出字符串，任意形式的转义都会失效，保留原样输出</li><li>形如上面这个例子，<code>String.raw</code>模板标签，实际上它是一个函数，后接模板字面量相当于传参，在控制台我们可以看到它传入参数的形式<ul><li>第一个参数是一个数组，包含以变量占位符为隔板分隔的各个子串(类似split)，此外该数组还包含一个不可枚举的raw属性包含的数组，内容形式和包含它的数组内容相同，不过字符串内容与输入时的状态完全相同(即转义都不生效且保留转义符，然而变量占位符依然生效)，这也解释了为什么上一个例子会保留输入原样输出(正是利用了raw)</li><li>第二及以后的参数为从前到后各变量占位符中表达式的值</li></ul></li></ul></li></ul><h3 id="零碎知识"><a href="#零碎知识" class="headerlink" title="零碎知识"></a>零碎知识</h3><ul><li><p>源代码书写字符串的时候才要考虑转义</p></li><li><p>字符串的split方法，参数为正则表达式时，会在各匹配项对应的位置返回<strong>分组捕获的字符串</strong>不会出现整体匹配的字符串</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> front-end </tag>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端学习week13</title>
      <link href="/2019/07/28/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0week13/"/>
      <url>/2019/07/28/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0week13/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>​    本周学习了最后一个常用排序算法-堆排序以及一些哈希表的基本概念，理解其思想和使用情景即可。js基础学习了异常处理和严格模式。红黑树没看完，只看完了基本概念，下周补完。leetcode方面到了245，有所放缓，其实是划水太多，要抓紧了</p><a id="more"></a><h4 id="堆，堆排序"><a href="#堆，堆排序" class="headerlink" title="堆，堆排序"></a>堆，堆排序</h4><ul><li>堆(heap)是一种数据结构，也叫优先序列(PriorityQueue)</li><li>区别于”堆内存(heap memeory)”的堆<ul><li>堆内存对应栈内存<ul><li>堆内存是随机分配的</li><li>栈内存对应调用栈</li></ul></li><li>栈空间指一片内存</li><li>调用栈指函数间互相调用及等待的逻辑概念</li></ul></li><li>堆是一棵完全二叉树<ul><li>每个结点都比其子节点大(小)</li><li>最大/最小堆 (最大/最小值一定处于堆顶)</li><li>主要支持两种操作<ul><li>增加一个元素</li><li>取出其最值</li><li>操作不影响堆的性质</li></ul></li></ul></li><li>堆排序是将长度为n堆数组的第一个值交换到最后，再将前n-1个数的数组堆化，直到数组有序</li><li>堆尾增加一个元素： heapUp</li><li>堆头增加一个元素： heapDown<ul><li>例：取出堆的最值，将堆尾元素放在头部重建为堆</li></ul></li><li>将一个无序数组转换为堆：<ul><li>将数组当做按层遍历的二叉树，从末尾最小的二叉树头结点（最后一个元素的父节点）做heapDown操作，循环至堆头</li></ul></li><li>找出第k大的元素，构建一个大小为k的最小堆</li></ul><h4 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h4><ul><li>try(throw)–catch–finally<ul><li>catch捕获的看前面throw的是什么，默认的错误是一个对象，因为是Error()的实例</li><li>编译器先确定程序没有<strong>语法错误</strong>才开始执行</li><li>throw立即停止运行直到被catch</li></ul></li><li>Error()是构造函数</li></ul><h5 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h5><ul><li><code>&quot;use strict&quot;</code></li><li>静默错误现在会抛出异常</li><li>不允许不声明创建全局变量</li><li>只限定当前作用域下的代码，不限制调用的函数</li><li>直接调用方法/构造函数，this绑定undefined而不是window</li><li>函数形参名唯一</li><li>不能使用八进制字面量(即0开头的数字类型)，但可以写成<code>0oxxx</code></li><li>不允许直接使用eval()在当前作用域中创建变量或函数<ul><li>在严格模式下，<code>eval()</code>在运行时有自己的词法作用域，意味着其中的声明无法修改所在的作用域，但是可以获取eval()内语句块的返回值</li></ul></li><li>不能覆写arguments的值</li><li>es6一些语法会自动开启es6模式，例：class</li></ul><h4 id="哈希表-散列表"><a href="#哈希表-散列表" class="headerlink" title="哈希表(散列表)"></a>哈希表(散列表)</h4><h5 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h5><ul><li>散列函数生成的值要尽可能随机且均匀分布</li></ul><h5 id="哈希冲突"><a href="#哈希冲突" class="headerlink" title="哈希冲突"></a>哈希冲突</h5><p>即不同key经过哈希函数计算出相同的值，很难通过完善算法的方式完美解决，所以需要其他的途径</p><ul><li>开放寻址法<ul><li>如果出现了冲突，就重新探测一个空闲位置将其插入<ul><li>线性探测        步长为1</li><li>二次探测        步长为平方</li><li>双重散列        冲突则再哈希一次</li></ul></li><li>装载因子： 填入表中的元素个数 / 散列表的长度<ul><li>装载因子越大，空闲位置越少，散列表性能越低</li><li>动态扩容/缩容，设置阈值保持执行效率</li></ul></li></ul></li><li>链表法<ul><li>每个slot对应一条链表，hash值相同则直接加入链表末尾</li></ul></li></ul><h4 id="平衡二叉查找树"><a href="#平衡二叉查找树" class="headerlink" title="平衡二叉查找树"></a>平衡二叉查找树</h4><p>严格的平衡二叉查找树是指这棵二叉查找树任意结点的左右子树高度差不能大于1，使树的高度保持以2为底logN</p><p>设计平衡二叉查找树的初衷是为了防止频繁的插入和删除操作造成的性能退化，常见的平衡二叉查找树：</p><ul><li>AVL树：严格符合以上定义，是高度平衡的二叉查找树</li><li>红黑树(R-B tree)：不严格符合高度差为1的定义，但是能思想是一样的，即保持左右子树高度大致相等，所以也认为是合格的平衡二叉查找树，很多种平衡二叉查找树都不严格符合定义<ul><li>定义：<ul><li>根结点是黑色</li><li>每个叶子是黑色的空结点NIL</li><li>相邻结点不能同时为红色，即红色结点被黑色结点隔开</li><li>*从任意结点到达其可到达的叶子结点路径经过的黑色结点的数量是相同的</li></ul></li><li>红黑树是“近似平衡”的(即性能不会退化地太严重，树的高度稳定地趋近以2为底logN)</li><li>插入操作<ul><li>插入结点必须是红色，新插入的结点放在叶子结点上</li><li>旋转</li><li>变色</li></ul></li><li>删除操作</li></ul></li></ul><h4 id="零碎知识"><a href="#零碎知识" class="headerlink" title="零碎知识"></a>零碎知识</h4><ul><li><p>浅拷贝和深拷贝</p><ul><li>浅拷贝只复制对象的第一层</li><li>深拷贝递归复制所有层级</li></ul></li><li><p>直接调用eval()是在当前作用域下调用，凡是使用别名调用eval()则一律是在全局作用域下</p></li><li><p>函数表达式的函数名是常量绑定，只在该函数内部有效，在函数内对其赋值在非严格模式下会静默失败，严格模式下会报错</p><ul><li><pre><code class="js">(function a() {    a = 3    console.log(a)})()//会打印出整个函数体//可以理解为a函数相当于const定义的常量</code></pre></li><li><p>注意函数声明提升<a href="https://blog.csdn.net/sinat_35512245/article/details/53514804" target="_blank" rel="noopener">https://blog.csdn.net/sinat_35512245/article/details/53514804</a></p></li><li><p>函数表达式可以后面加括号立即调用，函数声明不可以</p></li><li><p>给函数声明整体加括号相当于将函数声明转换为函数表达式，就可以立即调用了</p><ul><li>两种立即执行函数的写法<code>( function(){…} )()</code>和<code>( function (){…} () )</code></li></ul></li></ul></li><li><p>call 比 apply的性能更好，因为传入的参数是函数需要的格式</p></li><li><p>对象中若有splice属性存放数组的splice方法以及length属性，会自动转为<code>object []</code>形式</p></li><li><p>dot notation比用[]读取对象的属性性能好</p></li><li><p>for的性能远高于forEach</p><ul><li>因为for循环没有额外的函数调用栈和上下文</li><li>forEach里操作了toObject以及循环终止等逻辑更加复杂</li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> front-end </tag>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端学习week12</title>
      <link href="/2019/07/21/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0week12/"/>
      <url>/2019/07/21/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0week12/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>​    学习时间正好三个月了， 本周学习了快排，这样排序算法就差堆排序没学了。本周的重点还是js的面向对象的概念，js除了几个基本数据类型(number,string,null,undefined)，其他的数组函数等都能视作对象，甚至基本数据类型也有包装对象的概念。要理解js的面向对象，原型和原型属性是非常重要的知识点，要理清数据类型的原型几个构造函数的原型属性之间的关系，接着是自定义构造函数。leetcode方面到了210题，但是感觉最近提升有限，似乎到瓶颈了，还是要多总结</p><a id="more"></a><h5 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h5><ul><li>sort方法的函数值参数为什么用两个参数，而不是一个？<ul><li>一个参数局限性大，两个更灵活，sort内部实现根据箭头函数的返回值来对元素排序，可以自定义排序条件</li></ul></li><li>排序算法的稳定性：<ul><li>排序前后不改变相同元素的相对位置</li><li>稳定：<ul><li>冒泡</li><li>归并</li><li>插入/BST</li><li>返回新数组的快排</li></ul></li><li>不稳定：<ul><li>选择排序</li><li>原地快排</li></ul></li></ul></li><li>快排<ul><li>主要思想是先随机取一个位置的数，将大于，等于， 小于它的数分组，再递归<ul><li>切分不平衡可能使排序效率较低，一个解决办法是排序前先将数组随机打乱</li></ul></li><li>当数组中所有数都相同时，时间复杂度会退化为n * n，调用栈也会达到n层</li><li>小数组时快排比插入排序慢</li><li>原地快排将取样元素放在数组末尾作为哨兵来优化partition</li></ul></li></ul><h3 id="深入理解对象"><a href="#深入理解对象" class="headerlink" title="深入理解对象"></a>深入理解对象</h3><ul><li>方法中的this指向当前方法所属的对象，相当于函数的隐含参数<ul><li>eg: apply() bind() </li></ul></li><li>this 是对象中的一个特殊变量</li><li>箭头函数根据当前的<a href="http://www.cnblogs.com/xiaohuochai/p/5700095.html" target="_blank" rel="noopener">词法作用域</a>而不是根据<a href="http://www.cnblogs.com/xiaohuochai/p/5737435.html" target="_blank" rel="noopener">this机制顺序</a>来决定this，所以，箭头函数会继承外层函数调用的this绑定，而无论this绑定到什么，且<strong>不能改变</strong>箭头函数的this绑定，可以当做箭头函数没有this</li><li>箭头函数不能用做构造函数，即其没有原型属性</li><li>箭头函数没有arguments属性</li></ul><h4 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h4><ul><li>对象都包含一个原型，原型也是一个对象，原型也有原型。。。Object.prototype是所有对象原型的父原型<ul><li><code>Object.prototype.__proto__</code>结果为<code>null</code></li></ul></li><li>访问对象中不存在的属性，会在其原型中搜索，接着是原型的原型，以此类推<ul><li>访问属性的优先级 对象自身 &gt; 原型</li><li>即对象和原型有同名属性有限调用对象自身的属性</li></ul></li><li><code>Object.getPrototypeOf()</code>获取对象的原型</li><li><code>Object.creat(prototype)</code>以原型创建对象<ul><li>传入null创建无原型对象</li></ul></li><li>原型和原型属性<ul><li>对象的原型：<code>obj.__proto__</code></li><li>原型属性： 每个函数（且一般只有函数才有）都有一个<strong>原型属性</strong> <code>f.prototype</code><ul><li>原型属性是一个对象，对象内的属性包含构造器标识（即这个函数）， 以及实例能调用的方法<ul><li>函数对象本身的属性可以在构造器标识内查看，这是实例不能调用的</li><li>即实例的constructor属性可以查看这个实例的构造函数</li></ul></li><li>这个概念是针对构造函数来说的，可以理解为本来有的原型基础上的衍生原型（添加了自己定义的属性），就是它会作为这个构造函数的实例的原型</li><li>因此<code>f.prototype.xxx</code>可以给构造函数的原型属性添加属性，这样这个构造函数的实例就能使用这个属性<ul><li>可枚举/不可枚举属性，默认创建的是可枚举（会出现在for/in循环中，不可枚举属性不会，但是可以用in返回true）</li></ul></li><li>原型属性是一个对象， 创建的实例的原型指向这个对象，修改构造函数的原型属性指向的对象，在这之前创建的实例的原型指向不会变</li></ul></li><li><code>Object.prototype.toString()</code>判断包装类型</li></ul></li></ul><h4 id="包装类型"><a href="#包装类型" class="headerlink" title="包装类型"></a>包装类型</h4><ul><li><strong>每当读取一个基本类型值的时候，后台就会创建一个对应的基本包装类型的对象，从而让我们能够调用一些方法来操作这些数据</strong></li><li>自动创建的基本包装类型的对象，则只存在于一行代码执行的瞬间，然后立即被销毁了。这就意味着，不能在运行时为基本类型值添加属性和方法。</li></ul><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><ul><li>调用函数前用<code>new</code>表示调用其构造函数<ul><li>new一定会返回对象，当构造函数返回的不是对象则会被忽略</li><li>注意用不用new的区别，不用new相当于给当前作用域的活动对象添加属性</li></ul></li><li>通过<code>new</code>创建的对象称为构造对象的<strong>实例</strong></li><li><code>instanceof</code>判断实例是不是某个构造函数（或者继承的父构造函数）创建的</li></ul><h4 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h4><ul><li>表达一个事物是离散存放的</li><li>封装： 把表达一个事务的最终信息及可能的操作（即函数）放在一起</li><li>同一类对象有相同的一组属性和一组函数</li><li>继承：让一个类直接获取另一个类所有的属性和方法</li><li>多态：不关心得到的事物具体是什么类别，更关心这个事物是否有某方面特性(有特定的一组属性和方法)</li></ul><h4 id="class"><a href="#class" class="headerlink" title="class"></a>class</h4><ul><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Classes" target="_blank" rel="noopener">Javascript 类</a></p></li><li><p>创建的方法不可枚举</p></li><li><pre><code class="js">class A {    static a(){}    static b(){}    constructor(){}    method1(){}    method2(){}    get length(){}    set length(val){}}typeof A == function</code></pre></li></ul><h4 id="零碎知识"><a href="#零碎知识" class="headerlink" title="零碎知识"></a>零碎知识</h4><ul><li>判断类型<ul><li><code>typeof</code> 用来判断原始类型</li><li><code>Object.prototype.toString.call</code>判断内置对象类型</li><li><code>instanceof</code>判断自定义对象类型  </li></ul></li><li><code>new.target === f</code>判断f是否正在被new调用</li><li><code>Object.defineProperty(obj, &#39;name&#39;, {})</code>给对象/原型添加属性<ul><li><code>{}</code>内依次为value，get，set，enumerable， writable， configurable</li><li>value和（get，set）只能出现一个</li></ul></li><li>直接给原型赋值对象， <code>name.protorype = {constructor: name,  xxxxx}</code></li><li>用<code>Array.prototype.slice().call(arguments)</code>在函数中创建参数的数组（arguments是类数组不能直接用数组方法），也可以用<code>[].slice().call(arguments)</code></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> front-end </tag>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端学习week11</title>
      <link href="/2019/07/14/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0week11/"/>
      <url>/2019/07/14/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0week11/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>​    本周主要学习了js高阶函数的用法，可以将函数作为参数传入另一个函数使用，熟悉几个自带的数组方法函数，另外简单介绍了一下JSON。数据结构学习了二叉树，前中后序遍历，搜索二叉树的性质，增删结点，加深理解还是要靠刷题。leetcode方面，本周到了160题，下周争取200，还是应该注重质量，算法方面动态规划是个难点，概念了解的差不多了，但是大部分题目感觉还是很难，另外这周一定要把算法部分的排序和二分查找部分看完</p><a id="more"></a><h4 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h4><ul><li><code>_</code>实参占位符</li><li>以函数值为实参没有产生闭包</li><li>函数的length属性返回形参的个数，name属性返回函数名</li></ul><h5 id="传参"><a href="#传参" class="headerlink" title="传参"></a>传参</h5><ul><li><p>函数的apply方法，将数组或类数组作为单独参数传入，防止多余的参数被忽略</p><ul><li>现在一般用省略号</li></ul></li><li><p>数组以函数为参数的方法</p><ul><li><p>forEach</p><ul><li>一个函数参数， 只是对各元素进行操作，没有返回值，<code>forEach</code>不直接改变调用它的对象，但是对象可能会被<code>callback</code>改变</li><li>只遍历存在的项，empty不遍历</li><li>除了抛出异常无法阻止forEach</li></ul></li><li><p>filter</p><ul><li>一个函数参数，返回包含通过测试的元素的新数组</li></ul></li><li><p>map</p><ul><li>一个函数参数，返回回调函数的结果的新数组</li></ul></li><li><p>reduce</p><ul><li>一个函数参数，数组第一项作为初始值，初始值变量分别和数组剩下的每个值会作为操作函数的参数，返回最后迭代后的值</li><li>初始值可选，如果没有提供初始值，则将使用数组中的第一个元素。 在没有初始值的空数组上调用 reduce 将报错</li><li>函数参数前一个形参是累计器，后一个是数组元素</li></ul></li><li><p>实际上前三个方法传入的参数为三个，分别为</p><ul><li>Current Value (cur) (当前值)</li><li>Current Index (idx) (当前索引)</li><li>Source Array (src) (源数组)</li></ul><p>reduce在最前面还有一个Accumulator (acc) (累计器)</p><p>给函数参数传入的参数也是这几个参数，所以需要<strong>注意</strong>接受多余的参数是什么，会造成什么后果，怎么利用</p></li></ul></li><li><p>函数值参数可简写为箭头函数</p><ul><li>只有一个参数时可以省略括号</li><li>只有一个return语句时可省略return和花括号</li></ul></li><li><p>函数的方法：</p><ul><li><p><code>bind(null, xx,xx)</code>，返回一个新的函数，相当于在原函数内给对应位置的参数附值绑定，返回的新函数就没有这个形参了，null后紧接着原函数的第一个参数，以此类推</p></li><li><pre><code class="js">function bind(f) {    var fixedArgs = Array.from(arguments).slice(1)    return function() {        var args = Array.from(arguments)        return f.apply(null, fixedArgs.concat(args))    }}</code></pre></li><li><p><code>apply</code>方法，用数组来指定函数的参数</p></li></ul></li></ul><h5 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h5><p>Javascript Object Notation</p><ul><li>属性名必须用双引号，只能包含简单的数据表达式，不能包含注释</li><li>parse 和 stringify函数</li><li>没有undefined</li><li>不能出现明文tab符</li><li>不能出现多余符号</li></ul><h4 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h4><ul><li>完全二叉树</li><li>前pre/中in/后序post遍历 traversal</li><li>排序二叉树BST<ul><li>结点左结点的值小，右结点的值大</li><li>中序遍历，得到有序序列    是一种<strong>插入排序</strong>，利用这点可以很快地判断是否为BST，是BST很重要的一个性质</li><li>添加结点</li><li>删除结点</li></ul></li></ul><h4 id="零碎知识"><a href="#零碎知识" class="headerlink" title="零碎知识"></a>零碎知识</h4><ul><li><p>toString方法可以将数字转为2-36进制的字符串</p></li><li><p>sort()方法默认情况下按照升序排列数组项，sort()方法会调用toString()转型方法，然后比较得到的字符串，即使我们比较的是数字，他也会<strong>把数字转为字符串以后再排序</strong></p></li><li><p>关于动态规划(dynamic programming)的理解</p><ul><li>每个阶段只有一个状态-&gt;递推；</li><li>每个阶段的最优状态都是由上一个阶段的最优状态得到的-&gt;贪心；</li><li>每个阶段的最优状态是由之前所有阶段的状态的组合得到的-&gt;搜索；</li><li>每个阶段的最优状态可以从之前某个阶段的某个或某些状态直接得到而不管之前这个状态是如何得到的-&gt;动态规划。</li><li>动态规划的三个组成：<strong>最优子结构</strong>，<strong>边界</strong>， <strong>状态转移</strong></li><li>递归是自顶向下的，而动态规划的本质是自底向上的</li><li>解决动态规划/递归中的重复计算<ul><li>“备忘录算法”：将递归中计算过的值存入哈希表</li><li>自底向上递推，动态存储下次计算需要的状态</li></ul></li></ul></li><li><p>归并排序</p><ul><li>基本思想是将数组递归地分成两半分别排序，再将结果归并</li><li>优化： <ul><li>小规模子数组可以使用插入排序</li><li>增加一个判断：<code>arr[mid] &lt; arr[mid + 1]</code>时可认为数组已经有序，跳过merge，直接连接</li></ul></li><li>一般是自顶向下的方法，也可自底向上两两归并，四四归并。。。。这种方式适合处理链表原地排序</li></ul></li><li><p>数组的includes方法可以正确判断NaN，indexOf不行</p></li><li><p><code>Array.from()将类数组对象转为数组</code></p></li><li><p><strong>arguments</strong> 是一个对应于传递给函数的参数的<strong>类数组对象</strong></p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> front-end </tag>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端学习week10</title>
      <link href="/2019/07/07/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0week10/"/>
      <url>/2019/07/07/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0week10/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>​    本周主要学习了数组和对象这两种数据结构，在js中，除了集中原始值，其他数据结构都能视作对象，另外简单介绍了一下链表，js中的链表结构比较简单，操作也很方便。需要理解的是对象标识符指向对象的存储地址(这也比其他语言简单很多)，另外就是js数组和字符串的一些方法函数，需要在使用中加强记忆。</p><p>​    leetcode刷到了100题，熟练度确实有点用，应该抽出点时间review，下周争取130+，另外看完算法的排序部分</p><a id="more"></a><h4 id="UTF-8-变长编码"><a href="#UTF-8-变长编码" class="headerlink" title="UTF-8 变长编码"></a>UTF-8 变长编码</h4><ul><li>第一个字节的前几位表示这个字符占用多少个字节<ul><li>一个字节01xxxxxx</li><li>两个字节110xxxxx</li><li>三个字节1110xxxx</li><li>四个字节11110xxx</li></ul></li><li>之后的每个字节的都是10开头，因此不同字节长度实际存储该字符所占二进制位：<ul><li>一个字节： 6</li><li>两个： 5 + 6 </li><li>三个： 4 + 6 + 6</li><li>四个： 3 + 6 + 6 + 6</li></ul></li><li>特点：<ul><li>变长</li><li>兼容标准ASCII</li><li>容错</li></ul></li></ul><h4 id="数组和对象"><a href="#数组和对象" class="headerlink" title="数组和对象"></a>数组和对象</h4><ul><li>读取null和undefined的属性会报错</li><li>用<code>.</code>和<code>[]</code>都可以方问属性，但是点后直接跟属性名，方括号会计算其中的表达式并把返回值作为属性名<ul><li>属性名是字符串</li><li>可以使用方括号访问数字或带空格的字符串作为属性名的属性</li></ul></li><li>数组是值的有序集合，对象是值的具名集合</li><li><code>delete obj.a</code>  一元运算符   删除对象中的a属性</li><li><code>str in obj</code> 二元运算符  返回布尔值，对象中是否有这个属性<ul><li>in用在数组中是检测这个位置是否为<strong>空</strong>，并不是是否存有这个值</li></ul></li><li>indexOf只能检索大于等于0的整数下标，其他都返回-1</li><li><code>for (name in obj)</code>  遍历对象的属性 ，属性名字符串传给name   <ul><li>这里的in不是运算符</li></ul></li><li>对象的浅比较和深比较<ul><li>== 和 === 比较的是对象是否是同一个引用</li><li>深比较是比较属性和值是否相同而不论是否是同一个引用，js没有深比较的api，需要自己实现</li></ul></li><li>一些数组的方法<ul><li>fill(item, start, end)  填充，不包括end位置，start和end都省略则填充empty</li><li>flat()   展开一级，返回新数组  里面有对象不展开</li><li>include(value)  判断数组中是否有这个值，返回布尔值   不能判断对象，除非是同一个引用</li></ul></li><li>给原始值添加对象和读取对象，不会报错但会读取undefined，可以用Object()创建原始类型(对象)的包装对象(一个真实的对象包装了一个原始类型)     不建议使用</li><li>字符串的trim()方法，删除开头和结尾的空白符号(空格，换行，制表等)</li><li>arguments对象很像数组，有length属性， 但不包含任何数组方法， 是一个类数组对象</li><li>类数组对象：任何一个具有length属性以及对应非负整数属性的对象<ul><li>类数组对象不能直接使用数组方法，但是可以<code>Array.methods.call(obj, xxx)</code>调用数组方法</li></ul></li><li><code>Array.from()</code> 方法从一个类似数组或可迭代对象中创建一个新的，浅拷贝的数组实例</li><li><code>...</code>省略号运算符<ul><li>rest parameter  剩余参数，只能出现一次且只能出现在形参最后</li><li>spread operator  展开数组和对象，展开对象时只能用在创建对象和数组的字面量时使用，因为展开形式为对象中属性及对应值的表达式</li></ul></li><li>可以给形参赋值作为缺省的默认值</li></ul><h4 id="零碎知识"><a href="#零碎知识" class="headerlink" title="零碎知识"></a>零碎知识</h4><ul><li><p>递归四条准则</p><ul><li>基准情形</li><li>不断推进</li><li>设计法则</li><li>合成效益法则</li></ul><p>使用递归时注意递归过程中<strong>重复计算</strong>的问题，可以储存各计算结果当遇到这个计算时直接返回值</p><p>不要使用全局变量(除非刻意要用)</p><p>注意返回新对象还是在原对象上操作的一致性</p></li><li><p>document.write()</p><ul><li>向文档解析流写入内容</li><li>文档一旦解析完成<code>&lt;/html&gt;</code>，解析流关闭</li><li>重新write会导致重新打开一个解析流，之前的内容完全覆盖</li></ul></li><li><p>排序算法</p><ul><li>希尔shell排序<ul><li>希尔排序的思想是 将原数组中间隔h的子数组使用插入排序，循环减少h至h=1即排序完成</li><li>实际是插入排序的优化版，能将离本来位置较远的元素更快地移动到本来的位置</li><li>实际使用中是性能最好的初级排序</li></ul></li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> front-end </tag>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端学习week9</title>
      <link href="/2019/06/30/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0week9/"/>
      <url>/2019/06/30/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0week9/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>​    本周正式开始了一边学习js基础一边leetcode的刷题，才发现自己的数学基础真的很薄弱，果然以前欠的都是要还的，只能慢慢训练了，以后坚持每天刷两道题以上，每周复习一次之前刷过的题目，争取结课前能突破500。</p><p>​    js方面，本周主要学习了初级函数的定义，一个重要的知识点是闭包，不同书对闭包的定义可能有出入，但是本质是大体一样的，就是每次函数调用都会创建一个新的作用域，这个作用域和同一个函数的其他作用域不会相互影响。其他就是一些细枝末节的东西，应当经常复习</p><a id="more"></a><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><ul><li><p>在if或循环中最好不要写函数申明</p><ul><li><pre><code class="js">function a() {}    //不同浏览器可能会出现问题&lt;p class=&quot;code-caption&quot; data-lang=&quot;&quot; data-line_number=&quot;frontend&quot; data-trim_indent=&quot;backend&quot; data-label_position=&quot;outer&quot; data-labels_left=&quot;Code&quot; data-labels_right=&quot;:&quot; data-labels_copy=&quot;Copy Code&quot;&gt;&lt;span class=&quot;code-caption-label&quot;&gt;&lt;/span&gt;&lt;a class=&quot;code-caption-copy&quot;&gt;Copy Code&lt;/a&gt;&lt;/p&gt;</code></pre></li><li><p>但是可以写函数表达式赋值</p></li><li><pre><code class="js">var a = function() {}</code></pre></li></ul></li><li><p>传参</p><ul><li>都是值传递<ul><li>arguments 得到所有传入实参的数组</li></ul></li><li>传入的实参为对象时，可以修改对象的属性，这一点很像const声明的常数变量为对象时可以修改其对象<ul><li>其他情况对传入的参数赋值等操作实际都是对arguments的项的操作，不能影响原来的变量</li></ul></li><li>多余的参数会被忽略</li><li>少传的参数会被赋值为undefined</li></ul></li><li><p>闭包</p><ul><li><strong>局部变量在每次函数调用时都会重新创建</strong>，且函数调用不会对其他函数调用内的局部变量产生影响</li><li>包装了局部变量的函数就叫做一个闭包</li></ul></li></ul><h4 id="零碎知识"><a href="#零碎知识" class="headerlink" title="零碎知识"></a>零碎知识</h4><ul><li><p><code>101..toString(2)</code>第一个点为数字小数点</p></li><li><p>数组的splice方法有三个参数，分别为位置，删除的个数， 和要添加的元素，可以将要删除的个数置零用作向某位置插入元素</p></li><li><p>可以在循环最外面加标签的方法跳出多重循环</p><ul><li><pre><code class="js">loop:for(xxxx) {    for(xxxxx){        break loop            }}&lt;p class=&quot;code-caption&quot; data-lang=&quot;&quot; data-line_number=&quot;frontend&quot; data-trim_indent=&quot;backend&quot; data-label_position=&quot;outer&quot; data-labels_left=&quot;Code&quot; data-labels_right=&quot;:&quot; data-labels_copy=&quot;Copy Code&quot;&gt;&lt;span class=&quot;code-caption-label&quot;&gt;&lt;/span&gt;&lt;a class=&quot;code-caption-copy&quot;&gt;Copy Code&lt;/a&gt;&lt;/p&gt;</code></pre></li></ul></li><li><p>数组的push, pop，unshift返回的是修改后数组的长度，shift返回的是取出的值，splice返回的是删除的数组</p></li><li><p>空数组取非的布尔值是false，但是空数组转换成数字是0，而且空数组==false返回的是true</p></li><li><p>函数表达式赋值声明</p><ul><li><pre><code class="js">var a = function b () {}     // b标识符可用于函数内的递归操作，一般省略</code></pre></li></ul></li><li><p>js的无符号右移<code>&gt;&gt;&gt;</code>即便没有发生实际位移，即位移位数为0，也会将前面的位数置0，并转为无符号数</p><ul><li>非数值<code>&gt;&gt;&gt;0</code>会得到0</li><li><code>-1 &gt;&gt;&gt; 0</code>会得到<code>2 ** 32</code></li></ul></li><li><p>unsigned = signed &gt;&gt;&gt; 0<br>通过使用无符号右移运算符，位动位数为0，可以将32位有符号整数，转化为32位无符号整数。</p><ul><li>signed = unsigned &lt;&lt; 0<br>通过使用左移运算符，位动位数为0，可以将32位无符号整数，转化为32位有符号整数。</li></ul></li><li><p><code>??</code>可用来代替<code>||</code>当不需要短路特性时</p></li><li><p>在不声明直接初始化的变量之前引用这个变量会直接报错，并不会声明提升</p></li><li><p>一般用判断长度的方法来判断数组是否为空，<strong>注意</strong>不能用<code>array == []</code>来判断，因为<code>[]</code>相当于<code>new Array()</code>相当于声明了一个新的空数组，程序会自动在堆中为其开辟一块内存空间，它和之前array的内存空间不是同一块，所以自然不相等</p><ul><li>Object用等号比较的是内存地址，是否引用了同一个值</li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> front-end </tag>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端学习week8</title>
      <link href="/2019/06/19/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0week8/"/>
      <url>/2019/06/19/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0week8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>​    本周划水有点厉害，主要还是复习了一边js中数值类型的存储方式，即双精度浮点数(见上周内容)，需要注意的是双精度浮点数虽然能表示很大的数，但是有其能精确表示的数的范围，这是由其只有64位决定的，只有位运算的32位整型中负数是由补码表示的，js中只出现这两种存储格式，其他仅作了解。</p><p>另外linux真的不知道该怎么学，本来想利用空余时间学习点linux的知识，以后面试能吹点牛皮，然而那么多命令看过就忘了，只记得一点点基本概念。</p><a id="more"></a><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><ul><li>变量的声明忌讳直接在前面声明一大坨，即插即用即可(反正编译的时候会全部提到前面)，因此，js可以调用语句后面声明的变量和值。即声明提升(hoisting)：变量在声明它们的函数体以及这个函数体嵌套的任意函数体内都是有定义的，<strong>注意声明会提升但是赋值不会</strong>。函数声明也有这样的特性</li><li>注意局部变量和全局变量</li><li>js的全局变量是全局对象的属性，用var声明的不可配置，而赋值声明的可以配置删除</li><li>局部变量可以覆盖重定义全局变量，然而只在局部生效</li></ul><h4 id="零碎知识"><a href="#零碎知识" class="headerlink" title="零碎知识"></a>零碎知识</h4><ul><li><pre><code class="js">var i = 0i = i++console.log(i)//会输出什么结果//答案： 输出 0 //原理： 先将i = 0 的赋值操作入栈，再将i + 1 入栈再按顺序出栈，最后得到的结果是将i赋值为0</code></pre></li><li><p>变量名由<code>$</code>，字母，数字，下划线组成，只有<strong>数字不能用作开头</strong></p></li><li><p>涉及return、break、continue、throw语句的场景中。如果这四个关键字后紧跟着换行，javascript会在换行处填补分号</p></li><li><p>++和–运算符单独一行时，会作为下一行的前缀解析</p></li><li><p>js是变量松散类型语言，可以给变量赋不同数据类型的值，但<strong>不建议</strong>这么做</p></li><li><p>var语句可以省略，直接对变量赋值会自动声明该变量，但在es5的严格模式下会报错，而且函数内未声明且直接赋值的变量会声明为全局变量，所以<strong>不推荐省略</strong></p></li><li><p>由于undefined并不是一个关键字，其在IE8-浏览器中会被重写，在高版本函数作用域中也会被重写；所以可以用void 0 来替换undefined</p></li><li><p>不同的对象在底层都表示为二进制，在javascript中二进制前三位都为0会被判断为object类型，null的二进制表示是全0，所以执行typeof时返回’object’</p><ul><li>所以判断一个值是否为null类型的最佳方法是直接和null进行恒等比较</li></ul></li><li><p>在Number()方法中空字符串和空白字符串都转换为0，而在Boolean方法中，空字符串””转换为false，而空白字符串” “转换为true</p><ul><li>自动类型准换中布尔类型只有七个假值(falsy value)，这7个值包括undefined、null、+0、-0、NaN、false、””(空字符串) 转换为false，其他任何情况都转换为true</li></ul></li><li><p>Number(‘’)的结果是0，parseInt(‘’)和parseFloat(‘’)的结果是NaN</p></li><li><p>null和undefined没有toString()方法，而String()函数在非undefined和null会调用toString()方法</p><ul><li>一般使用空字符串”” + 某个值，将该值转换为字符串</li></ul></li><li><p>字符串的substring(start, end)和slice(start, end)方法(substr() 已弃用)</p><ul><li>slice(start, end)<ul><li>返回从start位置到end(不包括)的字符串</li><li>如果end为undefined或不存在，则返回从start位置到字符串结尾的所有字符</li><li>如果start是负数，则start = max(length + start,0)</li><li>如果end是负数，则end = max(length + end,0)</li><li>start和end无法交换位置 start &lt; end时输出空字符串</li><li>start/end被传入NaN时相当于传入0</li></ul></li><li>substring(start, end)<ul><li>如果end为undefined或不存在，则返回从start位置到字符串结尾的所有字符</li><li>如果任一参数是NaN或负数，则被0取代</li><li>如果任一参数大于字符串长度，则被字符串长度取代</li><li>如果start 大于 end，则交换它们的值</li></ul></li></ul></li><li><p>数组的最大长度为2的32次方-1</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> front-end </tag>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端学习week7</title>
      <link href="/2019/06/16/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0week7/"/>
      <url>/2019/06/16/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0week7/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>​    本周将css的学习进行了收尾工作，介绍了目前还存活的css框架Bootstrap，重点在于grid layout系统是如何实现的。接下来进入了Javascript基础的学习，对于js的基础数据类型，这里坑比较多，按照比较受认可的《高程》的说法是五种数据类型，其中null和undefined分别为一种，特别注意的是number类型这里坑很多</p><a id="more"></a><h4 id="Bootstrap"><a href="#Bootstrap" class="headerlink" title="Bootstrap"></a>Bootstrap</h4><p>css框架</p><ul><li>grid layout<ul><li>version 3.4 <ul><li>浮动实现  宽度百分比</li></ul></li><li>version 4.3 <ul><li>flex  利用flex特性</li></ul></li></ul></li></ul><h2 id="Javascript"><a href="#Javascript" class="headerlink" title="Javascript"></a>Javascript</h2><h3 id="值，类型，运算符"><a href="#值，类型，运算符" class="headerlink" title="值，类型，运算符"></a>值，类型，运算符</h3><p><strong>five basic types of values in JavaScript</strong>: numbers, strings, Booleans, null, and undefined values.</p><p><strong>使用<code>typeof (null)</code></strong>返回的是object</p><h4 id="number"><a href="#number" class="headerlink" title="number"></a>number</h4><ul><li><p>js使用64位固定长度存储数字，其中一位表示正负，一位表示小数点位置。</p><p><a href="https://www.cnblogs.com/jillzhang/archive/2007/06/24/793901.html" target="_blank" rel="noopener">浮点数在计算机中的存储方式</a></p><p>补充： 对于64位双精度的11位符号位，是采取移位方式存储的，范围为(-1023 - 1024)，即(2^11 -1)加上E的值</p><p><img src="http://chart.googleapis.com/chart?cht=tx&chl=V%20%3D%20(-1)%5Es%5Ctimes%20M%5Ctimes%202%5EE&chs=45" alt></p><p>特例： 0 在浮点数中特殊存储为全0，-0首位为1。infinity：指数全1，尾数全0。NaN：指数全1，尾数第一位为1</p><p><a href="http://2ality.com/2012/04/number-encoding.html" target="_blank" rel="noopener">How numbers are encoded in JavaScript</a></p><ul><li><p>1位符号位，11位指数位(exponent)，52位数值位，最大的数为2**53 -1, 再大的数就要占用exponent位，此时+1不会影响数值，因为相当于向左移了一位，最后一位补零，而数值位只能有52位</p></li><li><p>存储的小数用二进制表示时可能会丢失精度(超过64位)</p></li><li><p>所有的数字类型,在JavaScript中,都是双倍精度的浮点数类型，每一个数字,都是使用64位(8字节)来存储</p></li><li><p>对于<strong>位运算</strong>, JavaScript会首先把浮点数转换成32位的整型来进行处理,而不是直接对浮点型进行操作.准确的来说,是转换成<code>32位</code>,<code>大端序</code>, <code>补码</code>, <code>有符号</code>的整型，因为整型不能表示小数，转换时会把小数部分抹去。转换时整数部分超过32位则保留右边32位<del>转换过程是将52位数值位的前20位<strong>抹掉</strong>，32位有符号整型的第一位作为符号位，此时负数为补码形式存储。</del>位运算之后再转为64位，负数补1，正数补0</p><p><a href="https://juejin.im/entry/587d8b4861ff4b006509784f" target="_blank" rel="noopener">了解 JavaScript 的 Number 类型</a></p></li></ul></li><li><p>special numbers</p><ul><li>Infinity     超过能存储的最大值的数字</li><li>-Infinity</li><li>NaN   not a number  无意义的结果以及NaN参与运算的结果</li></ul></li></ul><h4 id="strings"><a href="#strings" class="headerlink" title="strings"></a>strings</h4><p>Javascript使用UCS-2编码，<strong>所有字符在这门语言中都是2个字节，如果是4个字节的字符，会当作两个双字节的字符处理</strong><a href="http://www.ruanyifeng.com/blog/2014/12/unicode.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2014/12/unicode.html</a></p><ul><li>单双引号没有区别</li><li>字符串只能放在一行，所以不能出线明文回车</li></ul><h4 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean"></a>Boolean</h4><ul><li><p>比较</p><ul><li><p>字符串比较： 按照字母顺序第一个能比较的字符按ascii值比较决定大小</p></li><li><pre><code class="js">console.log(NaN == NaN)// → false//Infinity的比较也是false，因为无穷大不一定精确相同</code></pre></li></ul></li><li><p>逻辑</p></li></ul><h4 id="自动类型转换-隐式类型转换"><a href="#自动类型转换-隐式类型转换" class="headerlink" title="自动类型转换(隐式类型转换)"></a>自动类型转换(隐式类型转换)</h4><ul><li>== 两侧存在null或undefined时，只有两边都为null或undefined才为true</li><li>布尔类型转换： 0, NaN, “” 视为false</li><li>===  !==  严格比较，不会发生类型转换</li><li>boolean == string 永远为false</li><li><code>+</code>号运算符作为<em>一元运算</em>符时，Expression将进行ToNumber()操作 <a href="https://www.cnblogs.com/polk6/p/js-adv-addopr.html" target="_blank" rel="noopener">加号运算符详解</a><ul><li>在new Date()前面使用一元加符号，可以把日期字符串，转换为日期毫秒数</li></ul></li><li>a++ 会将a的数据类型转为number</li></ul><h5 id="逻辑运算符短路特性"><a href="#逻辑运算符短路特性" class="headerlink" title="逻辑运算符短路特性"></a>逻辑运算符短路特性</h5><ul><li><p>当 || 和  &amp;&amp; 两侧表达式返回的<strong>不是布尔值</strong>时触发短路特性</p></li><li><p>||  左侧可以转为true时返回左边的值，用于添加右边的默认值fallback，当左边为false时返回默认值</p></li><li><p>&amp;&amp; 左侧可以转为false时返回左边的值，左边为true时返回默认值</p></li><li><p>只要左侧返回，右边会被直接忽略</p></li></ul><h4 id="Others"><a href="#Others" class="headerlink" title="Others"></a>Others</h4><ul><li><p>位运算</p><p>只有整数才能做位运算</p><ul><li><code>|</code> 按位或</li><li><code>&amp;</code> 按位与     注意负数是补码形式</li><li><code>^</code> 按位异或</li><li><code>~</code> 按位非</li><li><code>&gt;&gt;</code> 按位右移   保留符号位(负数左边补1，正数补0</li><li><code>&gt;&gt;&gt;</code> 按位右移  不保留符号 (都补0)</li><li><code>&lt;&lt;</code>  按位左移 右边补0</li></ul></li><li><p>逗号运算符：逗号运算符的作用是将若干表达式连接起来。它的优先级是所有运算符中<strong>最低</strong>的，结合方向是自左至右，返回最后一个表达式的值。请注意：<strong>并不是所有的逗号都要看成逗号运算符</strong>，如在函数调用时，各个参数是用逗号分隔开的，这里的逗号并不是逗号运算符。</p></li><li><p>void运算符：出现在操作数之前，操作数正常计算，但忽略结果返回undefined</p></li></ul><h3 id="程序结构"><a href="#程序结构" class="headerlink" title="程序结构"></a>程序结构</h3><ul><li><p>当一行的开头是+，-，/,  [ ,  ( ,  ` ，前一行必须加分号 ，可以把分号写在这行开头，其他时候建议<strong>不写分号</strong><a href="https://www.cnblogs.com/fsjohnhuang/p/4154503.html" target="_blank" rel="noopener">JS的自动分号插入机制</a></p></li><li><p>所有不在引号里且不为保留字和标识符的都是变量</p></li><li><p>变量名只能以$ , _ ,字母开头，可以包含数字，不能包含空格和其他ascii码范围内的符号</p></li><li><p>在控制台所有表达式都有一个返回值 </p></li><li><p>注意isNaN()和Number.isNaN()的区别</p><ul><li>isNaN() ： 是否不是数字类型，这里非常奇怪，因为NaN自己就是数字类型</li><li>Number.isNaN() ： 是否是NaN这个值，除了NaN都返回false</li></ul></li><li><p><a href="http://2ality.com/2012/09/expressions-vs-statements.html" target="_blank" rel="noopener">Js语句和表达式的区别</a></p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> front-end </tag>
            
            <tag> css </tag>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>写给新手看的stylus简单教程</title>
      <link href="/2019/06/12/%E5%86%99%E7%BB%99%E6%96%B0%E6%89%8B%E7%9C%8B%E7%9A%84stylus%E7%AE%80%E5%8D%95%E6%95%99%E7%A8%8B/"/>
      <url>/2019/06/12/%E5%86%99%E7%BB%99%E6%96%B0%E6%89%8B%E7%9C%8B%E7%9A%84stylus%E7%AE%80%E5%8D%95%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>​    学css那肯定就离不开预处理，预处理的作用相当于在css上面再套了一层壳，用更简洁更高级的方式来写样式，剩下的就交给编译器编译成css代码，但要记住预处理只不过是工具而已，能不能写好是建立在css的基本功学扎实的基础之上的，特别是进入css3时代，原生css即能方便实现的功能越来越多，预处理显得又不那么重要了，但是后面学习使用框架时似乎能用到，那么还是好好学习一下，这篇文章的是写给像我一样刚接触css时看到预处理器的文档一脸懵逼不知道如何下手的同学，顺便记录一些能用上的奇技淫巧。</p><a id="more"></a><p>这里选择了相对冷门的stylus，因为写起来不需要花括号，分号甚至不需要声明的冒号，写起来相当优雅<del>简单省事</del></p><h3 id="嵌套"><a href="#嵌套" class="headerlink" title="嵌套"></a>嵌套</h3><p>嵌套是预处理器最有特色的东西了，在stylus中是利用缩进实现的层层嵌套，编译时会从最外层的选择器一直到最里层，但要注意的是嵌套随然好用，但是最好不要超过2层，因为css中尽量不要体现html中的结构</p><h3 id="amp"><a href="#amp" class="headerlink" title="&amp;"></a>&amp;</h3><p>这个符号相当重要，它是缩进使用的，代表其被嵌套的父选择器，其实就是一种省略的写法。</p><p>其实有了嵌套和&amp;,就已经可以完成大部分的工作了。接下来算是一些高级点的用法</p><h3 id="Mixin"><a href="#Mixin" class="headerlink" title="Mixin"></a>Mixin</h3><p>混合，其实就是其他编程语言中的函数，在需要调用的地方打上函数名，编译时会自动加入自定义的内容</p><h3 id="extends"><a href="#extends" class="headerlink" title="@extends"></a>@extends</h3><p>在其他选择器下使用<code>@extend [name]</code>可以将[name]选择器下的所有属性都加入。</p><h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><h4 id="循环生成多个选择器"><a href="#循环生成多个选择器" class="headerlink" title="循环生成多个选择器"></a>循环生成多个选择器</h4><ul><li><pre><code class="scss">for $num in (1..100)    .a-{$num}        color red&lt;p class=&quot;code-caption&quot; data-lang=&quot;&quot; data-line_number=&quot;frontend&quot; data-trim_indent=&quot;backend&quot; data-label_position=&quot;outer&quot; data-labels_left=&quot;Code&quot; data-labels_right=&quot;:&quot; data-labels_copy=&quot;Copy Code&quot;&gt;&lt;span class=&quot;code-caption-label&quot;&gt;&lt;/span&gt;&lt;a class=&quot;code-caption-copy&quot;&gt;Copy Code&lt;/a&gt;&lt;/p&gt;</code></pre></li></ul><p>以上代码生成</p><ul><li><pre><code class="css">.a-1 {  color: #f00;}.a-2 {  color: #f00;}.a-3 {  color: #f00;}</code></pre></li></ul><p>通过这种方式我们可以快捷生成多个用数字排序的选择器</p><p>主要有一下几个点：</p><ul><li>变量前加$是为了与正常字符串区分，可以不加</li><li>拼接字符串使用<code>{}</code></li><li>循环范围使用<code>(1..10)</code>两个小数点，且包含1和10</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> front-end </tag>
            
            <tag> css </tag>
            
            <tag> stylus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端学习week6</title>
      <link href="/2019/06/06/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0week6/"/>
      <url>/2019/06/06/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0week6/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>​    本周继续学习了CSS3的一些重要属性，重点有以下几个：列布局，渐变，2D/3D变换，还有渐变及动画。列布局与flex相比的优势在于实现一些单元素的多列布局，更类似于报纸杂志等文字排版。渐变主要应用于背景图片的颜色渐变，注意与混色模式搭配可以生成一些很有意思的效果。transform，transition及animation搭配生成页面中的动画效果，注意变换是不影响布局的，渲染的元素会默认覆盖在其他正常元素之上，渐变及动画的区别在于渐变是用时间控制，而动画是用帧来控制，且动画可以实现无限循环的动画。CSS3的基本概念的学习到这里应该就告一段落了。</p><a id="more"></a><h3 id="CSS3"><a href="#CSS3" class="headerlink" title="CSS3"></a>CSS3</h3><h4 id="multiple-column"><a href="#multiple-column" class="headerlink" title="multiple column"></a>multiple column</h4><ul><li><code>column-count: columns;</code>将块元素折断</li><li>不能折断inline-block/inline     图片可以<ul><li><code>break-inside: avoid-column;</code> 可设置不折断</li></ul></li><li><code>column-width</code>不支持百分比与负值值</li><li><code>column-fill: ;</code><ul><li>balance 默认</li><li>auto</li></ul></li><li>同时设置<code>column-count</code>和<code>column-width</code>，前者作为最大列数，后者为每列最小宽度，可以都转化为count，哪个小哪个生效</li><li><code>column-gap</code>  支持百分比</li><li><code>column-rule</code>  列间边框样式，不影响布局</li></ul><h4 id="border-and-box-effects"><a href="#border-and-box-effects" class="headerlink" title="border and box effects"></a>border and box effects</h4><ul><li>border-radius<ul><li>border-top-right-radius   先垂直方向再水平方向</li><li>百分比值/具体数值 大于元素高度或宽度时会等比缩小</li><li>百分值分别为高度和宽度的百分比</li></ul></li><li>border-image</li></ul><h4 id="opacity-amp-color"><a href="#opacity-amp-color" class="headerlink" title="opacity &amp; color"></a>opacity &amp; color</h4><ul><li>添加opacity属性会触发图形加速</li><li>未设置z-index且设置过opacity的图层会盖住其他内容，实际上是渲染成了一张图片</li></ul><h4 id="gradients"><a href="#gradients" class="headerlink" title="gradients"></a>gradients</h4><ul><li>linear-gradient值生成的是图片 用于<code>background-image</code></li><li>linear-gradient(deg/direction, color1 color-stop, color2 color-stop)  color-stop写像素值是这个color-stop距开始的位置，若这个值小于前一个color-stop则会被重置为前一个的值</li><li>repeating-linear-gradient</li><li>radial-gradient</li><li>conic-gradient</li></ul><h4 id="transformations"><a href="#transformations" class="headerlink" title="transformations"></a>transformations</h4><ul><li><p>2D </p><ul><li><p>transform: func ;</p><ul><li><p>rotate()</p></li><li><p>translateX/translateY/translate(X, Y)   取百分值为自身的宽高</p></li><li><p>scaleX/scaleY/scale(X, Y)  value为缩放倍数，负值翻转，坐标轴的刻度也会缩放</p></li><li><p>skewX/skewY/skew(X, Y)  倾斜</p></li><li><p>matrix(a, b, c, d, X, Y)  坐标变换 ，前四位矩阵，后两位平移</p><p><a href="https://www.zhangxinxu.com/wordpress/2012/06/css3-transform-matrix-矩阵/" target="_blank" rel="noopener">https://www.zhangxinxu.com/wordpress/2012/06/css3-transform-matrix-%E7%9F%A9%E9%98%B5/</a></p></li><li><p>不影响布局，但是会盖住其他元素</p></li><li><p>渐变时若函数名和数量相同，则每个函数值单独渐变，否则直接变化（未设置的值会被重置为默认值）</p></li><li><p>平移尽量使用transform，显卡图层直接渲染，速度快 </p></li></ul></li><li><p><code>transform-origin: value;</code></p><ul><li>不动点</li></ul></li></ul></li><li><p>3D</p><ul><li><p>x-axis向右 y-axis向下 z-axis向外 z-axis随元素旋转变化</p></li><li><p>rotateX/rotateY/rotateZ</p></li><li><p>rotate3d(x, y, z, angle)</p></li><li><p>perspective  景深</p><p>“viewport” 沿z-axis与xoy平面的距离   一般设置为1000px左右</p><p>不能与rotate属性分开写，会覆盖失效，且必须写在第一位否则会被忽略</p><p>单独写在父元素中相当于给每一个子元素增加属性</p><p>值为0或none时相当于不观察该元素，元素投影在父元素上，0和none有一点区别但我不知道为什么</p></li><li><p>scaleZ</p></li><li><p>martix3D</p></li><li><p><code>perspective-origin: x, y;</code>“viewport”原点在xoy平面位置</p></li><li><p><code>transform-style: preserve-3D</code> 更符合实际，用在变换元素的父元素上</p></li><li><p><code>backface-visibility: hidden;</code>更符合实际，使后面元素不可见</p></li></ul></li></ul><h4 id="transition-amp-animation"><a href="#transition-amp-animation" class="headerlink" title="transition &amp; animation"></a>transition &amp; animation</h4><ul><li><p>transition</p><ul><li><p>transition-property 默认为all</p></li><li><p><code>transition-timing-function: value;</code> 距离时间函数</p><ul><li><p>ease/linear/ease-out/ease-in-out</p></li><li><p>cubic-bezier(x1, y1, x2, y2)</p><p>应当抽时间好好学习一下贝塞尔函数<a href="https://www.zhangxinxu.com/wordpress/2014/06/deep-understand-svg-path-bezier-curves-command/" target="_blank" rel="noopener">https://www.zhangxinxu.com/wordpress/2014/06/deep-understand-svg-path-bezier-curves-command/</a></p></li><li><p>steps()</p></li></ul></li><li><p>transition-delay可以为负值，动画直接从中间开始</p></li></ul></li><li><p>animation</p><ul><li>@keyframes<ul><li>from = 0%  to = 100%</li></ul></li><li>animation-iteration-count  迭代次数<ul><li>infinite </li></ul></li><li>animation-direction<ul><li>normal  重复时直接从结束帧跳到开始帧</li><li>alternate 重复时从结束帧反向播放</li></ul></li><li>animation-timing-function<ul><li>steps()</li></ul></li><li>animation-fill-mode<ul><li>none / backwards 动画前为0%状态 / forwards 结束时保留100%状态/both</li></ul></li><li>animation-play-state: running/paused</li><li>实现切片轮播图：<ul><li><a href="https://tympanus.net/Tutorials/CSS3SlidingImagePanels/?tdsourcetag=s_pctim_aiomsg" target="_blank" rel="noopener">https://tympanus.net/Tutorials/CSS3SlidingImagePanels/?tdsourcetag=s_pctim_aiomsg</a></li></ul></li></ul></li></ul><h3 id="零碎知识"><a href="#零碎知识" class="headerlink" title="零碎知识"></a>零碎知识</h3><ul><li><p>给body设置<code>overflow: hidden</code>不能触发BFC</p><p>原因：<code>overflow:visible</code>以外的<strong>块级</strong>元素将创建BFC，<strong>除非该值已经扩散到了视口</strong>。</p><p><a href="https://segmentfault.com/q/1010000002645174" target="_blank" rel="noopener">https://segmentfault.com/q/1010000002645174</a></p></li><li><p>div么有内容，只有width且height为0时，transform-origin为最左侧</p></li><li><p>max-content/min-content</p><p><a href="https://www.zhangxinxu.com/wordpress/2016/05/css3-width-max-contnet-min-content-fit-content/" target="_blank" rel="noopener">https://www.zhangxinxu.com/wordpress/2016/05/css3-width-max-contnet-min-content-fit-content/</a></p><p>width属性的值</p><p>min-content的包裹性(块元素绝对定位，浮动，inline-block时的宽度)，max-content使所有内容不这行</p></li><li><p>background-blend-mode</p></li><li><p>filter</p><ul><li>blur(  x px) 模糊效果</li></ul></li><li><p>一定要记住： 给元素绝对定位或者浮动会使其自动变为block</p></li><li><p>使用transition等变化时最好两边都申明属性，否则可能不出现或出现奇怪的效果</p></li><li><p>input:submit/buttom比input:text默认高一点，是因为按下动画</p></li><li><p>text-align对最后一行文字无效</p></li><li><p>忽略外层div使鼠标点击穿透： <code>pointer-event: none;</code></p></li><li><p>给<strong>包含块</strong>设置 边框 和 内边距 可以使<strong>子元素</strong>包含在内而不与父元素产生外边距折叠</p></li><li><p>媒体查询不能引入css，也不建议这样做</p></li><li><p><code>display: content;</code> 浏览器会将所有将 <code>display</code> 设置为 <code>contents</code> 的元素从可访问性树]中移除。这会导致该元素及其后续元素不再被屏幕阅读技术访问。</p></li><li><p>布局/位置和其他样式尽量分开处理，CSS组件应当减少受到html结构的影响<a href="https://blog.zfanw.com/css-architecture/" target="_blank" rel="noopener">https://blog.zfanw.com/css-architecture/</a></p></li><li><p>绝对定位的宽高是根据包含块的(content+ padding)的和计算的(不包含border)，与box-sizing无关！！</p></li><li><p><a href="https://yio.me/qdkf/269.html" target="_blank" rel="noopener">伪元素中怎么添加换行符</a></p></li></ul><h4 id="JavaScript-小记"><a href="#JavaScript-小记" class="headerlink" title="JavaScript 小记"></a>JavaScript 小记</h4><ul><li><p>js中用getElementById.value方法获取的值的运算可以用在末尾加|0的方法使其从string 变为 integer</p></li><li><p>Switch case 使用严格比较（===）</p><p>Switching 的细节</p><ul><li>如果多种 case 匹配一个 case 值，则选择第一个 case。</li><li>如果未找到匹配的 case，程序将继续使用默认 label。</li><li>如果未找到默认 label，程序将继续 switch 后的语句。</li></ul></li><li><p>除了空字符串””，其他字符串转化为布尔值都为真</p></li><li><p>JavaScript 使用 32 位按位运算数</p><p>JavaScript 将数字存储为 64 位浮点数，但所有按位运算都以 32 位二进制数执行。</p><p>在执行位运算之前，JavaScript 将数字转换为 32 位有符号整数。</p><p>执行按位操作后，结果将转换回 64 位 JavaScript 数。</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> front-end </tag>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端学习week5</title>
      <link href="/2019/06/01/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0week5/"/>
      <url>/2019/06/01/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0week5/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>​    本周学习了CSS3中的一些新属性，本周有三个重点，1. 媒体查询：主要应用于移动页面的自适应，理解设备像素和CSS像素(设备独立像素)的区别和关系。2. flex布局，flex的使用大大简化 了很多复杂页面布局的工作量，细节也相对较少，<code>display: flex</code>的元素自动升级为块元素，而内容item则没有行内和块元素之分，可以理解为结合了浮动和inline-block的特性。 3. @font-face规则，利用这个规则可以引入字体图标，可以减少图片资源的加载还能自定义字体名字。</p><a id="more"></a><h3 id="CSS3"><a href="#CSS3" class="headerlink" title="CSS3"></a>CSS3</h3><h4 id="media-query"><a href="#media-query" class="headerlink" title="media query"></a>media query</h4><ul><li><p>使用媒体查询的三种方式</p></li><li><p>CSS内的媒体查询不影响选择器优先级</p></li><li><p>DPR  device pixel ratio</p><p>physical pixel / css pixel</p><p>单位： DPI  DPCM DPPX(常用)  D: dot</p></li><li><p><code>&lt;meta name=&quot;Viewport&quot; content=&quot;width=device-width&quot;&gt;</code></p><p>让手机浏览器以设备屏幕宽度的初始包含块渲染页面，不设置一般是1000左右，仅支持移动端</p><p>width后设置的是设备渲染的css像素宽度，不用写单位</p><p>css像素也叫做设备独立像素(device-independent pixels (dips))</p><p><a href="http://www.ayqy.net/blog/完全理解px-dpr-dpi-dip/" target="_blank" rel="noopener">http://www.ayqy.net/blog/%E5%AE%8C%E5%85%A8%E7%90%86%E8%A7%A3px-dpr-dpi-dip/</a></p></li><li><p>手机上缩放页面永远不会回流，用户缩放的时候css像素(例如width)是不变的，只是改变了DPR</p></li><li><p>移动端布局</p><p>一般两种情况：</p><ul><li>页面在不同设备上显示比例一致<ul><li>使用vw单位</li><li>使用<code>meta viewport</code>标签定宽</li><li>以上旧版浏览器不支持时，使用rem单位，用js获取视口宽度，使用<code>100vw/(dips页面宽度)</code>作为1rem的大小<code>html {font-size: 100vw/x}  x为逻辑页面大小</code>，但要注意字号大小小于12px时会被浏览器强行重置为12px，所以需要将单位放大至12px以上，相应的rem使用时缩减相应倍数</li></ul></li><li>页面在更大的屏幕上显示更多内容<ul><li><code>width=devic-width</code>使用px以及流式布局(块元素自动占满宽度)</li></ul></li><li>混合页面<ul><li>布局使用rem，文字使用px，<code>width=devic-width</code></li></ul></li></ul></li></ul><h4 id="pseudo-class-amp-pseudo-element"><a href="#pseudo-class-amp-pseudo-element" class="headerlink" title="pseudo-class&amp;pseudo-element"></a>pseudo-class&amp;pseudo-element</h4><ul><li><code>:target</code>伪类：url中含有元素的id的值时选中</li><li><code>:not()</code>伪类中不能出现层级选择器即<code>&gt; ~ +</code>以及空格等  <strong>且not伪类在选择器中权重为0，但是not伪类里面的东西参与优先级</strong></li><li><code>::first-letter</code>伪元素会选中第一个文字字符前的所有符号字符</li></ul><h4 id="flexible-box-layout"><a href="#flexible-box-layout" class="headerlink" title="flexible box layout"></a>flexible box layout</h4><ul><li><p><code>display: flex</code>声名内部为flex，外部为块  <code>inline-flex</code></p></li><li><p>flex-container     </p><ul><li>flex-direction     设置main-axis<ul><li>column /column-reverse</li><li>row  默认值</li></ul></li><li>justify-content  是item元素main-axis对齐<ul><li>flex-start/flex-end</li><li>center</li><li>space-around/space-between</li></ul></li><li>align-items  在cross-axis上对齐  <strong>子元素本身在交叉轴的对齐</strong><ul><li>flex-start/flex-end</li><li>center</li><li>baseline</li><li>stretch  默认值 设置为其他值时则失效</li></ul></li><li>align-content 设置行间的空间，与justify-content值相同，只有一行时无效  <strong>子元素整体在交叉轴对齐</strong></li><li>flex-wrap  设置cross-axis   发生折行 shrink失效 ，折行时不会发生外边距折叠</li><li>flex-flow ： direction | wrap</li></ul></li><li><p>flex-item</p><ul><li><p>flex-basis</p><p>对应行排列时的width或列排列时的height，比较灵活，item的理想大小</p><p>content &lt; width &lt; flex-basis (limited by max|min-width)   <strong>优先级</strong></p></li><li><p>flex-grow: 对container剩余空间的分配拉伸，若所有item中的值之和不超过1，那还会剩下1减去和的比例部分未分配</p></li><li><p>flex-shrink  缩减对应比例权重使items fit container，默认为1，具体收缩的值为各item初始宽度乘以权重再在多出的宽度下分配，和不足1时与grow类似</p></li><li><p>align-self  交叉轴上的对齐</p></li><li><p>order 顺序默认为0</p></li></ul></li><li><p>理解flex-item的min-content</p><ul><li><p>看到zxx的文章<a href="https://www.zhangxinxu.com/wordpress/2016/05/css3-width-max-contnet-min-content-fit-content/" target="_blank" rel="noopener">https://www.zhangxinxu.com/wordpress/2016/05/css3-width-max-contnet-min-content-fit-content/</a></p></li><li><p>说一下自己的理解：flex布局自带shrink为1，而flex-item有一个最小内容宽度，一般被子元素的内容撑起，例如只有文本内容且为文本样式为nowrap时，最小内容宽度为最长的单词长度，内容为替换元素图片且未设置图片的宽度时，最小内容宽度即为图片的宽度(DOM结构为container&gt;div&gt;img，div作为flex-item有包裹内容的性质)。当最小内容宽度的和大于container的宽度，此时flex-item也无法再被压缩，表现为溢出。一个有意思的情况是在图片作为item的内容的情况下，当给图片设置<code>max-width: 100%</code> ，相当于flex-item的最小内容宽度的限制取消了，此时会依照shrink的规则来对flex-item进行压缩。 </p><p>当图片宽度比容器小的时候设置了<code>max-width</code>会怎样：<strong>flex布局可以理解成若item的shrink为0时先将元素按本来属性摆放，再按设置的shrink或grow等其他属性来伸长或压缩</strong>。所以会直接按图片的尺寸摆放</p></li></ul></li><li><p>flex container在 column warp时宽度不能被items的内容撑开，可以在末尾使用伪元素来填充剩余的空间使形成完整的矩形</p></li><li><p><a href="https://output.jsbin.com/topegiw" target="_blank" rel="noopener">https://output.jsbin.com/topegiw</a> 利用flex实现自适应的正方形阵列，利用了伪元素的padding百分比值为父元素宽度的特性撑起父元素高度及grow属性实现自适应大小的正方形，增加几个高度为0的正方形元素使当最后一个行未铺满正方形时其大小不会过分拉伸</p></li><li><p>子元素可以用<code>margin:auto</code> 实现两端对齐， 设为auto的margin会占用这个方向剩余的所有空间</p></li></ul><h4 id="web-font"><a href="#web-font" class="headerlink" title="web font"></a>web font</h4><ul><li><pre><code class="css">@font-face {    font-family custom name;    src: url();    src: url()  format(&#39;embedded-opentype&#39;),   //ie8 above            woff            ttf ;    font-style: ;    font-weight: ;    unicode-range: ;}/* custom name可以重复使用，引入斜体粗体等     @font-face分开写会造成第版本IE浏览器下加载多个字体请求。*/</code></pre></li><li><p>font-size-adjust:  number</p><p>x的大小缩放</p></li><li><p>font-stretch</p><p>需要单独设计的字体文件</p></li><li><p>利用font引入icon</p><p>用图标，符号替代不需要的字符编码作为字体引入 unicode PUA(private user area)  <code>\f000</code> 之后，使用类名及伪元素组合可以给图标命名和防止读屏软件读出，</p></li></ul><h4 id="svg"><a href="#svg" class="headerlink" title="svg"></a>svg</h4><h4 id="text-effect-amp-typographic-styles"><a href="#text-effect-amp-typographic-styles" class="headerlink" title="text effect &amp; typographic styles"></a>text effect &amp; typographic styles</h4><ul><li>text-shadow</li><li>text-overflow<ul><li>clip</li><li>ellipsis 超出的文本用(…)表示，只能应用于单行文本</li></ul></li><li>text-align :start/end</li></ul><h3 id="零碎知识"><a href="#零碎知识" class="headerlink" title="零碎知识"></a>零碎知识</h3><ul><li><p>max-width可以设置为none而min-width不可以，可以给min-width设置为0达到想要的效果</p></li><li><p>如何调整<code>input:text</code>中placeholder文本的样式</p><p>使用::placeholder伪元素，但是不能调整垂直对齐，因为input内为 替换元素且为单行</p></li><li><p>border  outline  box-shadow 区别</p><p>border：占据空间</p><p>outline： 不占空间，只能为矩形，不能圆角，不能模糊，有outline-offset属性，从border外侧开始渲染</p><p>box-shadow：不占空间，形状跟随border，优于outline，从border内侧开始渲染，但是需要方框时可以用outline</p><p><a href="https://juejin.im/post/591e478b0ce4630069308278" target="_blank" rel="noopener">https://juejin.im/post/591e478b0ce4630069308278</a></p></li><li><p>FoUT (the Flash of Unstyled Text)</p><p>页面加载时间比引入的样式短，加载到样式时造成页面闪烁</p><p>解决方案：</p><ul><li>把首屏的样式写入页面的style标签中</li><li>使用link标签放在页面上方而不是@import</li></ul></li><li><p>bacground-positon</p><p>百分值是图片水平或垂直方向的百分值位置对应元素的百分值位置</p></li><li><p>background-size的cover和contain不是数值属性，不能动画</p></li><li><p>background-origin的默认值是padding-box</p></li><li><p>不要忘记为替换元素（比如 img 、 object 、 video 、 iframe 等）设置一个 max-width ，值为 100% 。</p></li><li><p>无法给img等自闭合标签添加伪元素！因为伪元素是子元素</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> front-end </tag>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端学习week4</title>
      <link href="/2019/05/23/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0week4/"/>
      <url>/2019/05/23/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0week4/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>​    学习时间一个月了，到了一个结点，css2.1的规范学习也结束，下周将开始css3的学习。先回顾一下上周的知识：上周的重点是盒模型，行内元素以及行内块元素的规则，还有定位布局，注意文本的一些属性在不同的元素下表现形式会不一样，例如对齐规则在表格中就相对直观简单。本周主要学习了另外两种原始的布局方法：表格，浮动。表格需要注意的是表层和边框优先级的规则顺序：td&gt;row&gt;col&gt;table。浮动摆放位置的规则和清除浮动以及闭合浮动的概念和方法。</p><a id="more"></a><h4 id="元素居中方法"><a href="#元素居中方法" class="headerlink" title="元素居中方法"></a>元素居中方法</h4><h5 id="inline"><a href="#inline" class="headerlink" title="inline"></a>inline</h5><ul><li><p>水平方向<code>text-align: center</code>即可</p></li><li><p>垂直方向</p><ul><li><p>使用伪元素</p><ul><li><pre><code class="css">.inline::after {    content: &quot;&quot;;    display: inline-block;    height: 100%;    vertical-align: middle;}&lt;p class=&quot;code-caption&quot; data-lang=&quot;&quot; data-line_number=&quot;frontend&quot; data-trim_indent=&quot;backend&quot; data-label_position=&quot;outer&quot; data-labels_left=&quot;Code&quot; data-labels_right=&quot;:&quot; data-labels_copy=&quot;Copy Code&quot;&gt;&lt;span class=&quot;code-caption-label&quot;&gt;&lt;/span&gt;&lt;a class=&quot;code-caption-copy&quot;&gt;Copy Code&lt;/a&gt;&lt;/p&gt;</code></pre></li><li><p>原理：画个图就明白了，<code>vertical-align: middle</code>的意思是使元素的中部与父元素的基线上的x中部对齐</p></li></ul></li><li><p>可以利用表格的对齐特性</p><ul><li><pre><code class="css">display: table-cellvertical-align: middle</code></pre></li></ul></li><li><p>多行文本垂直据中</p><ul><li><pre><code class="css">div {    min-height: 150px;    line-height: 150px;}span {    display: inline-box;    line-height: normal;    vertical-align: middle;}&lt;p class=&quot;code-caption&quot; data-lang=&quot;&quot; data-line_number=&quot;frontend&quot; data-trim_indent=&quot;backend&quot; data-label_position=&quot;outer&quot; data-labels_left=&quot;Code&quot; data-labels_right=&quot;:&quot; data-labels_copy=&quot;Copy Code&quot;&gt;&lt;span class=&quot;code-caption-label&quot;&gt;&lt;/span&gt;&lt;a class=&quot;code-caption-copy&quot;&gt;Copy Code&lt;/a&gt;&lt;/p&gt;</code></pre></li></ul></li></ul></li></ul><h5 id="绝对定位居中"><a href="#绝对定位居中" class="headerlink" title="绝对定位居中"></a>绝对定位居中</h5><ul><li><pre><code class="css">margin: auto;top: 0;left: 0;right: 0;bottom: 0;</code></pre></li></ul><p>见：<a href="https://www.zhangxinxu.com/wordpress/2013/11/margin-auto-absolute-绝对定位-水平垂直居中/" target="_blank" rel="noopener">https://www.zhangxinxu.com/wordpress/2013/11/margin-auto-absolute-%E7%BB%9D%E5%AF%B9%E5%AE%9A%E4%BD%8D-%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD/</a></p><p>原理：<strong>当一个绝对定位元素，其对立定位方向属性同时有具体定位数值的时候，流体特性就发生了</strong>，即元素的外边距会扩大或缩小以适应父元素或画布的实际大小</p><p> 过分受限自动填充父元素可用尺寸，注意正常流的<code>margin:auto</code>不能使垂直居中，而绝对定位中可以</p><h5 id="flex"><a href="#flex" class="headerlink" title="flex"></a>flex</h5><p>子元素<code>margin: auto</code>或调整父元素的<code>justify-content</code>和<code>align-items</code></p><h5 id="transform"><a href="#transform" class="headerlink" title="transform"></a>transform</h5><p>利用<code>transform: translate();</code>和<code>position: relative</code> 百分值的特性</p><p>唯一子元素大于父元素也能居中的方法</p><h4 id="表布局"><a href="#表布局" class="headerlink" title="表布局"></a>表布局</h4><ul><li><p>visibility中的collapse只对表格中的列生效，且列或列组的visibility只有这一个声明，整列隐藏。</p></li><li><p>匿名表对象</p><p>浏览器会自动补全遗漏的表格组件，可利用这个特性故意省略table，会自动补全一个<code>&lt;div class=&quot;table&quot;&gt;</code>，可以给表格增加滚动条</p></li><li><p>caption视为块级元素</p></li><li><p>合并单元格边框</p><p>表宽度是指两边框中线的距离</p><p>次像素 subpixel</p><p>边框优先级和表层的优先级是一样的，另外hidden优先级最高，none优先级最低，粗&gt;细，上&gt;下，左&gt;右</p></li><li><p>表层</p><p>所有颜色背景初始都是透明的，按顺序叠放，透过外层透明背景可以看到里层背景，td最高，table最低</p></li><li><p>表大小</p><ul><li><p>高度永远自动计算</p></li><li><p>宽度</p><ul><li>固定布局</li></ul></li><li><p>自动布局</p><p>表格及单元格宽度由其包含的内容决定，要在整个表格后加载解析完成之后才能最终确定，如果某行的列宽和前面的不一致，则之前绘制好的行也必须重新绘制</p></li><li><p>table-layout </p><p>默认为auto即自动布局，使用fixed值时表格第一行渲染即确定单元格宽度，可以加速渲染</p></li><li><p>单元格width为百分比：参考<a href="https://csspod.com/table-width-algorithms/" target="_blank" rel="noopener">https://csspod.com/table-width-algorithms/</a></p><p>例：设置成1%？</p></li><li><p>对齐</p><ul><li><p>vertica-align: middle</p><p>单元格内容中间对齐，可利用这个特性实现垂直居中</p></li><li><p>base-line</p></li></ul></li></ul></li><li><p>col无法使用hover伪类，可以使用伪元素利用表层特性实现行列高亮</p></li></ul><h4 id="回流和重绘"><a href="#回流和重绘" class="headerlink" title="回流和重绘"></a>回流和重绘</h4><p><a href="https://www.cnblogs.com/chenjg/p/10099886.html" target="_blank" rel="noopener">https://www.cnblogs.com/chenjg/p/10099886.html</a></p><ul><li><p>reflow/relayout</p><p>页面样式变化涉及重新计算布局</p><p>尽量不要触发回流，控制在一定范围内</p></li><li><p>repaint</p><p>页面样式变化不涉及计算布局，只改变颜色背景阴影等</p></li></ul><p><strong>回流一定会触发重绘，而重绘不一定会回流</strong></p><h4 id="IE-hack"><a href="#IE-hack" class="headerlink" title="IE hack"></a>IE hack</h4><p>条件注释</p><h4 id="浮动"><a href="#浮动" class="headerlink" title="浮动"></a>浮动</h4><ul><li><p>可用来清除图片间的空隙</p></li><li><p>包含块是最近的<strong>块级</strong>祖先</p></li><li><p>给行内元素设置浮动会变成块元素</p></li><li><p>块元素会忽略浮动元素布局，但是行内元素会环绕浮动渲染</p></li><li><p>浮动不会影响前面块元素的布局</p></li><li><p>浮动框没有空间会向下向左滑动</p></li><li><p>朋友圈照片布局优化，调整<code>li</code>的数量观察效果</p><p><code>li:first-child:nth-last-child(3)</code></p></li><li><p>浮动和定位组合，只有<code>position:relative</code>生效，其他情况只有定位生效</p></li><li><p>浮动元素不会重叠</p><p>垂直方向不同包含块的浮动元素也不会重叠</p><p>水平方向的不同包含块的浮动元素会冲叠</p></li><li><p>浮动的负magin浮动块中内容的位置不会影响浮动布局盒子的位置，有点像定位中的relative。但是会改变布局盒子的大小，而浮动块的内容位置也是相对布局盒子的位置，当浮动布局盒子宽度为0时，位置会变为前面块元素的末尾，此时浮动块元素可以重叠，具体例子参见淘宝的双飞翼布局<a href="https://www.cnblogs.com/langzs/archive/2013/01/27/taobaoshuangfeiyi.html" target="_blank" rel="noopener">https://www.cnblogs.com/langzs/archive/2013/01/27/taobaoshuangfeiyi.html</a></p></li></ul><h5 id="清除浮动"><a href="#清除浮动" class="headerlink" title="清除浮动"></a>清除浮动</h5><ul><li><p>清除浮动</p><ul><li><code>clear</code> 块级 让块框下移，使两边没有浮动元素</li><li>触发BFC，若块级元素在两个浮动之间，则变窄</li></ul></li><li><p>闭合浮动</p><p>块框高度增大使包含其浮动的后代元素，</p><ul><li><p>触发BFC：</p><ul><li>overflow 除visible以外的值</li><li>display: inline-block/table-cell/table/flow-root;<br>position: absolute/fixed;</li><li>float</li><li>position: absolute/fixed</li></ul></li><li><p>末尾使用一个行元素生成行框使其撑高</p><p>缺点：会有不需要的一段高度</p></li><li><p>末尾使用一个块元素<code>clear:both</code>使撑高，br亦可</p><p>优化：可使用after伪元素<a href="http://www.iyunlu.com/view/css-xhtml/55.html?tdsourcetag=s_pctim_aiomsg" target="_blank" rel="noopener">http://www.iyunlu.com/view/css-xhtml/55.html?tdsourcetag=s_pctim_aiomsg</a></p></li><li><p>常用示例：</p><ul><li><pre><code class="css">div::before,div::after {    display: table;    content: &#39;&#39;;}div::after {    clear: both;}&lt;p class=&quot;code-caption&quot; data-lang=&quot;&quot; data-line_number=&quot;frontend&quot; data-trim_indent=&quot;backend&quot; data-label_position=&quot;outer&quot; data-labels_left=&quot;Code&quot; data-labels_right=&quot;:&quot; data-labels_copy=&quot;Copy Code&quot;&gt;&lt;span class=&quot;code-caption-label&quot;&gt;&lt;/span&gt;&lt;a class=&quot;code-caption-copy&quot;&gt;Copy Code&lt;/a&gt;&lt;/p&gt;</code></pre></li></ul></li></ul></li></ul><h4 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h4><ul><li>浏览器大多使用padding来实现列表项缩进，所以可以改变padding来调整缩进</li><li>list-style-tyoe属性会继承，但是用户代理的样式表可能有定义。</li></ul><h4 id="计数器"><a href="#计数器" class="headerlink" title="计数器"></a>计数器</h4><ul><li><p>counter-reset</p></li><li><p>counter-increment</p><p>浏览器第一次使用时会reset</p></li><li><p>伪类中:content: counter(name)</p></li><li><p>计数器可以定义列表样式：counter(name, list-styletype)</p></li><li><p>counters(name, “.”)</p><p>老计数器追加新计数器，并用 . 连接</p></li><li><p>计数器有作用域，counter-reset确定了计数器的作用域</p></li></ul><h4 id="零碎知识"><a href="#零碎知识" class="headerlink" title="零碎知识"></a>零碎知识</h4><ul><li><p>p标签内不能写块元素，遇到块元素标签直接闭合</p></li><li><p>行内元素不能包含块元素，也会直接闭合</p><ul><li>这是旧标准的说法，新的html5中删去了block和inline的概念，能否嵌套应当查看元素的categories和content model</li></ul></li><li><p>伪元素生成的内容无法选中</p></li><li><p><code>all: initial</code>将所有属性还原默认值</p><p>例：用于去除<code>inline-block</code>间的间隙</p></li><li><pre><code class="css">html {box-sizing: border-box;}*,::after,::before {    box-sizing: inherit;}</code></pre><p>将所有元素设置为border-box的优化写法</p></li><li><p>opacity不继承</p></li><li><p>圣杯布局和双飞翼布局区别</p><ul><li><p>圣杯布局：借助的是其他非主要元素覆盖了其父元素的padding值所占据的宽度，同一个杯子，非主要元素其只是占据了全部容器的padding值部分；</p></li><li><p>双飞翼布局：给主要部分main-wrap添加一个外层元素main，其他非主要元素所占据的空间是主要部分(main-wrap)的margin空间，像鸟的两个翅膀，与主要部分main脱离</p></li><li><p>双飞翼布局多了一个DOM节点，但是布局也更稳定</p></li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> front-end </tag>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端学习week3</title>
      <link href="/2019/05/18/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0week3/"/>
      <url>/2019/05/18/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0week3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本周开始学习css的布局基础知识，基本视觉格式化从盒模型入手，介绍了块元素的盒模型及基本概念，水平方向和垂直方向的规则和要点很多，注意水平方向的width总和和垂直方向的margin折叠学习这些内容能方便预测页面中的基本布局，之后学习了背景图片的一些技巧和sprite图应用，接着是基本布局之一的定位，最后是行内元素的结构，注意行内框，行框，line-height的关系，内容很多很杂，需要梳理。</p><a id="more"></a><h2 id="基本视觉格式化"><a href="#基本视觉格式化" class="headerlink" title="基本视觉格式化"></a>基本视觉格式化</h2><h3 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a>盒模型</h3><ul><li><p>所有元素都有盒模型，只不过行内元素的宽高上下外边距设置无效</p></li><li><p>无法通过元素的margin box部分与此元素交互</p></li><li><p>padding/border不能为负值</p></li><li><p>只有width/height/margin可以设置为auto</p></li><li><p>box-sizing 默认为content-box 建议设置为border-box</p></li><li><p>利用border的特性使用css画出多种几何图形</p><p><a href="http://www.webhek.com/post/40-css-shapes.html" target="_blank" rel="noopener">http://www.webhek.com/post/40-css-shapes.html</a></p></li><li><p>border默认为前景色</p><p>即文本的颜色</p></li><li><p>包含块：最近的块级祖先</p></li><li><p>常规流normal flow</p></li></ul><h4 id="水平属性"><a href="#水平属性" class="headerlink" title="水平属性"></a>水平属性</h4><ul><li><p>内容，左右外边距可以设置为auto</p></li><li><p>块级元素框水平总和等于父元素内容区width(<strong>不是width属性的值！！</strong>) 百分数也是</p></li><li><p>水平方向外边距不会折叠</p></li><li><p>没有auto</p><p>过分受限会把margin-right强制为auto(与文本书写方向有关)</p></li><li><p>一个auto</p><p>根据父元素计算出值</p><p>只有margin-left为auto时，不能计算出负值，会自动置0，负值给margin-right</p></li><li><p>两个auto(margin-left/right,width)</p><ul><li><p>margin-left/right</p><p>元素在父元素中居中</p></li><li><p>margin/width</p><p>设置为auto的外边距为0</p></li></ul></li><li><p>三个auto</p><p>两个外边距会被设置为0</p></li><li><p>替换块级元素的宽度为auto时则为内容的固有宽度</p></li><li><p>边框宽度不能用百分比表示</p></li><li><p>利用min-width/max-width属性</p></li></ul><h4 id="垂直属性"><a href="#垂直属性" class="headerlink" title="垂直属性"></a>垂直属性</h4><ul><li><p>浏览器渲染规则：<strong>自上而下，自外而内，静态渲染，一次到位</strong></p></li><li><p>默认高度由内容决定</p></li><li><p>margin-top/bottom都为auto时会自动设为0，不会居中</p></li><li><p>height必须设置为auto或者非负值</p></li><li><p>常规流中，margin/padding的水平和垂直方向的百分数值都是基于包含块的内容区width计算的</p></li><li><p>若包含块height设置为auto且高度由内容撑大，子元素height设置的百分数会失效</p><p>特殊情况：包含块只设置了<code>min-height</code>，有高度但子元素高度百分比依然无效</p><p>解决方法：</p><ul><li>将包含块设置具体高度</li><li>包含块的高度不由子元素撑大，例如子元素设置为绝对定位</li></ul></li><li><p><strong>外边距折叠</strong> </p><p>只在垂直方向</p><p>保留两者中较大的外边距 </p><p>负margin和正margin相遇时两者相加得到新的外边距</p><p>两个负margin重叠也只保留绝对值较大的</p><p>多个margin接触时，正与负分别合并，最后正与负求和</p></li><li><p>常规流块元素没有边框和内边距且只包含块元素时，包裹子元素的 border-box，父子元素的margin会合并，但触发了BFC的元素，无论如何都会内容区包裹子元素的margin-box，父子元素的margin也不会合并</p></li><li><p><strong>BFC</strong></p></li><li><p>列表项</p><p>块级元素</p></li><li><p>隐藏元素</p><ul><li>visibility: hidden 元素不可见，不可交互，但是仍占据布局中的位置</li><li>opacity: 0 元素透明，但是可交互</li><li>display: none 元素从布局中完全消失</li></ul></li></ul><h3 id="颜色和背景"><a href="#颜色和背景" class="headerlink" title="颜色和背景"></a>颜色和背景</h3><ul><li><p>背景不继承</p></li><li><p>背景图片无法直接复制</p></li><li><p>背景颜色默认在border以内的区域包括border</p></li><li><p>背景图片：</p><ul><li><p>background-repeat</p></li><li><p>background-size</p><p>元素的背景占据了元素的全部尺寸，包括内边距和边框，但不包括<strong>外边距</strong>。</p><p>以background-origin为基准 ，默认为padding-box，即背景图像一定是从padding开始摆放，如果不使用no-repeat，则背景图像会覆盖至包括边框</p><ul><li><p>cover</p><p>图片由无穷大等比缩小到正好覆盖元素</p></li><li><p>contain</p><p>与cover相反</p></li><li><p>object-fit </p><p>img/video的属性</p></li></ul></li><li><p>background-attachment</p><ul><li><p>fixed</p><p>相对于视口定位。</p><p>可产生特殊的效果</p></li></ul></li><li><p>background-position</p><p>值可以写关键字，配合数值</p><p>百分比：位置为box的百分比对准图片的百分比位置，注意图片比窗口大的时候增加百分比图片如何移动？</p></li><li><p>background-clip</p></li></ul></li></ul><h3 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h3><ul><li><p>position</p><ul><li><p>static 默认</p></li><li><p>fixed</p><p>相对视口</p><p>上下/左右margin设置为auto可以居中</p><p>默认位置为原先在常规流中的位置</p></li><li><p>relative</p><p>相对自己原来的位置</p><p>常规流会保留原来的位置</p></li><li><p>absolute</p><p>相对定了位的最近祖先的padding-box(无定位祖先则相对第一屏)</p><p>宽度未设置时，最大到包含块的border，最小为一个单词长度，可设置white-space使不折行</p></li><li><p>sticky</p><p>不会离开包含块，结合了relative和fixed 的特性</p></li><li><p>z-index</p><p>默认0，后盖前</p><p>祖先后代都定位时，后代的z-index失效</p></li></ul></li><li><p>transition</p><p>过度动画</p><p>cubic-bezier</p><ul><li>与visibility组合时，注意visibility只要离开hidden状态就会visible，并不是渐变</li></ul></li></ul><h3 id="行内元素"><a href="#行内元素" class="headerlink" title="行内元素"></a>行内元素</h3><ul><li><p>垂直方向内容区相连，有边框的话，边框会重叠显示</p></li><li><p>行内框是由行内元素产生，行框则是一行中所有的行内框构成</p></li><li><p>box-shadow是元素折断之后生效，border是折断之前生效，可以利用这个特性为多行文本的每行增加边框</p></li><li><p>行内元素垂直方向margin不影响布局</p></li><li><p>line-height值尽量写纯数字，用em容易产生奇怪的结果</p></li><li><p>只要行框形成就不会消失</p></li><li><p>给行内元素增加边框和padding不会影响行内框等布局，初始边框包围内容区</p></li><li><p>替换元素内容区包括外边距</p></li><li><p>line-height可视为确定了行框的最小高度</p></li><li><p>将行内元素的<code>line-height</code>设置小于normal失效：会假设行内元素旁白会有一个空的匿名文本，行高继承自块元素</p></li><li><p>inline原色无padding和border时，其底色区域的高度为当前字体line-height为normal时计算的值，与实际设置的line-height无关</p></li><li><p>替换元素line-height属性无效</p></li><li><p>vertical-align的百分值是根据line-height计算</p></li><li><p>当包含块中只有行内替换元素时，例如只有一张图片，行框的计算要加上图片的行内款和相邻<strong>空白节点</strong>的行内框(假设改行有匿名文本)</p></li></ul><h4 id="视觉格式化流程"><a href="#视觉格式化流程" class="headerlink" title="视觉格式化流程"></a>视觉格式化流程</h4><ol><li>按照以下步骤确定行中各元素行内框以及高度：<ol><li>获取各行内非替换元素及不属于后代内元素的所有文本的 <code>font-size</code>值和 <code>line-height</code>值， <code>line-height</code>和 <code>font-size</code>差值为行间距值。</li><li>获取替换元素高度及上、下外边距，上、下内边距，上、下边框值相加。</li></ol></li><li>对于内容区，需要确定各元素、匿名文本以及该行本身基线的位置，将其基线对齐。对于替换元素，需要底边放置该行基线上。</li><li>对于指定 <code>vertical-align</code> 值的元素，确定其垂直偏移量。并改变元素在上方或下方超出的距离。</li><li>确定各行内框的具体位置后再进行确定行框。行框高度为最高行内框顶端和最低行内框低端之间的距离。</li></ol><h4 id="inline-block"><a href="#inline-block" class="headerlink" title="inline-block"></a>inline-block</h4><ul><li><p>inline-block的元素之间会产生<strong>空格间隙</strong>间隙影响布局，解决方法见：<a href="https://www.zhangxinxu.com/wordpress/2012/04/inline-block-space-remove-去除间距/" target="_blank" rel="noopener">https://www.zhangxinxu.com/wordpress/2012/04/inline-block-space-remove-%E5%8E%BB%E9%99%A4%E9%97%B4%E8%B7%9D/</a></p><p>相邻的block元素中间产生匿名空格，让元素分行即可</p></li><li><p>行内框为margin-box的外边缘</p></li><li><p>基线为最后一行文字的基线/无内容时以margin-box的下边缘为准</p></li><li><p>替换元素设置为<code>display:inline</code>无效，会被当做<code>inline-block</code></p></li><li><p>inline-block的基线会影响布局，其基线取决于元素本身的特性，在该元素中没有行内子元素（注意是DOM树的子元素，有块子元素不算或者块子元素中有行元素这个行元素算）的时候或者overflow不为visible，该inline-block的基线为margin-bottom的下边界。否则，以该元素中最后一个行框子元素的基线为该元素的基线。</p><ul><li><p>假设两个inline-block并列，第二个又嵌套了一个inline-blok，会怎样布局</p><p>解答：按照上面的规则，inline-block的基线为margin-box的底部，第二个inline-block的基线变成被嵌套的inline-block的基线，所以第一个和被嵌套的底端对齐。</p></li></ul></li></ul><h4 id="匿名盒子"><a href="#匿名盒子" class="headerlink" title="匿名盒子"></a>匿名盒子</h4><p>匿名文本看作被包含在匿名盒中继承父元素属性</p><p>匿名块盒子</p><ul><li>如果有多个块盒子，而它们中间又没有行内元素，则会在这些盒子的前面和后面创建两个匿名块盒子</li><li>如果块容器盒里面有一个块级盒，那么我们强制让它里面<em>只含有</em>块级盒</li><li>匿名盒子无法被选择器选中，可继承的属性都为inherit，不可继承的为initial</li></ul><p>匿名行内盒</p><ul><li>任何被直接包含在一个块容器元素中（不在行内元素里面）的文本，必须视为一个匿名行内元素</li><li>不分行的就是行内盒，因为内部分块的叫块盒</li></ul><p>块容器盒</p><ul><li>该元素的直接子元素只能是块级盒，或只能是行内级盒</li></ul><h3 id="零碎知识"><a href="#零碎知识" class="headerlink" title="零碎知识"></a>零碎知识</h3><ul><li><pre><code class="css">* {    background-color: rgba(0, 0, 0, 0.08);}/*练习时css预写能方便看到各元素区域*/&lt;p class=&quot;code-caption&quot; data-lang=&quot;&quot; data-line_number=&quot;frontend&quot; data-trim_indent=&quot;backend&quot; data-label_position=&quot;outer&quot; data-labels_left=&quot;Code&quot; data-labels_right=&quot;:&quot; data-labels_copy=&quot;Copy Code&quot;&gt;&lt;span class=&quot;code-caption-label&quot;&gt;&lt;/span&gt;&lt;a class=&quot;code-caption-copy&quot;&gt;Copy Code&lt;/a&gt;&lt;/p&gt;</code></pre></li><li><p>伪元素可看作该元素的元素</p></li><li><p>伪元素不能交互</p></li><li><p>改变分隔线hr的颜色</p></li><li><pre><code class="css">hr {    /* 如何改变hr的颜色 */    background-color: rgb(211, 213, 213);    border: none;    height: 1px;}   /* 直接改变border-color会变成2px高度，因为有上下两边框  */</code></pre></li><li><p>设置html的width为100vw是包括滚动条的，设置为100%则不包括，默认即为100%</p><p>html默认的overflow为auto  </p><p><strong>而要设置块元素height100%显示，必须设置其包含块的height，否则无效</strong></p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> front-end </tag>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端学习week2</title>
      <link href="/2019/05/11/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0week2/"/>
      <url>/2019/05/11/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0week2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>​    本周继续学习了html中剩余的常用标签，特别是表单，列表和表格的用法；理解什么是语义化；并进入css的学习，本周的重点是css选择器的种类和优先级，介绍了颜色，长度等数值和单位的用法，以及字体和文本属性的声明。</p><a id="more"></a><h3 id="html-常用标签"><a href="#html-常用标签" class="headerlink" title="html 常用标签"></a>html 常用标签</h3><ul><li>i<ul><li>语义： 用来表示由于某些原因需要与普通文本区分的文本</li></ul></li><li>strong  em<ul><li>语义都为强调，strong更强一些</li></ul></li><li>pre<ul><li>块级标签</li><li>有预定义格式的文本</li><li>标签内文本格式都会保留</li><li>与<code>code</code>(行内标签)标签配合显示高亮代码</li></ul></li><li>列表<ul><li>ol - ordered list</li><li>ul - unordered list<ul><li>li - list item</li></ul></li><li>dl - desciption list<ul><li>dt - description term</li><li>dd - description description</li><li>一个列表项由一个dt和多个dd为一组</li><li>一个dt对应多个dd</li><li>dd和dt是同级元素，不是嵌套关系</li></ul></li></ul></li></ul><h3 id="可访问性"><a href="#可访问性" class="headerlink" title="可访问性"></a>可访问性</h3><ul><li>accessibility - a11y</li><li>internationalizition - i18n</li><li>各个设备访问/各种人群</li><li>a r i a 属性<ul><li>accessibly rich internet application</li><li>和role属性组合使用，提示浏览器当前元素是一个何种视觉元素</li><li>aria-xxx=”yyy” 提示浏览器单枪视觉元素的状态或其他信息</li></ul></li></ul><h3 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h3><ul><li><p>form</p><p>最外层标签</p><ul><li><p>属性</p><ul><li><p>action</p><p>表单提交地址</p></li><li><p>target</p></li><li><p>method</p><p>表单提交方式</p><ul><li><p>get</p><p>将表单字段拼成querystring</p><p><a href="http://abc.com/?a=1&amp;b=2&amp;c=3" target="_blank" rel="noopener">http://abc.com/?a=1&amp;b=2&amp;c=3</a></p><p>组合成：表单地址?”name=”表单内容1&amp;”name”=内容2&amp;…</p></li><li><p>post</p></li></ul></li><li><p>enctype</p><p>编码方式</p></li></ul></li><li><p>input</p><ul><li><p>type属性</p><ul><li><p>file</p><ul><li><p>accept属性组合使用</p><ul><li>可以接受的文件类型</li><li><code>&lt;input type=&quot;file&quot; name=&quot;&quot; id=&quot;&quot; accept=&quot;image/*,text/*&quot;&gt;</code></li><li>MIME Type  媒体类型</li><li><code>&lt;input type=&quot;file&quot; name=&quot;&quot; id=&quot;&quot; accept=&quot;.jpg,.png,.gif,.jpeg,.webp,.exe&quot; value=&quot;c:/user/xieran/desktop/a.pdf&quot;&gt;</code></li></ul></li><li><p>multiple</p><p>选择多文件，布尔值</p></li></ul></li><li><p>hidden</p><ul><li>存放一些用户不可见、不可改的数据，在用户提交表单时，这些数据会一并发送出</li><li>隐藏的输入域</li><li>value设置其值</li><li>name设置名字</li></ul></li><li><p>不能识别的值一律当text处理</p></li></ul></li><li><p>其他属性</p><ul><li>value<ul><li>datetime-local<ul><li><a href="https://zh.wikipedia.org/wiki/ISO_8601" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/ISO_8601</a></li></ul></li></ul></li><li>name<ul><li>很重要，表单提交时，这个域/字段/框/FormControl的名字</li><li>同时，在radio和checkbox阵列里，name相同的元素被分在一组里</li></ul></li></ul></li><li><p>可以作为内联元素放入label标签</p></li></ul></li><li><p>button</p></li><li><p>label</p><p>通过for属性连接其他元素或直接嵌套，使文字可互动</p></li><li><p>select</p><ul><li>option<ul><li>value<ul><li>选择了该项目后它所属的select元素的值</li></ul></li><li>selected<ul><li>默认被选中</li></ul></li><li>disabled<ul><li>表示该项被禁用</li></ul></li><li>hidden<ul><li>表示该项被隐藏</li></ul></li><li>以上三个属性均无值</li></ul></li><li>optgroup // hgroup  colgroup<ul><li>给option分组</li><li>用label属性表示这个分组的名字</li><li>无法被选中，只能选择option</li></ul></li></ul></li><li><p>textarea </p><p>多行文本输入框</p></li><li><p>fieldset</p><p>字段组，把一组输入域放在一起</p><ul><li><p>legend</p><p>只能作为 fieldset 的子元素，用来标识这组输入域的名字</p></li></ul></li></ul></li></ul><p>name属性主要用于表单元素 id所有标签都能使用</p><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><ul><li>“映射”标签</li><li>name属性</li><li>若设置id属属性，id和name属性值必须一样</li><li>子元素area</li></ul><h3 id="table"><a href="#table" class="headerlink" title="table"></a>table</h3><ul><li><p>tbody 可以多个</p><ul><li>tr 一行 table row<ul><li>th 表头/居中加粗 table header</li><li>td table data<ul><li>colsapn 跨行</li><li>rowspan跨列</li><li>不能跨不存在的行列</li></ul></li></ul></li></ul></li><li><p>thead 表头行</p></li><li><p>tfoot 表尾行</p></li><li><p>caption 表名</p></li><li><p>col/colgroup 设置列的样式</p><p>放在tbody/thead之前，caption之后</p></li><li><p>从上到下，从左到右</p></li></ul><h3 id="iframe"><a href="#iframe" class="headerlink" title="iframe"></a>iframe</h3><ul><li>inline frame</li><li>不能省略结束标签，否则之后的内容会被当做fallback后备内容不在页面显示</li><li>name属性<ul><li>_top ,   _parent</li><li>自定义</li></ul></li><li>iframe的跳转也会被浏览器记录</li></ul><h3 id="html5标签"><a href="#html5标签" class="headerlink" title="html5标签"></a>html5标签</h3><p>不能用style标签引入css</p><ul><li>progress 进度条<ul><li><a href="https://www.zhangxinxu.com/wordpress/2013/02/html5-progress-element-style-control/" target="_blank" rel="noopener">https://www.zhangxinxu.com/wordpress/2013/02/html5-progress-element-style-control/</a></li></ul></li></ul><h3 id="语义化"><a href="#语义化" class="headerlink" title="语义化"></a>语义化</h3><p>我的理解：应当用机器可读的语义来降低机器处理web内容的难度</p><ul><li>语义化做的好的页面能方便人与机器理解<ul><li>可维护性</li><li>搜索结果靠前（机器理解）</li></ul></li><li>合适内容选用合适标签</li><li>合适的嵌套</li><li>元素合适的类名和id名称</li></ul><p>标签分类</p><ul><li>旧<ul><li>块级</li><li>行内</li></ul></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Content_categories" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Content_categories</a></li></ul><p>下面是常见标签语义</p><ul><li>p - 段落</li><li>h1,h2,h3,h4,h5,h6 - 层级标题</li><li>strong,em - 强调</li><li>ins - 插入</li><li>del - 删除</li><li>abbr - 缩写</li><li>code - 代码标识</li><li>cite - 引述来源作品的标题</li><li>q - 引用</li><li>blockquote - 一段或长篇引用</li><li>ul - 无序列表</li><li>ol - 有序列表</li><li>dl,dt,dd - 定义列表</li></ul><p>zwj  零宽连字符</p><h3 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h3><p>cascading style sheet</p><p>注释不能嵌套</p><ul><li><p>层叠</p><ul><li>冲突处理</li><li>样式继承</li></ul></li><li><p>注意代码规范，减少git diff信息</p></li><li><p>替换元素</p><ul><li>没有后代元素/标签/结点</li><li>指内容被其他不在文档里的内容替换的</li></ul></li><li><p>非替换元素</p></li><li><p>内容直接出现在标签中间</p></li><li><p>元素显示角色 role display</p><ul><li>块级元素 block<ul><li>display 属性可以改变显示方式</li></ul></li><li>行内/行间/内联元素 inline</li></ul></li><li><p>引入html</p><ul><li><p>style标签</p></li><li><p>link标签</p><ul><li><p>media属性 显示介质</p><ul><li><p>all 默认</p></li><li><p>print 打印</p><p>…</p></li></ul></li></ul></li><li><p>内联样式</p></li><li><p>DOM</p></li></ul></li><li><p>@import指令</p><ul><li><code>@import &quot;xxxx.xx&quot;;</code></li><li>只能出现在开头，可以有多个</li><li>树状依赖，导致串行下载</li></ul></li><li><p>选择器</p><ul><li><p>声明的属性和值必须是支持的，否则会被用户代理忽略</p></li><li><p>标签/元素 类 id</p><ul><li>id只能是一个单词，中间不能有空格</li></ul></li><li><p>属性选择器</p><ul><li><code>[xx] {}</code> </li><li><code>[href$=&quot;.pdf&quot;] {}</code>以.pdf结尾的href属性</li><li><code>[href$=&quot;.pdf&quot; i] {}</code>以.pdf结尾的href属性，且不区分大小写(case insensitive)</li><li><code>[href^=&quot;a&quot;] {}</code>以a开头的href属性</li><li><code>[href*=&quot;abc&quot;] {}</code>连续出现abc的href属性</li><li><code>[href~=&quot;abc&quot;] {}</code>出现abc单词的href属性</li><li>类名以 bs- 开头的元素<br><code>[class^=&quot;bs-&quot;], [class*=&quot; bs-&quot;] {  background-color: yellow;}</code></li><li><code>[lang|=&quot;en&quot;] {}</code>相当于<code>[lang=&quot;en&quot;], [lang^=&quot;en-&quot;] {}</code> </li></ul></li><li><p>层级选择器</p><ul><li>后代选择器<ul><li><code>div p {}</code></li></ul></li><li>子元素选择器<ul><li><code>div &gt; p {}</code></li></ul></li><li>邻接选择器<ul><li><code>div + p {}</code>紧挨div的p  若有多个这样的组合则可选多个</li><li><code>div ~ p {}</code>div后所有兄弟p</li></ul></li></ul></li><li><p>选择器分组</p><ul><li><code>p,div,h1 {};</code></li><li><code>*</code>通配选择符</li><li>复合 类选择器<ul><li><code>.foo.bar {}</code>选择foo&amp;&amp;bar</li></ul></li></ul></li><li><p>伪类选择器 pseudo class</p><ul><li><p>链接伪类</p><ul><li><p>:link</p></li><li><p>:visited </p><p>安全问题大部分属性无法设置，也无法获取颜色</p></li></ul></li><li><p>动态伪类</p><ul><li>:hover</li><li>:active</li><li>:focus</li><li>顺序LVFHA</li></ul></li><li><p>位置伪类</p><p>括号中n一定要写在前面</p><ul><li>:first-child<ul><li>p:first-child 选择p，且p为第一个子节点</li><li>p :first-child 选择p里面的所有第一个子节点</li></ul></li><li>:last-child</li><li>:nth-child(1)<ul><li>若有元素内嵌套多个标签，则嵌套的标签中对应位置也会被选择</li></ul></li><li>:not()  单一条件</li></ul></li><li><p>:first-of-type</p></li><li><p>:only-of-type</p></li></ul></li></ul></li><li><p>优先级</p><p>从上至下，每有一项加一</p><p>0,0,0,0</p><ul><li><p>内联样式</p></li><li><p>id</p></li><li><p>类/伪类/属性</p><ul><li>元素/伪元素</li></ul><p>优先级一样，后出现的更高</p></li></ul><p>通配符<code>*</code>优先级为0</p><p>连接符 无优先级</p><p>！important</p><ul><li><code>p {color: red !important;}</code></li><li>有与important冲突的属性，important都会占上风</li><li>important比内联样式优先级高</li></ul><p>继承没有优先级，比通配符还小</p><p>同一个选择器内的属性，后出现的生效</p><p>属性的值不会合并</p></li></ul><h3 id="值和单位"><a href="#值和单位" class="headerlink" title="值和单位"></a>值和单位</h3><ul><li><p>颜色</p><ul><li><p>十六进制表示法 hex</p><p>缩写</p></li><li><p>rgb</p></li><li><p>hsl</p></li></ul></li><li><p>长度</p><ul><li><p>绝对</p><p>m，cm等</p></li><li><p>相对</p><ul><li><p>px</p><p>为什么：屏幕的总像素数可以由用户指定，与ppi不是一回事</p><p>常用于边框和定位，图像大小</p></li><li><p>em</p><p>最常用</p><p>相对父元素字体大小</p></li><li><p>ex</p><p>字体中x字母一半的大小</p></li><li><p>rem</p><p>font size of the root element</p><p>指相对于根元素，一般是html，的字体大小，常用于web app自适应布局</p></li><li><p>vw视口宽度，vh视口高度</p><p>视口包含滚动条</p></li><li><p>calc</p></li></ul></li></ul></li></ul><h3 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h3><ul><li>字体族不加引号 </li><li>font-size默认继承的是父元素的计算值而非书写结果</li><li>font</li></ul><h3 id="文本属性"><a href="#文本属性" class="headerlink" title="文本属性"></a>文本属性</h3><ul><li><p>缩进</p></li><li><p>水平对齐</p></li><li><p>垂直对齐</p><p>适用内联元素</p></li><li><p>text-decoration</p><ul><li>子元素无法去掉父元素留下的线</li><li>线的位置粗细样式都不能指定，解决方案为使用背景图片</li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> front-end </tag>
            
            <tag> css </tag>
            
            <tag> html </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端学习week1</title>
      <link href="/2019/05/04/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0week1/"/>
      <url>/2019/05/04/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0week1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>一些前端的基本概念，没什么卵用</p><a id="more"></a><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h3><p>常见浏览器内核</p><ul><li>webkit</li><li>blink</li><li>gecko</li><li>trigent</li></ul><h3 id="二进制"><a href="#二进制" class="headerlink" title="二进制"></a>二进制</h3><ul><li><p>模拟信号  </p><p>连续的信号</p></li><li><p>数字信号</p><p>离散的信号</p></li></ul><h3 id="图片格式"><a href="#图片格式" class="headerlink" title="图片格式"></a>图片格式</h3><ul><li><p>jpg，jpeg</p><ul><li>有损压缩，压缩率高</li><li>照片</li></ul></li><li><p>png (portable network graphic)</p><ul><li>无损压缩</li><li>适合有大块相同颜色区域的图像，不适合照片</li><li>支持透明(Alpha通道)</li></ul></li><li><p>gif</p><ul><li>只有256色(原图小于256色时是无损压缩)</li><li>支持透明，但只支持全透明和不透明</li></ul></li><li><p>bmp</p><ul><li>无压缩，无损</li><li>多种颜色数量的格式</li><li>体积大，不适合网页</li></ul></li><li><p>psd</p><p>Photoshop专用格式</p></li><li><p>webp</p><ul><li>google开发的格式</li><li>有损压缩</li><li>各方面强过jpg</li><li>适合移动端</li></ul></li></ul><h3 id="命令行"><a href="#命令行" class="headerlink" title="命令行"></a>命令行</h3><ul><li><p>GUI与CLI</p><ul><li>GUI - Graphics User Interface</li><li>CLI - Command Line Interface</li><li>两者区别只在于形式不一样</li></ul></li><li><p>概念</p><ul><li><p>prompt 命令 提示符</p></li><li><p>裸命令</p><p>例：pwd 显示当前工作目录</p></li><li><p>pipe</p><p>管道符，将前一个命令的Output作为下一个命令的Input</p><p>例如：xxx | grep abc  过滤出含abc的输出结果</p></li></ul></li></ul><h3 id="编码知识"><a href="#编码知识" class="headerlink" title="编码知识"></a>编码知识</h3><ul><li><p>ASCII表</p><p>记忆：10-换行 48-0 65-A 97-a</p></li><li><p>Unicode  通用字符集</p><ul><li>utf-8 针对Unicode的一种变长字符编码</li></ul></li><li><p>BOM</p><p>BOM是用来判断文本文件是哪一种Unicode编码的标记，其本身是一个Unicode字符（”\uFEFF”），位于文本文件头部。</p></li></ul><h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2><h3 id="嵌套规则"><a href="#嵌套规则" class="headerlink" title="嵌套规则"></a>嵌套规则</h3><ul><li>树状(递归)结构</li></ul><h3 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h3><ul><li><p>语义化 secmentic</p><p>语义化是前端开发里面的一个专用术语，其优点在于标签语义化有助于构架良好的html结构，有利于搜索引擎的建立索引、抓取；另外，亦有利于页面在不同的设备上显示尽可能相同；此外，亦有利于构建清晰的机构，有利于团队的开发、维护。</p><p>即：<strong>合适的内容用合适的标签</strong></p></li><li><p>事实上，即使是有些非自闭合标签（如p，li），在一些情况下也是可以省略结束标签的，<strong>而且，是完全符合html标准的</strong></p><p>参考</p><ul><li><a href="https://www.w3.org/TR/html-markup/p.html" target="_blank" rel="noopener">https://www.w3.org/TR/html-markup/p.html</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Content_categories" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Web/HTML/Content_categories</a></li></ul></li></ul><h3 id="缩进-indent"><a href="#缩进-indent" class="headerlink" title="缩进 indent"></a>缩进 indent</h3><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><ul><li><p>属性名大小写不敏感，属性值大小写敏感</p></li><li><p>当属性值没有空格和引号等特殊字符时，属性值<strong>完全可以</strong>不用引号包围</p></li><li><p>当属性值有复杂的引号时，考虑转义字符</p></li><li><p>一些通用/全局属性(Global Attributes)</p><ul><li><p>id</p></li><li><p>name 标签名，主要用再表单类标签</p></li><li><p>title</p></li><li><p>style 给标签内指定内联样式</p></li><li><p>class</p></li><li><p>data-*  </p><p>html5中新属性，储存页面的私有自定义数据，会被用户代理自动忽略</p><p>例：</p><ul><li><pre><code class="html">&lt;li data-animal-type=&quot;鸟类&quot;&gt;喜鹊&lt;/li&gt;</code></pre></li></ul></li></ul></li></ul><h3 id="html-entity-字符实体"><a href="#html-entity-字符实体" class="headerlink" title="html entity 字符实体"></a>html entity 字符实体</h3><p>输入符号时，可能会与标签混在一起</p><p>两种转义(escape)格式</p><ul><li><p>&entityName; </p></li><li><p>&#entityNumber;</p></li><li><p>参考</p><ul><li><a href="https://dev.w3.org/html5/html-author/charref" target="_blank" rel="noopener">https://dev.w3.org/html5/html-author/charref</a></li><li><a href="http://www.w3school.com.cn/html/html_entities.asp" target="_blank" rel="noopener">http://www.w3school.com.cn/html/html_entities.asp</a></li><li><a href="http://www.w3school.com.cn/tags/html_ref_entities.html" target="_blank" rel="noopener">http://www.w3school.com.cn/tags/html_ref_entities.html</a></li></ul></li><li><p>空白字符忽略</p><ul><li><p>用户代理默认忽略文字间<strong>多余一个</strong>的空格，换行符全部忽略</p></li><li><p>可以用css改变忽略</p></li><li><p>可以用字符实体让空格不被忽略</p><p>例如<code>&amp;nbsp;</code>，但这不是真正的空格</p></li></ul></li></ul><h3 id="常用标签"><a href="#常用标签" class="headerlink" title="常用标签"></a>常用标签</h3><ul><li><p>html</p><p>只能有一个</p></li><li><p>head</p><ul><li><p><a href="https://github.com/joshbuchea/HEAD" target="_blank" rel="noopener">https://github.com/joshbuchea/HEAD</a></p></li><li><p>head内的内容不会显示在页面上</p></li><li><p>meta 元信息</p></li><li><p>title标签</p><ul><li>仅纯文本</li><li>如果不出现在head内会自动移到head</li><li>出现多个的话仅第一个生效</li></ul></li><li><p>页面图标</p><p>也可以不用一个标签设置，浏览器会自动读取网站根目录下的favicon.ico这个文件</p></li></ul></li><li><p>body</p><ul><li>如果在body或者html标签的<strong>结束标签之后</strong>又出现了其它的标签，则之前的结束标签就会被认为无效，浏览器会自动添加结束标签</li></ul></li></ul><ul><li>base 基准<ul><li>在标签之前加载的标签不会使用这个基准地址</li><li><code>&lt;base href=&quot;页面中所有相对路径的基准地址&quot; target=&quot;全局设置页面中所有链接的打开位置&quot;&gt;</code><ul><li>必须以<strong>/</strong>即目录结尾，否则会把最后一个/的位置作为基准路径</li><li>target属性<ul><li>_blank 新标签</li><li>_self  默认值</li><li>_parent 父窗体显示</li><li>_top 顶层窗体显示</li></ul></li></ul></li></ul></li></ul><ul><li><p>h1-h6</p><ul><li>一般页面不超过一个h1<ul><li>seo (Search Engine Optimism)</li></ul></li></ul></li><li><p>p</p></li><li><p>a</p><ul><li><p>语义是一个链接</p></li><li><p>绝对路径</p></li><li><p>相对路径</p></li><li><p>空的href连接到当前页面</p><ul><li><p>类似的，img标签的空src属性也连接到当前页面</p><p><a href="https://www.nczonline.net/blog/2009/11/30/empty-image-src-can-destroy-your-site/" target="_blank" rel="noopener">https://www.nczonline.net/blog/2009/11/30/empty-image-src-can-destroy-your-site/</a></p></li></ul></li><li><p>download 属性 html5</p><ul><li>表示点击链接将下载链接对应文件，而不是跳转，下载的文件以download属性的值来命名</li><li>只能下载自己网站的资源</li><li>这个属性能让点击下载完全由前端实现</li></ul></li></ul></li><li><p>img</p><ul><li>alt属性 alternate</li></ul></li><li><p>span 和 div</p><p>通用标签，是没有语义的标签</p></li></ul><h3 id="Git使用"><a href="#Git使用" class="headerlink" title="Git使用"></a>Git使用</h3><p>常用命令：</p><ul><li><p>git config</p></li><li><p>git init 初始化本地仓库</p></li><li><p>git status 当前仓库状态  -s紧凑显示</p></li><li><p>git add xx 将修改/新文件提交到stage区</p></li><li><p>git commit -m “提交信息” 提交暂存区文件</p></li><li><p>git diff  显示详细文件修改状态，-staged显示暂存区文件改动</p></li><li><p>git log</p></li><li><p>git merge</p></li><li><p>git clone [url]</p><p>git clone <a href="https://github.com/libgit2/libgit2" target="_blank" rel="noopener">https://github.com/libgit2/libgit2</a> mylibgit 可将本地仓库名改为mylibgit</p></li><li><p>git remote</p></li><li><p>git push/pull</p></li><li><p>git fetch</p></li><li><p>git checkout</p></li><li><p>git branch</p></li><li><p><code>https://&lt;username&gt;.github.io/</code>可以访问到<code>&lt;username&gt;.github.io</code>这个仓库里的资源</p></li><li><p><code>https://&lt;username&gt;.github.io/&lt;repo_name&gt;</code>可以访问到<code>repo_name</code>这个仓库里的资源</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> front-end </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搭建RSS自动推送服务</title>
      <link href="/2018/03/25/%E6%90%AD%E5%BB%BARSS%E8%87%AA%E5%8A%A8%E6%8E%A8%E9%80%81%E6%9C%8D%E5%8A%A1/"/>
      <url>/2018/03/25/%E6%90%AD%E5%BB%BARSS%E8%87%AA%E5%8A%A8%E6%8E%A8%E9%80%81%E6%9C%8D%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>利用Google app engine搭建自动推送RSS至kindle的服务</p><a id="more"></a><p>原repo：<a href="https://github.com/cdhigh/KindleEar" target="_blank" rel="noopener">KindleEar</a></p><p>因为网络环境原因一直没有成功。心灰意冷下看到这篇文章：</p><p><a href="https://bookfere.com/post/19.html" target="_blank" rel="noopener">KindleEar 搭建教程：推送 RSS 订阅到 Kindle</a></p><p>记录非常详细，几乎涵盖了所有问题，故转载</p>]]></content>
      
      
      
        <tags>
            
            <tag> kindle </tag>
            
            <tag> rss </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>win10下配置st3+Texlive+sumartraPDF的LaTeX环境</title>
      <link href="/2017/05/11/win10%E4%B8%8B%E9%85%8D%E7%BD%AEst3-Texlive-sumartraPDF%E7%9A%84LaTeX%E7%8E%AF%E5%A2%83/"/>
      <url>/2017/05/11/win10%E4%B8%8B%E9%85%8D%E7%BD%AEst3-Texlive-sumartraPDF%E7%9A%84LaTeX%E7%8E%AF%E5%A2%83/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>sublime配置方便而Tex live相较Ctex更灵活且自定义程度高 sumatraPDF可配置为默认的pdf预览器，并内置了反向查找的功能，具体步骤略。</p><a id="more"></a><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><ol><li>在sublime中安装好LaTeXtools插件后，找出配置文件LaTeXTools.sublime-settings</li><li>将Tex live和sumatraPDF的安装路径添加环境变量后，找的settings中的texpath，distro和sumatra项按照提示修改，再找到builder项改为simple，即配置完成。</li><li>反向代理：打开sumartaPDf，在选项的对应处输入<code>&quot;C:\Program Files\Sublime Text 3\sublime_text.exe&quot; &quot;%f:%l&quot;</code> 并执行即可。</li><li>在编辑完文档后按ctrl+b即可保存并输出pdf。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> LaTeX </tag>
            
            <tag> sublime </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Qt学习笔记</title>
      <link href="/2017/05/10/Qt%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2017/05/10/Qt%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>想做一个GUI对验证码识别程序做同意的处理，又开了个新坑，并没有任何Qt的基础，Python相对C++比较简单，因此使用PyQt来做，本文为快速制作一个简陋的GUI程序的学习过程。</p><a id="more"></a><h3 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h3><p>参见另一文中的末尾<a href="http://limbotech.top/2017/04/14/python-opencv/" target="_blank" rel="noopener">Windows下Pycharm+Anaconda+Opencv图像处理环境配置</a></p><h3 id="设计过程"><a href="#设计过程" class="headerlink" title="设计过程"></a>设计过程</h3><p>可以参考另一系列教程<a href="http://blog.csdn.net/a359680405/article/details/45096185" target="_blank" rel="noopener">PyQt5学习笔记01—-第一个窗口</a>已经写的非常详细了</p><p>设计结果：</p><p><img src="/assets/Blogimg/2017.5.11/1.png" alt></p><p>下面说说自己0基础学习时的问题：</p><ol><li><p>由QT Designer设计好的UI执行Pyuic生成的ui代码会覆盖之前的，所以我们需要创建一个新的主程序通过调用UI程序来实现代码与界面分离，在主程序中添加功能。</p></li><li><p>主程序中新建一个类例如：</p></li></ol><p class="code-caption" data-lang="python" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span><a class="code-caption-copy">Copy Code</a></p>``` python class MainWindow(QtWidgets.QMainWindow, Ui_MainWindow):    def __init__(self):        super(recognizer, self).__init__()        self.setupUi(self)```<p>   其中<code>def __init__(self)</code>为窗口初始化的部分，信号连接，字体等设置放在这里面</p><ol start="3"><li><p>自定义的槽函数也放置在class中</p></li><li><p>调用label来显示文字及图像信息</p></li></ol><p class="code-caption" data-lang="python" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span><a class="code-caption-copy">Copy Code</a></p>``` python self.label.XXXXXXXXX```<ol start="5"><li><p>可以设置全局变量来记录之前打开的文件路径，程序结果等。</p></li><li><p>使用<a href="https://anthony-tuininga.github.io/cx_Freeze/" target="_blank" rel="noopener">cxfreeze</a>来打包生成可执行文件(to be continued)</p></li><li><p><a href="https://anthony-tuininga.github.io/cx_Freeze/" target="_blank" rel="noopener">cxfreeze</a>打包会生成很多库文件，不方便使用，可用<a href="http://www.pyinstaller.org/" target="_blank" rel="noopener">pyinstaller</a>打包成单一可执行文件</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> PyQt </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>验证码识别研究</title>
      <link href="/2017/04/18/%E9%AA%8C%E8%AF%81%E7%A0%81%E8%AF%86%E5%88%AB%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6/"/>
      <url>/2017/04/18/%E9%AA%8C%E8%AF%81%E7%A0%81%E8%AF%86%E5%88%AB%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="研究背景"><a href="#研究背景" class="headerlink" title="研究背景"></a>研究背景</h3><p>验证码(CAPTCHA) 最早作为卡内基梅隆大学的一个科研项目，Yahoo! 是CAPTCHA 的第一个用户。CAPTCHA 是“Completely Automated Public Turing test to tell Computers and Humans Apart”(全自动区分计算机和人类的图灵测试)的缩写，是一种区分用户是人类还是计算机的公共自动程序。在一个验证码测试中，由计算机生成一个问题并评判用户的答案，这个问题必须只有人类才能解答。由于计算机无法解答，回答出该问题的用户就会被认为是人类  。CAPTCHA 在网络上的大规模使用起源于 1999-2000 年 Yahoo 网站的账号注册。目前大部分网站都引入了验证码机制来加强网络的安全验证。通过对验证码识别的研究，能够及时发现验证码存在的安全漏洞，对设计出更加安全的验证码有参考价值，对图像处理，模式识别等相关领域也具有重要意义。</p><a id="more"></a><h3 id="验证码识别的具体过程"><a href="#验证码识别的具体过程" class="headerlink" title="验证码识别的具体过程"></a>验证码识别的具体过程</h3><p>识别流程一般为：</p><div id="flowchart-0" class="flow-chart"></div><p>本课题主要介绍验证码识别中常用的数字图像处理技术，研究对象为卡提诺社区的验证码，给出算法流程和识别结果，并对结果进行分析。</p><h4 id="验证码示例及特点："><a href="#验证码示例及特点：" class="headerlink" title="验证码示例及特点："></a>验证码示例及特点：</h4><p>从原网页下载了一万张待标注的验证码：</p><p><img src="/assets/Blogimg/%E9%AA%8C%E8%AF%81%E7%A0%81%E8%AF%86%E5%88%AB%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6/3731.png" alt><img src="/assets/Blogimg/%E9%AA%8C%E8%AF%81%E7%A0%81%E8%AF%86%E5%88%AB%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6/3733.png" alt><img src="/assets/Blogimg/%E9%AA%8C%E8%AF%81%E7%A0%81%E8%AF%86%E5%88%AB%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6/3734.png" alt><img src="/assets/Blogimg/%E9%AA%8C%E8%AF%81%E7%A0%81%E8%AF%86%E5%88%AB%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6/3732.png" alt></p><p>由观察可得此类验证码的特点：</p><ol><li>每幅验证码字符由4位数字和英文字母组成，且字体种类不多</li><li>每个字符的颜色与背景的噪声颜色都不相同</li><li>字符没有粘连，便于字符分割</li></ol><p>由以上特点设计的识别流程如下：</p><div id="flowchart-1" class="flow-chart"></div><h4 id="识别流程"><a href="#识别流程" class="headerlink" title="识别流程"></a>识别流程</h4><p>根据设计好的识别方案，从之前下载的验证码中选取了200张作为实验数据及模式识别的样本，具体流程如下:</p><h5 id="颜色聚类"><a href="#颜色聚类" class="headerlink" title="颜色聚类"></a>颜色聚类</h5><p>验证码图像中字符间颜色不同且均匀，可通过颜色聚类的方法将字符分离。</p><p>主要使用K-means算法，原理：</p><p>从数据集合中选取K个点作为各簇的中心，计算集合中各元素到各簇心的距离，使距离最近的元素为一类，再计算各类的中心作为新的簇心，重复上述过程，直到簇心的位置不变。</p><ol><li><p>将获取的RGB图换值LAB空间，由于LAB空间色域广且各分量间联系较小，更适合颜色聚类。</p><p>RGB原图：</p><p><img src="/assets/Blogimg/%E9%AA%8C%E8%AF%81%E7%A0%81%E8%AF%86%E5%88%AB%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6/%E5%9B%BE%E7%89%871.png" alt></p><p>LAB空间：</p><p><img src="/assets/Blogimg/%E9%AA%8C%E8%AF%81%E7%A0%81%E8%AF%86%E5%88%AB%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6/%E5%9B%BE%E7%89%872.png" alt></p></li><li><p>将图像每个像素值的L,A,B三个分量为一组作为特征向量，用K-means进行颜色聚类，由于背景的噪声颜色较复杂，因此K值取的较大，取K = 40。</p><p>颜色聚类后(已按类标记)：</p><p><img src="/assets/Blogimg/%E9%AA%8C%E8%AF%81%E7%A0%81%E8%AF%86%E5%88%AB%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6/%E5%9B%BE%E7%89%873.png" alt></p></li></ol><h5 id="类图处理"><a href="#类图处理" class="headerlink" title="类图处理"></a>类图处理</h5><p>由于颜色聚类后得到的矩阵是对原图不同类的标记，因此将每一类的标记点置黑，其他点置白，可以得到K张类图，其中4张包含字符的类图，(K - 4)张包含各类的颜色的噪声图，省去了预处理中灰度化的步骤。</p><p>因为K张类图都有一定数量的像素数，且背景噪声中可能包含与待识别字符颜色相同的零星噪点，难以直接获得包含字符的类图。通过人工挑选出包含字符的类图，经过多次实验，字符的像素点数量大致在[70,500]区间。</p><p>对之前的K张类图做4邻域的连通域去噪，步骤：</p><p>扫描整张图像，将不同4邻域的连通域标记为不同数字，统计各连通域的像素点数，将小于70或大于500的连通域置白。</p><p>处理后得到的各类图像种类：空白的噪声图像，只包含字符的图像，包含与字符像素点数类似的噪声图像。</p><h5 id="投影分割"><a href="#投影分割" class="headerlink" title="投影分割"></a>投影分割</h5><p>经由上述步骤获得的图像，</p><p>人工选取包含字符的图像，经过多次实验，得到字符像素长度和高度的大致区间为[7,25],[8,28]。</p><p>计算每一列黑像素点的总数，形成竖直投影波形，根据投影波形的过零点确定图像像素区域的边界得到宽度；同理计算每行的黑点数，可得到像素区域高度。将在区间外的类图剔除，最后得到的即为原图中的四个字符图像，由字符最左端的像素位置可确定四个字符在原图中的顺序。</p><p>但也可能存在与待识别的字符像素数及长宽都类似的噪声，如下图所示：</p><p><img src="/assets/Blogimg/%E9%AA%8C%E8%AF%81%E7%A0%81%E8%AF%86%E5%88%AB%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6/5.png" alt><img src="/assets/Blogimg/%E9%AA%8C%E8%AF%81%E7%A0%81%E8%AF%86%E5%88%AB%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6/169.jpg" alt><img src="/assets/Blogimg/%E9%AA%8C%E8%AF%81%E7%A0%81%E8%AF%86%E5%88%AB%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6/389.jpg" alt><img src="/assets/Blogimg/%E9%AA%8C%E8%AF%81%E7%A0%81%E8%AF%86%E5%88%AB%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6/356.jpg" alt><img src="/assets/Blogimg/%E9%AA%8C%E8%AF%81%E7%A0%81%E8%AF%86%E5%88%AB%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6/819.jpg" alt><img src="/assets/Blogimg/%E9%AA%8C%E8%AF%81%E7%A0%81%E8%AF%86%E5%88%AB%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6/741.jpg" alt></p><h5 id="特征提取"><a href="#特征提取" class="headerlink" title="特征提取"></a>特征提取</h5><p>由于以上得到的各个字符大小不尽相同，为统一字符特征，将字符的大小已近邻插值的方式归一化至$28*28$的大小.</p><p>将作为实验数据的200个验证码分离出的字符手动分类，得到由24种字符组成的样本库：</p><p>$$\Omega = {2,3,4,6,7,8,9,B,C,E,F,G,H,J,K,M,P,Q,R,T,V,W,X,Y}$$</p><p>其中部分字符有不同的字体，部分英文字符有大小写，但不影响识别且为简化识别步骤，故将其分为同一类。</p><p>对字符主要提取4*4的粗网格统计特征：</p><p><img src="/assets/Blogimg/%E9%AA%8C%E8%AF%81%E7%A0%81%E8%AF%86%E5%88%AB%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6/4.PNG" alt></p><p>计算每个网格内的像素值占总像素值的比列，将这16个数据作为一组特征向量储存，以二进制储存对应的类别编号。</p><p>为提高识别率，增加了边缘特征：</p><p><img src="/assets/Blogimg/%E9%AA%8C%E8%AF%81%E7%A0%81%E8%AF%86%E5%88%AB%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6/1.png" alt><img src="/assets/Blogimg/%E9%AA%8C%E8%AF%81%E7%A0%81%E8%AF%86%E5%88%AB%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6/2.png" alt></p><p>对作图所示的字符使用Canny边缘检测得到字符的边界，如右图所示，统计左图黑点数及右图白点数，将比值作为特征向量的第17个数据加入。</p><h5 id="字符识别及结果分析："><a href="#字符识别及结果分析：" class="headerlink" title="字符识别及结果分析："></a>字符识别及结果分析：</h5><p>对单个字符的识别采用 K 近邻(KNN)算法，该方法首先储存训练样本，计算测试样本和每个训练样本特征向量的欧式距离，若在所有的训练样本中，得到与测试样本最接近的的 K 个的样本出现频率最高的类别，则该样本也属于这个类别。多次实验后取K为4。</p><p>之前<strong>投影分割</strong>步骤中提到的出现与待识别字符大小及像素点均类似的噪声，使用KNN计算后得到的与样本最小距离偏较大，多次实验后，得到大致阈值。若KNN步骤中最小 距离大于该值的对象则舍弃，以此去除该类噪声。</p><p>另取100张验证码人工标注后以之前的样本库用KNN识别，正确的有92幅，识别率为0.92。出现错误的结果原因基本为字符缺少，应为预处理步骤阈值等需要调整。</p><p>已用程序标注好所有一万张验证码。</p><h3 id="接下来的工作"><a href="#接下来的工作" class="headerlink" title="接下来的工作"></a>接下来的工作</h3><ol><li>校验程序标注的验证码</li><li>解决仍存在识别结果错误的问题</li><li>用Python重写程序以提高程序效率</li></ol><script src="https://cdnjs.cloudflare.com/ajax/libs/raphael/2.2.7/raphael.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/flowchart/1.6.5/flowchart.min.js"></script><textarea id="flowchart-0-code" style="display: none">st=>start: Startpre=>operation: 预处理sp=>operation: 字符分割re=>operation: 字符识别e=>endst->pre->sp->re->e</textarea><textarea id="flowchart-0-options" style="display: none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-0-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-0", options);</script><textarea id="flowchart-1-code" style="display: none">st=>start: Starta=>operation: 颜色聚类b=>operation: 噪声处理c=>operation: 投影分割d=>operation: 模式识别e=>endst->a->b->c->d->e</textarea><textarea id="flowchart-1-options" style="display: none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-1-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-1-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-1", options);</script>]]></content>
      
      
      
        <tags>
            
            <tag> Opencv </tag>
            
            <tag> Matlab </tag>
            
            <tag> 图像处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows下Pycharm+Anaconda+Opencv图像处理环境配置</title>
      <link href="/2017/04/14/python-opencv/"/>
      <url>/2017/04/14/python-opencv/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>软件下载略</p><p><strong>opencv</strong> 的库可以从这里下载：</p><p><a href="http://www.lfd.uci.edu/~gohlke/pythonlibs/" target="_blank" rel="noopener">Unofficial Windows Binaries for Python Extension Packages</a></p><a id="more"></a><p>复制入/lib/site-packages</p><p class="code-caption" data-lang="python" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span><a class="code-caption-copy">Copy Code</a></p>``` python pip install *.whl```<p>进行安装</p><p><strong>Anaconda</strong>是一个成熟的python科学计算发行版，包含很多常用的库，省去了很多麻烦</p><p>可以在这里获取licenses，并放入user/.continuum：</p><p><a href="https://anaconda.org/limbopy/settings/add-ons" target="_blank" rel="noopener">licenses</a></p><p>有自己的控制台命令</p><p class="code-caption" data-lang="conda" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span><a class="code-caption-copy">Copy Code</a></p>``` conda conda -h```<p>可以查看帮助</p><p><strong>Pycharm</strong>是功能强大的python IDE，虽然<strong>Anaconda</strong>有捆绑<strong>Spyder</strong>，但这款功能更强</p><h3 id="PyQt5的配置"><a href="#PyQt5的配置" class="headerlink" title="PyQt5的配置"></a>PyQt5的配置</h3><p>由于需要编写GUI，与设计数据库的方式很类似，配置可参考<a href="http://www.jianshu.com/p/094928ac0b73" target="_blank" rel="noopener">Python3 PyQt5 pycharm 环境搭建</a></p><p>在from PyQt5 import 包时报错，原因是Python3.6(Anaconda)目录下缺少python3.dll文件，从官网下载embeddable包复制即可，参考<a href="http://blog.5ibc.net/p/116112.html" target="_blank" rel="noopener">python3.6.0(Anaconda)安装PyQt5，“DLL load failed: 找不到指定的模块</a></p><p>需要调用资源配置在pyrcc中配置，与配置pyuic类似，pyrcc5.exe文件再anaconda/scripts目录下</p>]]></content>
      
      
      
        <tags>
            
            <tag> PyQt </tag>
            
            <tag> Python </tag>
            
            <tag> Opencv </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows下配置Hexo+GitHub博客基本步骤及遇到的问题</title>
      <link href="/2017/04/14/Windows%E4%B8%8B%E9%85%8D%E7%BD%AEHexo-GitHub%E5%8D%9A%E5%AE%A2%E5%9F%BA%E6%9C%AC%E6%AD%A5%E9%AA%A4%E5%8F%8A%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <url>/2017/04/14/Windows%E4%B8%8B%E9%85%8D%E7%BD%AEHexo-GitHub%E5%8D%9A%E5%AE%A2%E5%9F%BA%E6%9C%AC%E6%AD%A5%E9%AA%A4%E5%8F%8A%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>初衷是想找一个成本低廉又能保存一些技术学习笔记的地方，免费的OneNote对代码输入非常不友好，因此想到这样一个折中的搭建个人博客的方法，hexo用于搭建静态博客非常方便，同时能使用markdown编辑文章，而GitHub的门槛也非常低，网上教程也很多，步骤和自己遇到的一些问题如下：</p><a id="more"></a><h4 id="安装Node-js及Git"><a href="#安装Node-js及Git" class="headerlink" title="安装Node.js及Git"></a>安装Node.js及Git</h4><p>从主页下载即可，配置好git</p><h4 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h4><p>打开终端，输入</p><p class="code-caption" data-lang="bash" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span><a class="code-caption-copy">Copy Code</a></p>``` bash npm install -g hexo```<p>等待安装完成，无法安装可设置npm代理</p><p class="code-caption" data-lang="bash" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span><a class="code-caption-copy">Copy Code</a></p>``` bash npm config set registry http://registry.cnpmjs.org```<h4 id="创建Hexo文件夹"><a href="#创建Hexo文件夹" class="headerlink" title="创建Hexo文件夹"></a>创建Hexo文件夹</h4><p>在预备作为储存博客页面的文件夹内打开终端，依次输入</p><p class="code-caption" data-lang="bash" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span><a class="code-caption-copy">Copy Code</a></p>``` bash 1. hexo init #会自动创建git repo2. npm install```<p>查看是否创建成功</p><p class="code-caption" data-lang="bash" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span><a class="code-caption-copy">Copy Code</a></p>``` bash 1. hexo generate #生成静态页面2. hexo server #在本地启动 少用，由于路径的原因，会产生各种问题```<p>浏览器输入默认的local:4000端口即可查看页面</p><h4 id="创建GitHub-repo"><a href="#创建GitHub-repo" class="headerlink" title="创建GitHub repo"></a>创建GitHub repo</h4><p>注意repo名应当为username.github.io否则部署后会有问题</p><h4 id="获取SSH密钥并添加"><a href="#获取SSH密钥并添加" class="headerlink" title="获取SSH密钥并添加"></a>获取SSH密钥并添加</h4><p>打开终端，键入</p><p class="code-caption" data-lang="bash" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span><a class="code-caption-copy">Copy Code</a></p>``` bash ssh-keygen -t rsa -C "xxx@xx" #后为github账号注册时的邮箱地址```<p>在User\name \ .ssh\路径下找到id_rsa.pub</p><p>复制密钥，添加入GitHub的setting中即可</p><p>测试是否添加成功：打开终端，输入：</p><p class="code-caption" data-lang="bash" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span><a class="code-caption-copy">Copy Code</a></p>``` bash ssh -T git@github.com```<p>成功添加会提示相应字样</p><p>ps：代理等原因会影响连接，例如</p><p class="code-caption" data-lang="bash" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span><a class="code-caption-copy">Copy Code</a></p>``` bash $ ssh -vT git@github.comOpenSSH_7.3p1, OpenSSL 1.0.2k  26 Jan 2017debug1: Reading configuration data /etc/ssh/ssh_configdebug1: Connecting to github.com [93.46.8.89] port 22.debug1: Connection established.debug1: identity file /c/Users/Limbo/.ssh/id_rsa type 1debug1: key_load_public: No such file or directorydebug1: identity file /c/Users/Limbo/.ssh/id_rsa-cert type -1debug1: key_load_public: No such file or directorydebug1: identity file /c/Users/Limbo/.ssh/id_dsa type -1debug1: key_load_public: No such file or directorydebug1: identity file /c/Users/Limbo/.ssh/id_dsa-cert type -1debug1: key_load_public: No such file or directorydebug1: identity file /c/Users/Limbo/.ssh/id_ecdsa type -1debug1: key_load_public: No such file or directorydebug1: identity file /c/Users/Limbo/.ssh/id_ecdsa-cert type -1debug1: key_load_public: No such file or directorydebug1: identity file /c/Users/Limbo/.ssh/id_ed25519 type -1debug1: key_load_public: No such file or directorydebug1: identity file /c/Users/Limbo/.ssh/id_ed25519-cert type -1debug1: Enabling compatibility mode for protocol 2.0debug1: Local version string SSH-2.0-OpenSSH_7.3ssh_exchange_identification: Connection closed by remote host```<p>关闭代理即可</p><h4 id="Hexo的配置和部署"><a href="#Hexo的配置和部署" class="headerlink" title="Hexo的配置和部署"></a>Hexo的配置和部署</h4><p>_config.yml为全局配置文件，在Deployment区域，修改为：</p><p class="code-caption" data-lang="bash" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span><a class="code-caption-copy">Copy Code</a></p>``` bash deploy:  type: git  repo:      github: git@github.com:username/username.github.io.git,master```<p>若要关联自己的域名令需添加CNAME文件</p><p>终端部署命令：</p><p class="code-caption" data-lang="bash" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span><a class="code-caption-copy">Copy Code</a></p>``` bash hexo clean #清楚缓存hexo generatehexo deploy```<p>在此之前可能需要输入</p><p class="code-caption" data-lang="bash" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span><a class="code-caption-copy">Copy Code</a></p>``` bash npm install hexo-deployer-git --save```<p>安装部署插件</p><p>至此，基本的配置工作已完成。</p><p class="code-caption" data-lang="bash" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span><a class="code-caption-copy">Copy Code</a></p>``` bash hexo new "title"```<p>可在source\ _posts下生成“title”标题的新md文件</p><p>由于国内的特殊网络环境，访问已搭建好的页面需要输入<a href="https://username.github.io" target="_blank" rel="noopener">https://username.github.io</a></p><h3 id="Hexo主题"><a href="#Hexo主题" class="headerlink" title="Hexo主题"></a>Hexo主题</h3><p>推荐一个主题<a href="https://github.com/litten/hexo-theme-yilia" target="_blank" rel="noopener">yilia</a></p><p>也是本站正使用的，Reademe很详细也不再此赘述</p><h3 id="绑定个人域名"><a href="#绑定个人域名" class="headerlink" title="绑定个人域名"></a>绑定个人域名</h3><p>如果你有闲置的域名，可以将其绑定至刚配置好的博客页</p><p>在域名管理页的DNS控制中添加域名解析类型为A指向IP地址(在控制台中ping一下搭好的博客地址可以得到)或者添加CNAME指向域名，选择其一即可，不能同时添加</p><p>在source目录下添加名为CNAME的文件(无后缀)，内容为你要绑定的域名</p><p>修改_config.yml中的url为要绑定的域名，部署即可</p><h3 id="关于写作"><a href="#关于写作" class="headerlink" title="关于写作"></a>关于写作</h3><p>在文章中加入<code>&lt;!-- more --&gt;</code>可以将文章截断显示在主页，防止文章过长</p><p>文章头的reward和comments分别为打赏和评论，值为True/False</p><p class="code-caption" data-lang="bash" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span><a class="code-caption-copy">Copy Code</a></p>``` bash hexo new page xxx```<p>可以新建一个名为xxx的页面，以此做了一个留言板</p><hr><p><em>以下是对<a href="https://github.com/litten/hexo-theme-yilia" target="_blank" rel="noopener">yilia</a>主题的修改，增加一些功能</em></p><h3 id="跟帖及留言"><a href="#跟帖及留言" class="headerlink" title="跟帖及留言"></a>跟帖及留言</h3><p>添加评论以及留言的功能，的功能，按照<a href="http://lawlite.me/" target="_blank" rel="noopener">lawlite</a>的方法并没有成功，因此改用来必力的跟帖</p><p>从来比力网站获取web代码后，在themes\yilia\layout\ _partial下的article.ejs最后添加即可</p><p>例如：</p><p class="code-caption" data-lang="html" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span><a class="code-caption-copy">Copy Code</a></p>``` html <% if (!index && post.comments){ %><div id="lv-container" data-id="city" data-uid="XXXXXXXXX">  <script type="text/javascript">   (function(d, s) {       var j, e = d.getElementsByTagName(s)[0];<pre><code>   if (typeof LivereTower === &#39;function&#39;) { return; }   j = d.createElement(s);   j.src = &#39;https://cdn-city.livere.com/js/embed.dist.js&#39;;   j.async = true;   e.parentNode.insertBefore(j, e);</code></pre><p>   })(document, ‘script’);<br>  </script><br><noscript> 为正常使用来必力评论功能请激活JavaScript</noscript><p></p></div><% } %>```<p>最外层的标签可以取消在主页和控制文章中显示跟帖</p><h3 id="网站访问量功能"><a href="#网站访问量功能" class="headerlink" title="网站访问量功能"></a>网站访问量功能</h3><p>在<a href="http://ibruce.info/2015/04/04/busuanzi/" target="_blank" rel="noopener">不蒜子</a>获取代码后放入themes\yilia\layout\ _partial下的footer.ejs中即可</p><h3 id="在文章中插入音乐"><a href="#在文章中插入音乐" class="headerlink" title="在文章中插入音乐"></a>在文章中插入音乐</h3><p>由于是在github上搭建的博客，直接从网易云获取的外链不支持https，从知乎搜索到一个解决办法</p><p class="code-caption" data-lang="bash" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span><a class="code-caption-copy">Copy Code</a></p>``` bash npm install --save hexo-tag-aplayer```<p>安装播放器插件</p><p><del>在<a href="https://github.com/YUX-IO/163music-APlayer-you-get-docker" target="_blank" rel="noopener">A Flask Music Project. Demo</a>项目中找到音乐链接，修改相应参数即可</del></p><p>在网易云音乐中找到对应曲目，然后生成外链。</p><p>代码如下：</p><p class="code-caption" data-lang="html" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span><a class="code-caption-copy">Copy Code</a></p>``` html <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="329" height="100" src="https://music.163.com/outchain/player?type=2&id=26513177&auto=0"></iframe>```<p>效果如下：</p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="329" height="100" src="https://music.163.com/outchain/player?type=2&id=26513177&auto=0"></iframe></%></%>]]></content>
      
      
      
        <tags>
            
            <tag> blog </tag>
            
            <tag> hexo </tag>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2017/04/14/hello-world/"/>
      <url>/2017/04/14/hello-world/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><a id="more"></a><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><p class="code-caption" data-lang="bash" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span><a class="code-caption-copy">Copy Code</a></p>``` bash $ hexo new "My New Post"```<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><p class="code-caption" data-lang="bash" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span><a class="code-caption-copy">Copy Code</a></p>``` bash $ hexo server```<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><p class="code-caption" data-lang="bash" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span><a class="code-caption-copy">Copy Code</a></p>``` bash $ hexo generate```<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><p class="code-caption" data-lang="bash" data-line_number="frontend" data-trim_indent="backend" data-label_position="outer" data-labels_left="Code" data-labels_right=":" data-labels_copy="Copy Code"><span class="code-caption-label"></span><a class="code-caption-copy">Copy Code</a></p>``` bash $ hexo deploy```<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Hello world </tag>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
