[{"title":"前端学习week23","date":"2019-10-20T12:50:41.000Z","path":"2019/10/20/前端学习week23/","text":"​ 本周主要在做vue的东西，多少是相通的，react之后再来整理 React 组件名第一个字母一定为大写字母，否则会被当做自定义标签编译成react元素 React.createElement(&quot;div&quot;, null); React.createElement(Div, null); props和state的区别：props是父级传给子组件的属性的值，通过this.props.xxx获取，且禁止修改。而state是组件的私有数据对象，可以调用this.state.xxx获取，只能通过this.setState()更新(可以直接赋值改变，但不会触发重新渲染) class式组件不需要用state时可以省略constructor，这是es6的class语法！！，相当于自动执行了constuctor(...args) {super(...args)} 函数式组件不能使用state，简洁，只接收一个props参数， 返回一个react元素 组件中调用this.setState()每次改变时都会重新调用render，注意{}中表达式调用方法的this，可以利用箭头函数的this绑定特性，class field 因为将函数名传入事件处理机时this会隐式丢失！！回忆概念，所以需要特别注意，建议无脑写成箭头函数内调用的形式比较保险 传入箭头函数在每次执行render时都相当于传入了一个新的函数，由于这个属性值改变，该元素会重新渲染，react的做法是会先重新调用一次旧函数，传入参数null(防止内存泄漏)，再执行一次新函数，传入对应的参数。注意两次调用的作用域也不同 关于事件处理函数，在组件标签上的自定义时间的处理函数传入的参数都需要自己设置，而在原生标签的原生属性上第一个传入的参数默认为事件对象 原生时间直接绑在组件标签上不会生效 this.setState()更新是异步的，微任务，回调可以接一个state参数，作为上个setState更新后的state(与this.state不是同一个对象！)，注意setState是回调形式的异步，不是promise，所以不能用await JSX 其实只是React.createElement()的语法糖，所以组件标签类型可以是首字母大写的组件名称，可以是首字母大写的变量，可以用首字母大写的对象点语法引用，但不能是表达式，其他情况会当做原生标签的字符串传入React.createElement() jsx返回的内容也只能有一个根结点 不产生单独的作用域 标签属性不能用中划线，只能驼峰式 语法实际被编译成React.createElement()调用 时刻记住代码中写的是类html而不是真正的html，注意一些细节：属性名可以大写，自闭和标签一定要加斜杠等 style属性不能接字符串，只能传对象 数字0依然会被渲染为0，其他的falsy会被忽略不会被渲染 表单onChange事件按键即触发，原生change事件(vue)在光标移开/回车才触发 特殊的propss属性 children 可以传递多种类型的值，会将写在A组件标签中间的元素都传入这个属性(中间可以不只一个根结点)，在A组件的定义中会渲染在{props.children}的位置，类似vue的插槽，但是不强制用children，可以用任意别的属性，然后在标签属性中传入react元素达到同样的效果 当组件标签中间是函数或字符串时，它就是对应的值 标签的ref属性传入函数时会在元素渲染完成后调用并传入参数为结点对象 现在的做法，构造器中创建一个React.creatRef()对象，将该对象传入ref属性，然后在该对象的current属性调用对应dom结点，需要多个ref就创建多个对象 当 ref 属性用于 HTML 元素时，构造函数中使用 React.createRef() 创建的 ref 接收底层 DOM 元素作为其 current 属性。 当 ref 属性用于自定义 class 组件时，ref 对象接收组件的挂载实例作为其 current 属性。 不能在函数组件上使用 ref 属性，因为它们没有实例 (函数式组件在使用时是直接调用，class式组件是创建一个实例)，但是可以在函数组件内部的元素上使用 不要用字符串形式的ref ref转发React.forwardRef 三个被标记为unsafe即将废弃的生命周期函数 componentWillMount componentWillReceiveProps componentWillUpdate 原因是在异步渲染时会造成未预料的问题update on async rendering render method should be pure function of props &amp; state portals可以让组件中的元素渲染在组件的dom树之外的位置，但是react内的事件处理逻辑等还是在原来的组件中(比如冒泡) context，需要在全局创建一个变量xxxContext value= React.createContext(defaultValue);，然后用&lt;xxxContext.Provider value=&quot;xxx&quot;&gt;包裹父组件，在需要使用这个值的class子组件中挂载static contextType = xxxContent，在通过this.context消费最近的value，并且可以在任何生命周期中访问到。 当子组件为函数组件时： &lt;MyContext.Consumer&gt; {value =&gt; /* 基于 context 值进行渲染*/} //value就是provider上的值 &lt;/MyContext.Consumer&gt; SyntheticEvent，事件处理时传入处理机的事件对象其实都是在原生事件上包装过的合成事件，保留了一些原生的接口，主要是为了兼容问题，此外为了节省内存，同一个类型的事件触发可能会复用同一个合成事件对象，并且处理完成后会清空，所以尽量不要异步访问事件(譬如当使用this.setState(state =&gt; {xxx: e.target.value}) 时) 不可变数据，便于在组件更新是比较前后的props和state(===即可)，节省空间，性能优化 immer Hooks useState 返回的赋值函数会完全覆盖之前的值，不是合并(与class中的this.setState不同) useState内部可能是通过栈来判断是哪个组件在调用这个函数，同一个函数组件中多个useState的返回结果依赖其调用顺序，所以要包证该组件函数在多次调用时其useState的个数和变量名不变 useEffect传入第二个数组参数跳过这个步骤时，注意内部函数的作用域，数组中要包含useEffect要使用的变量，否则会执行最初作用域的函数(空数组表示只有挂载卸载时会执行) useEffect在第一次渲染和每次更新后都会执行(相当于 componentDidMount + componentDidUpdate 但不会阻塞浏览器更新屏幕) react-router guide redux","tags":[{"name":"fromt-end","slug":"fromt-end","permalink":"babopo.github.io/tags/fromt-end/"},{"name":"react","slug":"react","permalink":"babopo.github.io/tags/react/"}]},{"title":"前端学习week22","date":"2019-10-13T14:45:56.000Z","path":"2019/10/13/前端学习week22/","text":"​ 有几周没有更新了，标题还是顺接上一篇吧，这几周主要学了一下vue，将一些理解记录如下 跨域的集中方式 cors jsonp 服务器代理 iframe document.domain 只能设置为上级域 Virtual DOM lit-html dom diff dom diff的时间复杂度分析 react中的diff算法是同层级比较，不同类型的元素会以此元素为根结点将整棵树拆解重新装载，同一类型的则会保留dom结点，只修改改变的属性/值，重新调用实例的render（这里可以在组件类中设置shouldComponentUpdate的生命周期方法，来达到性能优化的目的），当一个dom元素有多个子元素时可以给子元素设置单独的key来优化使利用重复元素，注意key只在不得已时可以使用index，因为重排会改变其index，而算法根据这个key对比，可能达不到预期效果，降低了算法处理的效率 vue中的虚拟DOM Vue 创建实例的选项里不要用箭头函数！！(this啊this) 先注册的组件再创建实例，否则使用的组件第一次渲染时不会渲染 也可先不挂载el dom节点在被挂载时渲染 所有的 Vue 组件都是 Vue 实例，并且接受相同的选项对象 生命周期钩子的 this 上下文指向调用它的 Vue 实例 vue实例/组件生成时选项内data属性中的值会直接作为实例的属性 mustache模板 不能访问自定义的全局变量，因为是在一个沙盒中 访问实例的属性不需要this 只能放字符串或一个表达式，不能放语句和控制流 在标签中使用表达式，注意 标签属性名中的空格和引号等符号会触发编译错误 html和css是大小写不敏感的，属性名用大写编译时也会强制转为小写 vue中computed里的getter 只要响应式依赖不改变就不会重新求值而是直接返回缓存 所以return Date.now()这种再次调用时不会再更新 vue渲染时判断写在标签表达式真假是判断是否为truthy (类型转换后是否为true)，而不只是true 同一对v-if和v-else必须直接相邻 在if和else中相同的元素在切换时不会重新渲染，而仅仅在渲染好的元素上改变属性，这个特性会使切换时保留用户的输入，给相同的标签添加不同的key属性可以关闭这个特性 注意v-for中绑定key需要使用v-bind指令，而v-if/v-else中不用，key只能用基本类型的值，v-for中使用key可以使更新时重排减少开销而不是重新渲染 组件上使用v-for时必须绑定key v-for的优先级高于v-if v-show不支持template元素，v-show和v-if的区别是v-show是创建时无论如何都会渲染的，操纵的知识css的display属性，而v-if会在切换时重新渲染 注意用索引向数组中加入元素和改变数组长度不会被检测，也就不会触发渲染 对于已经创建的实例，Vue 不允许动态添加根级别的响应式属性(能加上，但不是响应式的)，但是可以用Vue.set()/app.$set()，这两个方法是一样的 使用组件元素时再原生标签上使用is=&quot;name&quot;属性优于直接使用自定义的&lt;name&gt;&lt;/name&gt;，原因比如在 &lt;ul&gt; 元素内只有 &lt;li&gt; 元素会被看作有效内容 组件是可复用的vue实例，和new Vue接受的选项大致相同，除了el这种根实例特有的选项 组件中的data选项需要写成函数返回对象的形式，必须是一个函数，因为每使用一次组件都会创建一个新的实例，这样就达成了复用的目的，每个实例都是独立的拷贝 组件模板中必须要有一个根元素 由浏览器解析的自定义标签不能写成自闭合形式(vue自己解析的可以) 注意代码是由浏览器解析还是vue解析，主要是命名规则（大小写），和自闭和标签是否可用 单文件组件中的template标签内可以将自定义空标签写成自闭合 prop传入的值是单向更新的，只能从父级向下更新，反之不行，子组件可通过事件向父组件反馈信息 watch的变量只有在变量直接变化时才能侦听到，如果变量指向一个对象，对象属性变化是侦听不到的，可以加上deep: true选项 data双向绑定的原理：利用Object.defineProperty选项中的set和get v-on后接绑定的函数名或可执行代码，若可执行的代码得到的是一个function，这个function并不会执行 vue中的命名规则：kebab和camel是相通的，即for-example和forExample是相通的，只要命名了一个另一个就能直接用，指向相同的值(并不，目前只发现组件的props中的属性会相通，即用for-example命名的属性接受到数据后，可以用this.forExample在方法中调用)，但是仍需注意浏览器不认识大小写，思考了一下，应该是表达式中可以通用，用字符串表示不可以 在非template的地方使用该作用域中的值和方法($emit)不要忘了用this Vuex 一种数据对象状态管理机制，基本思路就是对被多个实例引用的共享数据对象，不是直接给数据对象中的属性赋值来改变其状态，而是通过使用状态管理封装的方法来修改，通过封装计算属性来读取数据，这样能方便调试和追踪状态变化 两个组件中生成计算属性的辅助函数的原理 //getter 相当于 vuex的store中的计算属性 function mapGetters(getterFields) { var obj = {} for(let field of getterFields) { obj[field] = function(){ return this.$store.getters[field] } } return obj } &lt;p class=&quot;code-caption&quot; data-lang=&quot;&quot; data-line_number=&quot;frontend&quot; data-trim_indent=&quot;backend&quot; data-label_position=&quot;outer&quot; data-labels_left=&quot;Code&quot; data-labels_right=&quot;:&quot; data-labels_copy=&quot;Copy Code&quot;&gt;&lt;span class=&quot;code-caption-label&quot;&gt;&lt;/span&gt;&lt;a class=&quot;code-caption-copy&quot;&gt;Copy Code&lt;/a&gt;&lt;/p&gt; function mapState(obj) { var result = {} for(let key in obj) { let val = obj[key] result[key] = function() { return val.call(this, this.$store.state) } } return result } 子组件中通过this.$store访问根实例中注册的store实例 mutations 同步 actions 异步，因为actions要通过commit方法提交 store中只有getters能访问其他getters，这个设定很是奇怪 Vue模块化机制(单文件组件) 现在已经是vue/cli的第三版了，配置简化了很多，通过vue create xxx创建项目后根据tutorial选择即可，甚至最后的项目文件中webpack等的配置文件也不给了，添加或修改配置需要自己创建文件 启用路由 注意默认的路由模式是hash模式，即只改变url中#后面的值，这样访问的依然是同一个网页，只是内容不同，所以url中间有一个 /#/ 启用history模式，利用的是bom的原生history.pushState()api，可以没有#，具体操作需要在前端router中指定base，然后在后端设置对含有这个路由的请求都返回同样的页面 history模式下的base选项设置好后，router-link标签的to属性就不再需要写基路径了，仅此而已 .router-link-active的active class匹配是包容的，即只要url中有能匹配上的字段都能匹配成功， router-link中使用exact属性表示完全匹配才生效 路由中使用的组件，即router中的routes属性的配置中的componet属性可以是Vue.extend() 创建的组件构造器，或者只是一个组件配置对象 html引入vue-router.js之前一定要先引入vue.js，否则报错 子路由只能在父级路由的router-view中渲染，无法覆盖整个页面 分清$route和$router，前者指的当前路由，可以从$route.params.xxx获取参数，后者指整个路由对象，可以调用go，push等方法使当前路由改变 使用路由参数通过组件的props传参时注意参数名和组件中props属性名要对应 为什么在原来的写法中直接引入vue-router就可以使用，而在单文件组件中需要先使用Vue.use(vueRouter)安装插件才能使用？ vue-router代码内部会检测全局是否存在Vue这个属性，存在则自动调用window.Vue.use()安装，注意是window的属性Vue，否则才需要手动调用(这也解释了原来的写法为什么不能在vue之前先引入vue-router就直接使用)，而在模块中我们是用import引入的(实际上vue-router的源码中并没有es6的export语法，是以module.exports形式导出的，import会被babel转化为es5语法)，所以并没有这个window.Vue这个属性，需要我们手动注册 注意工具都是使用-D命令安装在开发依赖(一般放一些打包工具和编译工具等)中的，安装时注意是否需要安装到生产依赖中 runtime版的vue没有compile函数，runtime版本和dev版本的区别 webpack打包时会将.vue格式文件编译成js文件，这个阶段会将组件中的template标签中的模板编译成render函数，最终渲染都是通过render函数，所以运行文件中是不带编译的，因此组件中不能写字符串形式的template模板，使用字符串或者基于html的template需要编译成render函数才能执行，也即需要客户端编译 总结： 单文件组件只能使用render render函数返回的是一个虚拟dom结点 单文件组件的生命周期 vue生命周期及使用 &amp;&amp; 单文件组件下的生命周期 组件之间通信方式 全局事件总线，在根实例的data属性中创建一个空的vue实例bus，然后在子组件中通过$root.bus.$emit(&#39;eventName&#39;, data)触发事件，在另一个组件中通过$root.bus.$on(&#39;eventName&#39;, cb(data))监听事件 也可以在一个单独的文件中创建一个eventBus // event-bus.js import Vue from &#39;vue&#39; export const EventBus = new Vue() //然后在需要通信的组件中引入 &lt;p class=&quot;code-caption&quot; data-lang=&quot;&quot; data-line_number=&quot;frontend&quot; data-trim_indent=&quot;backend&quot; data-label_position=&quot;outer&quot; data-labels_left=&quot;Code&quot; data-labels_right=&quot;:&quot; data-labels_copy=&quot;Copy Code&quot;&gt;&lt;span class=&quot;code-caption-label&quot;&gt;&lt;/span&gt;&lt;a class=&quot;code-caption-copy&quot;&gt;Copy Code&lt;/a&gt;&lt;/p&gt; 或者在main.js中初始化Vue.prototype.$EventBus = new Vue() 单文件组件中css局部生效的原理是在选择器和对应标签上加上独一对应的data-set属性 在单文件中使用生命周期函数指的是当前组件的根组件，比如子组件重新渲染时update就不会触发，需要到对应的子组件中使用其生命周期函数 Web components https://developer.mozilla.org/zh-CN/docs/Web/Web_Components template元素的内容会解析但不会渲染，使用content属性获取document-fragment，这是一个能储存并列dom结点的容器 坑中之坑webpack webpack动态加载模块 打包原理 vue中的import 两种形式 import a from &#39;xxxx/a&#39; 这种是es6语法，需要在a文件中export导出内容才能使用 import &#39;xxxxx/a&#39; 这种应该是webpack配置的，相当于html的script标签，可以直接引入可执行的js和css文件，但是在单文件组件中使用需要注意变量的作用域(是否挂载在window上) Element UI 用了一下element组件库，记录一些坑 表单 表单验证的两种方式 这里要批评一下element，文档太多东西没写啦，第一次使用看到这里一脸懵逼，表单输入框的验证大致由以下几个部分组成 首先form组件元素中model属性需要传入一个对象:model=&quot;obj&quot;，这个obj包含了几个form-item中对应的字段 如果要使用表单验证，则在form-item组件元素上必须使用prop属性传入一个字符串，这个字符串必须和上一步中的obj的某个属性对应，猜测源码中是通过prop检索需要传入验证函数的参数 然后需要制定验证的rules，先在data中创建一个rules对象，这个对象中包含需要验证的属性，记住属性名也需要和obj中属性对应，然后将这个rules传入form组件元素的rules属性中:rules=rules，一下是rules对象属性中两种规则写法 //1 username: [ { validator: checkUsername, trigger: &#39;blur&#39;} ] //2 email: [ { required: true, message: &quot;邮箱不能为空&quot;, trigger: &#39;blur&#39; }, { type: &#39;email&#39;, message: &quot;请输入正确的邮箱&quot;, trigger: [&#39;blur&#39;, &#39;change&#39;] } ] 区别很显然，先说共同点trigger，可以指定触发什么事件时调用验证 对于第二种，可以使用内置的验证规则，参见async-validator 对于第一种，可以自定义一个验证函数，这个验证函数有三个参数，rule，value，callback，第一个参数我还不知道怎么用，第二个value就是对应的form-item中input的value，第三个参数在做出验证判断时调用，验证失败则传入一个字符串或者error对象，验证成功不需要参数直接调用，示例如下 const checkUsername = (rule, value, callback) =&gt; { if(!value.trim()) { callback(new Error(&quot;用户名不能为空&quot;)) } else if(!checkSpecificKey(value)) { callback(new Error(&#39;用户名不能包含特殊字符&#39;)) } callback(); }; &lt;p class=&quot;code-caption&quot; data-lang=&quot;&quot; data-line_number=&quot;frontend&quot; data-trim_indent=&quot;backend&quot; data-label_position=&quot;outer&quot; data-labels_left=&quot;Code&quot; data-labels_right=&quot;:&quot; data-labels_copy=&quot;Copy Code&quot;&gt;&lt;span class=&quot;code-caption-label&quot;&gt;&lt;/span&gt;&lt;a class=&quot;code-caption-copy&quot;&gt;Copy Code&lt;/a&gt;&lt;/p&gt; 最后说一下提交按钮可以在click事件上绑定一个处理机，调用this.$refs[formName].validate((valid) =&gt; {})，来调用整个表单的验证，并对验证结果做对应处理，回调函数的valid为true/false 表单的提交 官网表单demo中的提交按钮给的是一个普通按钮，因为需要对表单内容做验证，所以点击事件触发时要调用表单组件的validate方法，对回调的结果做对应的操作，所以不能直接提交，如果不需要做验证，我想可以在表单元素中写上action和method，使用submit按钮提交并没有试过 所以我们需要使用ajax来提交，这里我们使用axios，首先需要拿到数据，搜了一圈，比较好的办法是用FormData，FormData的使用，另外请参考这个issue中的回答示例，似乎是只能一条一条append的，然后可以作为axios的参数发送请求，上传文件必须使用FormData，似乎比普通提交的urlencode格式更规范了，后端做好对应的处理即可 零碎知识 package.json html的标签(例如form的action，a的href等)中使用/绝对路径开头的path会替换当前地址栏的url域名后第一个/所有的内容组成新的url并发送对应的请求，使用./相对路径则会加在最后一个/之后 new Promise(f)的回调是构造过程中立即执行的 Koa和express的区别，koa中next返回一个promise，使用await next()时，会等到next调用的下一个中间件执行完成才会执行当前中间件接下来的代码，而express中是直接将当前中间件执行完 es6的class，构造函数中调用super前不能使用this，因为调用super相当于调用了父类的构造函数，创建了一个父类的实例再将this指向了这个实例(参考babel的实现) class B extends A {}中的关系 B.__proto__ === A es5中没有这一点 B.prototype.__proto__ === A.prototype script标签的integrity属性 利用document.createTextNode()将用户的输入转码 function htmlencode(s){ var div = document.createElement(&#39;div&#39;); div.appendChild(document.createTextNode(s)); //这里将字符串创建文本结点并以结点的形式加入 return div.innerHTML; //innerHTML就会将&#39;&lt;&#39;等原本为html代码的字符自动转义成对应实例 //注意不要用div.innerText获取 } function htmldecode(s){ var div = document.createElement(&#39;div&#39;); div.innerHTML = s; return div.innerText || div.textContent; } 简单的函数柯里化 function sum(...args) { const ret = sum.bind(null, ...args) ret.toString = function() { return args.reduce((a, b) =&gt; a + b, 0) } return ret }","tags":[{"name":"front-end","slug":"front-end","permalink":"babopo.github.io/tags/front-end/"},{"name":"vue","slug":"vue","permalink":"babopo.github.io/tags/vue/"}]},{"title":"前端学习week21","date":"2019-09-23T01:04:17.000Z","path":"2019/09/23/前端学习week21/","text":"​ 本周将nodejs的介绍进行了首尾，并学习了express和sqlite的使用，简要了解了websocket的原理来实现实时的数据交互，并用这些工具实现一个带登陆功能的投票系统，详见另一篇记录 NodeJs stream 可读流fs.createReadStream() end事件 pause,resume,pipe方法 可写流fs.createWriteStream() 返回一个布尔值，false表示缓冲区已满 drain事件，当可写流有返回false的情况之后才可能触发，表示缓冲区枯竭 在返回false到触发drain事件的这段时间内读取流不能向缓冲区写入数据，直到写入流将缓冲区的数据使用完 end方法 fs模块创建的可读可流和写流是将的stream模块功能的封装 //创建可读流 new Readable({ read(size) { //被流系统自动异步调用 this.push(buf) //将数据传入缓冲区 } }) //可写流 new Writeable({ write(chunk, encoding, done) { //流系统调用处理缓冲区数据 fs.write(chunk,xxx,xx,xxxx) done() //调用callback表示当前处理完成 } }) //读写流 new Duplex({ read(size) { this.push(xxx } write(chunk, encoding, done){ xxxx done() } }) //转换流 new Transform({ transform(chunk, encoding, callback) { this.push() callback() } }) &lt;p class=&quot;code-caption&quot; data-lang=&quot;&quot; data-line_number=&quot;frontend&quot; data-trim_indent=&quot;backend&quot; data-label_position=&quot;outer&quot; data-labels_left=&quot;Code&quot; data-labels_right=&quot;:&quot; data-labels_copy=&quot;Copy Code&quot;&gt;&lt;span class=&quot;code-caption-label&quot;&gt;&lt;/span&gt;&lt;a class=&quot;code-caption-copy&quot;&gt;Copy Code&lt;/a&gt;&lt;/p&gt; 除了读写流还有双工流Duplex和Transform，既可作为上游产生数据又可作为下游消费数据 net.socket是一个典型的Duplex实例 duplex的可读和可写部分是独立的，而transform的可读流经过一定处理自动进入可写流 重点理解和使用stream.pipe，相当于Unix中的管道符，数据只能从可读流pipe到可写流，多级pipe调用中间的一定是双工流(因为要满足可读流-&gt;可写流) pipe会自动处理枯竭，暂停，恢复等情况 ObjectMode，默认为false，对象模式，默认返回的数据会转为buffer字节流，可设置对象模式为true使保持数据原格式 Buffer 同es6中新增的二进制数组 Buffer是最底层的功能之一，在node中无需require可直接使用 不再用构造函数创建实例，详见文档 buffer类数组，一个元素为两个16进制表示的一个字节 给其中元素赋值，只保留整数舍弃小数部分，当未在0-255之间时会加上k * 256使其落在0-255之间 关于process.nextTick(callback)的理解 Node中的事件循环 The Node.js Event Loop, Timers, and process.nextTick() //例子1 seTimeout(() =&gt; { console.log(1) }, 0) setImmediate(() =&gt; { console.log(2) })//1,2顺序不确定 //例子2 var fs = require(&#39;fs&#39;) fs.readFile(&#39;a.txt&#39;, (err, data) =&gt; { seTimeout(() =&gt; { console.log(1) }, 0) setImmediate(() =&gt; { console.log(2) }) })//先2后1 timers阶段：定时器设定的回调函数 check阶段：setImmediate的回调 setImmediate和setTimeout是执行的时候将回调加入下一个对应的阶段执行 poll阶段：读文件等回调函数的执行阶段，一直pending状态并阻塞后面的流程直到数据到达然后执行回调，若下一个timers阶段有任务执行则会阻塞设定的时间 process.nextTick()的nextTickQueue 回调会在两个阶段之间执行(而不论当前在哪个阶段)，所以在process.nextTick()中递归调process.nextTick()会在进入下一阶段前就执行 node中的promise.then和process.nextTick一样不属于任何一个阶段，再两个阶段之间执行，但promise.then的优先级比process.nextTick低 浏览器的事件循环只分为宏任务和微任务，先宏任务再微任务再循环，宏任务每次只执行队列中的一个，微任务阶段将微任务全部执行，微任务的异步递归也会阻塞宏任务的执行 浏览器中微任务执行早于打印同步代码求值结果，宏任务晚于求值结果打印 Express 没什么好说的，都是封装好的api，记录一些资料 Express.js 4.0 的路由（Router）功能用法教學 关于app.use()比较好的解释 app.use()可以传app.router()创建的对象(例如使用静态文件，解析cookie等)，而app.get()不可以，想想也知道，router能包含各种请求，get只能处理get请求 Express URL跳转（重定向）的实现：res.location()与res.redirect() SQL 衍生表需要给一个别名 使用COUNT时没用GROUP 返回的是表的第一个条数据 IN 相当于 OR 的缩写，后面的括号中可以接逗号分隔的多个值，也可以接SELECT语句选出的数据(但是只能选出一个列，选出多个列报错) SELF JOIN 的原始写法是 FROM 两个自己，但是两个自己都要给别名 DELETE + JOIN 的语法是 DELETE (要删除的项所在的TABLE) FROM XXX DATEDIFF() 计算两个date类型数据的差 CASE用法示例UPDATE salary SET sex = CASE sex WHEN &quot;m&quot; THEN &quot;f&quot; ELSE &quot;m&quot; END; 注意理解聚合函数COUNT,SUM,MIN,MAX,AVG等和GROUP BY一同使用的写法，常用于查询结果相对原表的行列转置 WebSocket 相对于http协议数据交换就断开连接，websocket协议能提供持久的全双工通信 HTTP通信中双方有一方是被动的(即服务端)建立连接数据交换完成后即中断 在这之前一般使用长轮询(long polling)的方式实时从服务器获取数据更新 长轮询即客户端想服务器发送HTTP请求后服务器没有立即响应，而是等到数据更新后再响应，在此之间这个请求一直是pending状态，客户端在接收到这个响应后这个HTTP连接就自动结束了，客户端再重新发送同样的请求。 这样的缺点是数据更新有延迟，且开销过大，传输了很多冗余数据 WebSocket规范 websocket目前不受同源策略限制 websocket是事件驱动的 url对应的未加密连接是ws://，加密连接是wss:// websocket和http是同级的协议，同样是基于tcp实现的，tcp连接建立后，客户端发送一个http的upgrade请求，服务端回复确认后双方才能建立ws连接，发送同样的数据，开销比http协议小很多，可以看这篇文章后半部分websocket连接抓包分析 浏览器中new WebSocket()实例化后马上就会尝试建立连接 node原生并没有websocket相关的实现，可以在node环境中使用基于websocket封装的Socket.io WebSocket 与 Socket.IO 零碎知识 Content-Disposition:atachment; filename=&quot;xxx&quot;响应头触发下载 http无状态(指不记录访问用户的身份，数据交换后就结束连接)，不是持续的连接 使用cookies解决保持登陆问题 HTTP cookies 详解 说说cookie的理解：cookie并不是指整个数据交换的系统，而是指浏览器存储服务器发送过来的一小段数据的一种功能，每次访问服务器都会带上这段数据，以前是通过存储sessionID来达到保持登陆的效果，现在是存储token 彻底理解cookie，session，token 再聊聊cookie，token和session：cookie是什么上面已经说明了，token可以看作是一段只有服务端能验证的信息，而session是保存在服务器，存储了客户端一次会话的信息(通过sessionID+cookie的方式使客户端在一次会话中对该服务的的多次请求不再需要验证)，会话结束会被清除(因为服务器内存有限) session是客户端第一次请求时在服务端创建的，而session的生命周期并不是客户端打开浏览器到关闭的这段时间(因为服务端无法判断客户端是否关闭了浏览器)，而是设置一段有效时间，当客户端在这个时间内再次请求则这个session会被激活(active)，否则被清除 curl命令 pug+stylus+bootstrap写页面 axios 应该就是用promise封装过的Ajax 中文文档 http1.0协议在一次request和一次response之后就结束了。http1.1多了一个keep-alive可以发送多次请求和响应 MutationObserver监控dom节点的变化，微任务","tags":[{"name":"front-end","slug":"front-end","permalink":"babopo.github.io/tags/front-end/"},{"name":"nodejs","slug":"nodejs","permalink":"babopo.github.io/tags/nodejs/"},{"name":"http","slug":"http","permalink":"babopo.github.io/tags/http/"}]},{"title":"基于Express+pug+bootstrap+sqlite实现的投票系统","date":"2019-09-22T11:49:44.000Z","path":"2019/09/22/基于Express-pug-bootstrap-sqlite实现的投票系统/","text":"​ 使用express框架搭建服务器，pug编写html文件模板，暂时使用bootstrap的样式，sqlite作为后端数据库实现的简单投票系统，记录一些日志 pug 标签后面可以链式写多个类名 直接写类名/id不写标签名会自动编译出带该类名/id的div标签 模板尽量不要用./相对路径，直接用绝对路径/，因为其他页面的模板继承的话path不正确 使用multer中间件获取上传的头像文件，sharp将文件resize并保存 multer的创建选项中dest是文件的相对路径不是url的路径 input标签加入required属性防止提交时输入为空 (只有type=”text”有效, type=”file”也有效) bootstrapExpress cookieParser解析signed cookie 中间件回调函数的request只解析了请求头，需要绑定data事件来获取请求体，但是同一个请求如果前面处理过请求体后面就不用再绑定data事件了，例如前面使用过express.json()或者express.urlencoded()中间件 调用res.send函数之后不能再调用send/redirect/cookie相关等再次发送响应的方法(废话，http1.1连接响应一次后就断开了) app.listen监听的端口只能通过http协议连接，通过使用node自带的https模块来实现对https协议的支持 //示例 https.createServer({ key: fs.readFileSync(&quot;/root/.acme.sh/limbotech.top/limbotech.top.key&quot;), cer: fs.readFileSync(&quot;/root/.acme.sh/limbotech.top/limbotech.top.cer&quot;) }, app).listen(443) &lt;p class=&quot;code-caption&quot; data-lang=&quot;&quot; data-line_number=&quot;frontend&quot; data-trim_indent=&quot;backend&quot; data-label_position=&quot;outer&quot; data-labels_left=&quot;Code&quot; data-labels_right=&quot;:&quot; data-labels_copy=&quot;Copy Code&quot;&gt;&lt;span class=&quot;code-caption-label&quot;&gt;&lt;/span&gt;&lt;a class=&quot;code-caption-copy&quot;&gt;Copy Code&lt;/a&gt;&lt;/p&gt; 根据文档，app实例实际上就是一个能作为接收server的request和response的回调函数，因此下面两种写法等价 var http = require(&#39;http&#39;).createServer(app).listen(port, host, cb) ====== app.listen(port, host, cb) sqlite promise版本的sqlite包 数据库的ORM(Object Relational Mapping)框架，就是将数据库中的表映射成当前语言(我们使用的js)中的类，表中的每一条数据看作这个类的实例，使用ORM框架可以使用js操作数据库 Sequelize sqlite的autoincrement关键字不能和not null同时出现，且只能和integer primary key 同时出现 SQLite Autoincrement 自动增加的数其实是个从1开始自增的，存在库中的sqlite_sequence表中，所以可以delete from sqlite_sequence where name = &#39;your_table_name&#39;来重置这个数，当然也可以修改这个数 在控制台做的修改是立即生效的，不需要保存操作，所以修改时也要考虑备份 注意命令中的字符串要带引号 Socket.io socket.io是封装好的基于websocket的node模块(真的牛批)，在express的服务端中使用时只需要 const io = require(&#39;socket.io&#39;)(require(&#39;http&#39;).createServer()) &lt;p class=&quot;code-caption&quot; data-lang=&quot;&quot; data-line_number=&quot;frontend&quot; data-trim_indent=&quot;backend&quot; data-label_position=&quot;outer&quot; data-labels_left=&quot;Code&quot; data-labels_right=&quot;:&quot; data-labels_copy=&quot;Copy Code&quot;&gt;&lt;span class=&quot;code-caption-label&quot;&gt;&lt;/span&gt;&lt;a class=&quot;code-caption-copy&quot;&gt;Copy Code&lt;/a&gt;&lt;/p&gt; 即可接入 在客户端只要在相关页面 &lt;script src=&quot;/socket.io/socket.io.js&quot;&gt;&lt;/script&gt; //引入 ========= //执行 const socket = io() //即可自动接入 服务端与客户端之间的通信是通过一系列自定义事件驱动的","tags":[{"name":"front-end","slug":"front-end","permalink":"babopo.github.io/tags/front-end/"},{"name":"nodejs","slug":"nodejs","permalink":"babopo.github.io/tags/nodejs/"},{"name":"express","slug":"express","permalink":"babopo.github.io/tags/express/"}]},{"title":"前端学习week20","date":"2019-09-15T14:05:45.000Z","path":"2019/09/15/前端学习week20/","text":"本周的重点是promise， 理解异步的概念，js本来就是单线程的，理解也不难，重点是学会用法，注意点是异步程序是什么时候创建的，promise只是简化了使用回调函数的方式，此外理解promise什么时候创建什么时候执行，thend的返回值等问题。后面简单介绍了一些node的模块 Promise 一个promise对象代表一个异步操作的结果 promise对象创建时就执行了，then类似于DOM中的监听 与事件监听的区别： 一次性 即使promise已经成功/失败了，再调用then还是可以执行 promise状态确定后不能再更改，promise对象是一次性的，状态确定后其生命周期就结束了 then方法有两个参数（分别是成功/失败时执行的回调函数，这两个函数就是创建promise对象时的两个回调函数参数），调用then方法根据调用的promise对象的状态执行参数中对应的回调函数，获得一个新的promise对象，其结果由then中执行的情况决定 如果then中throw一个错误(不管在哪个函数中)，则新对象的状态都是rejected，值为throw出的内容， 原对象的状态和值根据其调用的哪个函数及传入的参数决定 注意throw错误的方式，再promise创建时的回调函数中throw错误是无法被接住的，在resolve/reject函数中throw的错误能被之后链式调用的then/catch接住，因为返回了新的rejected状态的promise对象(不管这个error有没有被接住都会创建) JavaScript Promises - reject vs. throw 若then中return了一个promise对象，则新对象的状态和值与这个返回的对象相同 then没有传对应的回调函数参数(null)，则新对象获得原对象的状态和值 链式调用跳转/穿透 注意在回调函数中返回undefined并不能使穿透，因为会返回的值为undefined的新promise对象 then中函数正常执行，则新对象状态为resolved(无论正常执行的函数是哪个)，值为函数返回值 再说一便then可以当做事件监听来理解，promise对象的状态一旦确定就会触发then中对应的回调函数 注意then中回调函数不是返回一个promise对象则都是同步的 如果promise对象(称为B)的resolve传入的参数是另一个promise(称为A)，则B要等到A的状态确定才能从pending状态转为确定， 且B的状态和值与A相同 当B调用resove时，A的rejected和resolved状态都能传递，且值也能传递 只有resolve能传递，reject不能(若A为resolved状态，则B为reject，value为promise) 解释：promise对象到达rejected状态时相当于抛出了一个错误，要用catch接住，不然抛出错误 then是异步调用的，微任务 宏任务setTimeout，setInterval， script脚本(整体代码) 事件循环(Event Loop) 遵循以下步骤 先检查宏任务队列(以script脚本开始)，按加入队列顺序执行 再检查微任务队列 重复以上步骤 注意主线程读取宏任务是一次事件循环读取一个， 读取微任务是一次直到微任务为空 JavaScript Promise：简介 We have a problem with promises Promises/A+ 实现A+标准的promise promise与generator 思路： 当有多步异步操作而我们需要获取每一步的返回结果， 解决方法就是使用迭代器， 因为迭代器可以分步执行和暂停， 只需要在异步执行的位置暂停等待异步程序的执行结果即可， 所以我们用生成器来包装一个函数表示内部有异步操作， 异步操作使用promise对象 async/await 其实就是用async代替生成器的*，await代替yield，返回promise对象，async自带执行器，awiat相当于调用promise对象的then获取异步结果，执行函数就能得到完整结果(返回一个promise对象)，不需要生成迭代器再调用next 除了常用的函数声明和函数表达式，也可用于class中的函数声明和箭头函数 描述一下async函数的执行过程：若函数内有异步操作， 调用函数会立即返回一个挂起状态的promise对象(A)， 函数内部遇到await就立即返回，等待await后的异步操作(若接的不是一个promise对象，则会转为一个立即resolve的promise对象)执行完后再执行下一句， 最后函数的执行情况和返回值作为A的状态和value 只要有一个await后得到了reject的promise对象，则整个函数的执行立即中断，reject状态及value传给整个函数的返回结果(无论是否有return)，除非使用try-catch处理(async函数内可以使用try-catch)或者await后有处理reject的catch调用 若多个异步操作间没有联系，可让异步操作并发执行提高效率 //例 let res = await Promise.all(promises &lt;p class=&quot;code-caption&quot; data-lang=&quot;&quot; data-line_number=&quot;frontend&quot; data-trim_indent=&quot;backend&quot; data-label_position=&quot;outer&quot; data-labels_left=&quot;Code&quot; data-labels_right=&quot;:&quot; data-labels_copy=&quot;Copy Code&quot;&gt;&lt;span class=&quot;code-caption-label&quot;&gt;&lt;/span&gt;&lt;a class=&quot;code-caption-copy&quot;&gt;Copy Code&lt;/a&gt;&lt;/p&gt; Even with async/await, raw promises are still key to writing optimal concurrent javascript coroutine async function f() { console.log(1) var a = await Promise.resolve(5) console.log(a) var a = await Promise.resolve(5) console.log(a) var a = await Promise.resolve(5) console.log(a) } //协程 纤程 coroutine async function g(){ console.log(3) var b = await Promise.resolve(6) console.log(b) var b = await Promise.resolve(6) console.log(b) var b = await Promise.resolve(6) console.log(b) } f() g() console.log(2) NodeJS node版本问题 REPL node环境的全局对象是global process相当于浏览器环境的console process.argv获取脚本的命令行参数， 字符串数组形式 调试 node --inspect-brk=portID fileName params，浏览器调试工具，停在第一行 vscode调试 ndb工具 require()模块加载检索顺序 http模块 和net模块的区别： net模块是工作在传输层，而http模块是应用层的，http模块将net模块的连接抽象成了请求和响应(自带很多方法和属性，简便很多)，http模块应该是以net模块为基础实现的 请求和响应上要绑定data事件才能获取对应具体内容 连接中传入回调函数的request已经解析好了请求头， 所以可以绑定data事件，传入的data就是请求体 零碎知识 Generator中的Thunk函数 页面加载时浏览器会默认向服务器发送获取favicon.ico的get请求，只影响页面title的图标，无法过滤","tags":[{"name":"front-end","slug":"front-end","permalink":"babopo.github.io/tags/front-end/"},{"name":"javascript","slug":"javascript","permalink":"babopo.github.io/tags/javascript/"}]},{"title":"如何不用call和apply实现一个bind","date":"2019-09-15T12:22:54.000Z","path":"2019/09/15/如何不用call和apply实现一个bind/","text":"前些天看到一道面试题，如和实现一个bind，当然是不能使用call和apply，这应该是有些念头的面试题了，因为不论是call和apply还是bind都是es5就有的特性了， 但是我觉得搞明白还是对理解js中this指向，函数参数调用，闭包等的理解还是很有帮助的。 bind的原理题目既然说不能用call和apply，那我们先来看看用call和apply如何实现bind，因为call和apply的区别仅在于传递参数的形式的不同，第一个参数都是函数this的新指向，apply的第二个参数为一个数组，包含将调用原函数所传递的参数， 而call为第二个及之后的参数，为简化起见，以下都只实现apply版本。 //bind的简单实现 Function.prototype.myBind = function (obj, ...args) { const self = this //记录调用bind的函数 const params = [...args] //记录通过bind函数提前传入的参数 return funciton(...args) { // 这里是一个闭包，因为bind返回的是一个函数，这个函数绑定了我们传入的参数和新的this指向 params = params.concat([...args]) // 再加上新函数调用时传入的参数 self.apply(obj, params) //通过apply调用，因为js传入超过形参数量的实参会被忽略，我们就不处理了 } } Copy Code ``` 可见， 实现bind函数的关键就是最后如何调用，再回到原问题，就变成了如何实现一个apply/call 实现apply原理刚看到这个题目时稍微想了一下，没什么思路，翻了一下权威指南，发现居然对apply/call给了解释，并且思路非常直白粗暴 //权威指南中的解释 f.apply(obj, arr) //相当于 obj.f = f f(...arr) delete obj.f 实现 根据思路我们先来实现一个初版 Function.prototype.myApply = function(obj, arr = []) { //arr要默认传一个[]，否则下面的扩展运算符会报错 const f = this //this指向调用apply的函数 obj.f = f obj.f(...arr) delete obj.f } &lt;p class=&quot;code-caption&quot; data-lang=&quot;&quot; data-line_number=&quot;frontend&quot; data-trim_indent=&quot;backend&quot; data-label_position=&quot;outer&quot; data-labels_left=&quot;Code&quot; data-labels_right=&quot;:&quot; data-labels_copy=&quot;Copy Code&quot;&gt;&lt;span class=&quot;code-caption-label&quot;&gt;&lt;/span&gt;&lt;a class=&quot;code-caption-copy&quot;&gt;Copy Code&lt;/a&gt;&lt;/p&gt; 在控制台中确实可以执行，简单的例子也能得到预见的结果， 但并没有完， 显而易见有很多问题 第二版 第一版的问题在于重新指向的obj中可能有f属性，这样就覆盖了，且最后删除了这个属性，因此想到es6新增的Symbol类型 //用Symbol类型的值作为过渡的属性 Function.prototype.myApply = function(obj, arr = []) { const temp = Symbol(&#39;temp&#39;) //Symbol不需要用new const f = this //this指向调用apply的函数 obj[temp] = f //Symbol只能用中括号的形式查找 obj[temp](...arr) delete obj[temp] } 第三版 在非严格模式下，当apply传入的第一个参数是null时，调用函数的this应该指向全局对象window //判断传入的obj Function.prototype.myApply = function(obj, arr = []) { const temp = Symbol(&#39;temp&#39;) const f = this obj = obj || window //当第一个参数是null/undefined时，使this指向window obj[temp] = f obj[temp](...arr) delete obj[temp] } &lt;p class=&quot;code-caption&quot; data-lang=&quot;&quot; data-line_number=&quot;frontend&quot; data-trim_indent=&quot;backend&quot; data-label_position=&quot;outer&quot; data-labels_left=&quot;Code&quot; data-labels_right=&quot;:&quot; data-labels_copy=&quot;Copy Code&quot;&gt;&lt;span class=&quot;code-caption-label&quot;&gt;&lt;/span&gt;&lt;a class=&quot;code-caption-copy&quot;&gt;Copy Code&lt;/a&gt;&lt;/p&gt; 完美 后续改进 正常人可能看出来了， 既然我们实现的是es5特性在es3的pollyfill，但我们为什么用了这么多es6的特性，包括Symbol以及扩展运算符 解决办法：扩展运算符可以用函数的arguments属性替代，Symbol值可以用变长的随机数代替，生成的时候检查对象中是否已有同名属性，有的话再生成即可，这里就不继续实现了。 完整代码最后做个总结：写下来发现并不难，几处要注意的就是bind实现时的闭包以及apply的实现方式 完整代码如下： //bind Function.prototype.myBind = function (obj, ...args) { const self = this const params = [...args] return funciton(...args) { params = params.concat([...args]) self.myApply(obj, params) } } //apply Function.prototype.myApply = function(obj, arr = []) { const temp = Symbol(&#39;temp&#39;) const f = this obj = obj || window obj[temp] = f obj[temp](...arr) delete obj[temp] }","tags":[{"name":"javascript","slug":"javascript","permalink":"babopo.github.io/tags/javascript/"}]},{"title":"前端学习week19","date":"2019-09-08T14:55:27.000Z","path":"2019/09/08/前端学习week19/","text":"​ 本周的重点是ajax，http协议及模块的概念，前两个是硬的知识点没什么好说的。 模块应该是前端的一个比较重要也是一个难点了，主要搞清楚CommonJS, AMD, CMD规范的区别，以后的webpack，es6 module应该还会再涉及到 Ajax 关于什么是ajax，就是可以通过XMLHttpRequest这个api，经由用户的交互等， 部分请求服务器的资源，而无需重新载入页面 基本流程就是new一个对象后，先后调用open和send方法向设定的url发送http请求，然后在response属性中获取服务器返回的响应 注意的点基本就是调用send时才会发送请求， open方法的第三个参数默认为true， 异步加载；设为false时为同步加载， 同步加载时页面会挂起不可交互，一般不使用 Module 关于模块的动态静态加载的理解，什么是静态分析 CommonJS/AMD的模块加载是动态的(require)：即运行时才加载，无法静态分析，因为可以用任意表达式表示模块名称，路径，属性名等 es6的模块是静态加载的，即编译时就加载完成，并不能用各种表达式来表示其模块名称等，便于静态分析(tree-shaking，去除不需要的代码)，这是在语法层面的限制 script标签引入es6模块要加属性type=&quot;module&quot; HTTP 文本协议(文本格式)，请求/响应模型(双向通信)，基于tcp 状态码 301 重定向，根据location字段跳转 服务器也可先返回200， 再通过js代码根据user-agent跳转 302 跳转对ajax是透明的，xhr获得的响应是跳转后的响应 304 协商缓存 响应条件请求头 cache-control age expires last-modified等 401 403 404 501 服务器必须支持GET和HEAD方法 502 安全相关首部 content-security-policy CORS 跨域的概念：只要请求资源的协议，域名，端口有一个不同就叫做跨域 access-control-allow-origin access-control-allow-methods access-control-allow-headers access-control-max-age CSRF 浏览器虽然有同源策略，但是浏览器请求实际是已经发送出去的 非简单请求会先发送OPTION预检请求HTTP访问控制（CORS） 有些请求有预检请求，有些没有：不能破坏web的兼容性 通过html的标签(img, video, script)的src属性引入的外域资源是不受限制的 原理可能是因为早期设计的时候没有考虑周全，并且这样是拿不到源码的，script标签通过src引入的内容是自动执行的 jsonp就是利用了script标签不受同源策略限制 &lt;p&gt;//使用示例&lt;/p&gt; &lt;script&gt; //在本地的脚本中声明了一个回调函数，回调函数名字可以自定义，但与url中要对应 function getPrice(data) { console.log(data) } &lt;/script&gt; &lt;p&gt;//向服务器请求了一个包括回调函数等信息的url的get请求，服务求收到请求时就返回对应响应的json内容，然后在本地调用这个回调函数 //为什么会在本地自动调用这个回调函数? //解释：需要服务器的配合，服务端在将请求的json数据返回给客户端时会用客户端定义的回调函数名包裹json数据(想想模块的原理)，因为我们已经声明过这个函数，所以可以直接调用&lt;/p&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;http://wsdetail.b2b.hc360.com/getSupplyPrice?callback=getPrice&amp;bcid=47296567&quot;&gt;&lt;/script&gt; &lt;p class=&quot;code-caption&quot; data-lang=&quot;&quot; data-line_number=&quot;frontend&quot; data-trim_indent=&quot;backend&quot; data-label_position=&quot;outer&quot; data-labels_left=&quot;Code&quot; data-labels_right=&quot;:&quot; data-labels_copy=&quot;Copy Code&quot;&gt;&lt;span class=&quot;code-caption-label&quot;&gt;&lt;/span&gt;&lt;a class=&quot;code-caption-copy&quot;&gt;Copy Code&lt;/a&gt;&lt;/p&gt; - 由此可知jsonp只能用于get请求的跨域，被CORS的方式完爆，只是能支持老式浏览器 - [说说JSON和JSONP](https://www.cnblogs.com/dowinning/archive/2012/04/19/json-jsonp-jquery.html) &lt;p class=&quot;code-caption&quot; data-lang=&quot;&quot; data-line_number=&quot;frontend&quot; data-trim_indent=&quot;backend&quot; data-label_position=&quot;outer&quot; data-labels_left=&quot;Code&quot; data-labels_right=&quot;:&quot; data-labels_copy=&quot;Copy Code&quot;&gt;&lt;span class=&quot;code-caption-label&quot;&gt;&lt;/span&gt;&lt;a class=&quot;code-caption-copy&quot;&gt;Copy Code&lt;/a&gt;&lt;/p&gt; http报文的时间单位一般是秒 远程过程调用(Remote Procedure Call) 基本思想是将服务端作为运算的主体，客户端向服务端发送参数等信息，服务端返回调用结果等信息 JSON-RPC 和JSON以及JSONP的区别和联系 总结：JSON是一种数据格式，自不必多说； JSON-RPC是一种无状态的远程程序调用协议，通过特殊的JSON格式，包含几个特定的属性，例如method，id，params等，与具体实现有关，服务端根据客户端发来的JSON中的具体内容(参数，函数名等)来调用对应的函数，将函数的返回结果序列化成特定的JSON格式再传回；而JSONP是一种非正式的跨域方式，形式就是JSON格式的数据包裹一个回调函数 restful 零碎知识 node环境下的tcp套接字编程 服务端 let net = require(&#39;net&#39;) let server = net.createServer() server.listen(port) //第二个参数接host，不传则默认为localhost server.on(&#39;connection&#39;, con =&gt; { conn.on(&#39;data&#39;, data =&gt; { xxx }) }) //另一种写法，只是形式不同，其他完全一样 net.createServer(socket =&gt; { socket.on(&#39;data&#39;, data =&gt; { xxxx }) }).listen(port, host) //监听到连接请求时才会创建一个新的socket对象，触发createServer()中的函数 客户端 let net = require(&#39;net&#39;) let client = new net.Socket() //在给定的socket上初始化一个tcp连接 client.connect(port, host, function() { client.write(xxx) }) data事件的触发机制 同一个连接里多次write可能合并成一次触发也可能触发多次，应该是看网络环境 在data事件中调用end方法来结束连接只是单方面结束了连接，整个连接会等待对方数据发送完才结束(想想四次挥手的概念) 习惯每次data事件处理完后都调用conn.end()来结束连接，我的理解 只是为了结束这个TCP连接而已 当连接localhost及本机的端口时，可以从服务端socket的remoteAddress看到客户端的ip也为127.0.0.1 注意remoteAddress/remotePort(远程客户端的地址和端口)和localAddress/localPort(本地服务端的地址和端口)都只能在服务端的socket上获取 node中tcp的socket概念：我的理解： 通过观察，客户端通过new net.Socket()创建的是一个socket类对象，确实是一个socket， 而服务端通过net.createServer()返回的是一个server类，这个server并不是socket，而server监听connection事件触发时得到的连接(即传给处理机的参数)是一个socket类，即在server端每次监听到client的连接请求时才创建一个socket，实际上是这个新创建的socket和客户端创建的socket建立了连接 server将事件处理全部写在net.createServer中的形式似乎更好理解 再谈socket的理解：socket可以看作是封装好的传输层接口，提供了多个函数和属性用于建立通信，在一台主机上的一个端口只能bind一个socket，也即一个端口同时只能被一个进程占用，而一个socket可以与多个socket建立连接，而一个端口也能并发处理多个请求 Socket编程之一个端口能建立多个TCP连接？","tags":[{"name":"front-end","slug":"front-end","permalink":"babopo.github.io/tags/front-end/"},{"name":"network","slug":"network","permalink":"babopo.github.io/tags/network/"}]},{"title":"前端学习week18","date":"2019-09-01T14:44:51.000Z","path":"2019/09/01/前端学习week18/","text":"​ 本周算是科普了一些网络知识，我觉得只要能说出在浏览器地址栏输入一个URL后发生了什么，基本概念就差不多清楚了。理清物理层，数据链路层，网络层，传输层的各层主要功能及主要的协议是什么和其功能，各协议包头的主要信息，另外重点是tcp连接的模型，其他零碎些的知识如广域网和局域网ip的区别，内网和外网，端口的概念等， 下周重点学习http报文的内容。 计算机网络 不要混淆端口和socket的概念，socket是抽象出来的tcp/udp等连接协议的实现，可以看作是端对端通信的”端“，以ip地址+端口号的五元组作为标识信息，服务端和客户端的连接就是socket之间的连接 socket和端口不是一个层面的概念，一个端口只能供一个进程使用，socket可以多个连接，如果服务端的socket连接了多个客户端，那么该端口会顺序处理客户端发送的数据 零碎知识 构造函数如果有return语句，且return的是对象(数组等)，用new创造实例时会返回指定的对象，若return的是基本数据类型，则会忽略return语句 在说一下this的问题 在函数体外部的this，无论在哪，都是指向当前运行环境的全局对象 在函数体内部的则根据函数的调用方式判断","tags":[{"name":"front-end","slug":"front-end","permalink":"babopo.github.io/tags/front-end/"},{"name":"network","slug":"network","permalink":"babopo.github.io/tags/network/"}]},{"title":"前端学习week17","date":"2019-08-25T14:52:05.000Z","path":"2019/08/25/前端学习week17/","text":"本周主要学习了BOM和表单的内容，BOM是浏览器中和dom及原生js无关的api，主要是一些浏览器和网页的信息，表单是一些文件相关的内容，另外需要熟记节流和防抖的区别以及实现。 防抖和节流 主要使用场景为函数高频调用时，例如监听mousemove事件等 防抖debounce 主要思想是将频繁调用的函数用定时器延后执行，实际只执行一次 两种思路 第一次调用加入异步队列后忽略之后的调用 记录定时器加入异步队列的id，每次调用都取消上一次定时，重新定时 节流throttle 使连续的函数执行，变为间隔一段时间执行 也是两种思路 记录上一次执行的时间戳，若时间间隔大于设定间隔，则立即执行并记录当前时间戳 设定定时器来调用，并记录是否设定了定时器，若定时器还存在则忽略调用，定时器调用时将状态改为未设置定时器 BOM browser object model 指的是浏览器中除js内置和dom操作相关的api window open方法，接受一个url字符串，打开新窗口，还接受其他三个参数，仅作了解 返回一个对象指向新窗口的，其中有一个opener属性指向原窗口，可以用这个返回的对象(这个对象并不是指向对应的window，只有几个简单的属性和方法)的postMessage方法传递一个字符串给打开的窗口，在新窗口中也可以通过opener.postMessage()向原窗口传递字符串(将message事件绑定处理机来接收)，来实现跨域通信 getComputedStyle方法，接收两个参数，第一参数为元素节点，第二个参数为伪元素字符串，不需要获取伪元素可以填null，返回一个CSSStyleDeclaration对象，这个对象的属性是只读且动态更新的，包含当前元素的所有计算样式，应为伪元素不是dom节点，不能直接通过dom操作获取，所以多用此方法获取伪元素的样式 location 既是window的属性也是document的属性 location将完整的url分解成不同的片段存放在不同的属性中(完整的url也保存) assign方法，打开一个新窗口，并加入历史记录，将location的href属性赋值相当于调用assign方法 每次修改location的属性页面都会重新加载 此外还有replace方法和reload方法，replace方法不会生成历史记录；reload参数为true时一定从服务器重新获取，否则可能从缓存中加载 url中的hash值指的是#号及后面的部分，hashchange事件就是监测hash值的变化，必须绑定至window对象 history对象 重点理解pushState方法，三个参数，一个state对象，一个标题(现在失效了)， 可选url popstate事件触发时事件中会包含history中的state对象(history中储存的也是当前页面的state)，可利用其记录一些信息 url一定与当前域名相同或者省略域名，否则会报错，新的url指向的目标可以不存在，因为并不会跳转，只是添加了一条历史记录，因为并不会刷新页面，所以设置了新的hash值(锚点)也不会触发hashchange事件，省略则继续用当前url state属性返回当前页面的state对象 在历史记录中跳转才会触发popstate事件，注意 使用pushState方法等并不会触发这个事件 navigator对象 主要是userAgent属性 表单 textarea用标签间的文本作为初始值 文本框的change事件只会在输入框失焦才触发，可用键盘事件或input事件替代 用js改变内容不会触发 FileReader 是一个构造函数 先来了解一下file api 表单中&lt;input type=&quot;file&quot;&gt;获取文件后，节点的files属性(FIleList对象)会包含读取的文件的集合类数组，集合内每个元素为一个file对象(构造函数是File，File的原型是blob)(可以认为是一个blob)，包含读取的文件的一些只读属性 创建的对象实例可以读取文件的数据 实例上的常用读取方法： readAsText()参数为(file或Blob,encoding)，encoding指定编码类型，默认为UTF-8 readAsDataURL(file或Blob) readAsBinaryString(file或Blob) 读取的结果都保存在实例的result属性中 文件读取完成时触发实例上的load事件 URL.createObjectURL(File/Blob) 创建一个blob url， 生命周期和创建它的窗口的document绑定，返回的url字符串指向指定的file/blob对象，可以在其他地方或窗口使用 localStorage window下的属性，同一个域名保存在本地同一个地方(同域的窗口才能获取)，关闭窗口不会清空，sessionStorage类似，但关闭窗口会清空 不同浏览器当然存的不是一个地方，不能通用 以键值对的形式存储，都是文本格式 setItem()方法，两个参数，第一个为键，第二个为值，都为字符串形式(否则会自动转为字符串)，若想传入对象则一般转为JSON格式，取出时再转回 getItem()一个参数，键名 storage事件 只发生在window，只有localStorage(sessionStorage不会)会触发此事件 注意只有当存储的数据实际修改时才会触发，存储一个一摸一样的键值对不会触发，而且不会在导致数据改变的当前页面触发 如果同时打开多个当前域名的窗口，如果某个页面修改了localStorage的数据，则其他页面的storage事件都会触发，而修改的页面不会触发，利用此特性可实现多窗口通信 其他事件 resize 窗口大小变化，页面缩放也会触发 零碎知识 伪元素本身并不是DOM元素，所以无法被js直接操作，也无法通过dom操作获取 利用javascript获取并修改伪元素的值 鼠标按住左键不放移到窗口外仍能触发mousemove（拖动操作） parseInt()第一个参数是字符串，不是字符串也会转成字符串再解析，当字符串的第一个字符转成数字为NaN(或空字符串)时返回NaN，按顺序解析，当遇到第一个字符不能正确转为整数时则自动忽略此字符及之后的字符 不要用parseInt替代Math.floor 大多数时候直接向innHTML中添加script标签脚本不会执行，但创建节点后加入DOM中会执行 创建和触发event 预编译，解决函数中各变量的值到底是什么的问题，按照以下步骤 实际上预编译会先生成一个AO对象(activition object)，因为声明提升的存在，先找到所有声明和隐式声明(未申明直接赋值的隐式声明全局变量)的变量作为属性，值都设置为undefined 将函数执行时传入的实参传给同名形参，使实参和形参统一 找到函数声明，将函数体赋给对应的变量(注意代码中的赋值操作是在书写的位置执行的，例如var a = 1) 正式执行时以AO为基础顺序执行代码 a标签href属性使用javascript:xxx(Bookmarklet)不会匹配visited typeof 未申明变量返回undefined 记住对象默认转字符串调用对象原型上的方法 结果为[object Object] obj.hasOwnProperty()的参数是字符串或者Symbol 对象解构： 形如({a, b, c = 1} = {a: 1, b: 2})，将右侧同名属性的值赋给左边 右边对象不存在这个属性名则赋值为undefined(或者这个属性的值就是undefined)，在左边的属性名后写等号赋值可作为默认值作为解决办法(右边属性值是null的时候无效) 表达式必须用()包裹，因为{}是语句块 表达式的返回值为右边的对象，且当等号右边是null/undefined时会报错(因为不能读取null/undefined的属性) 形如({type: a} = {a: 1})的语法type: a的意思是读取属性名为type的值a，并将右边对应的值赋给a 可以利用这个语法赋值给不同名的变量，例如({type: a} = {type: 1}) 嵌套使用，检索对象里的属性并赋值","tags":[{"name":"front-end","slug":"front-end","permalink":"babopo.github.io/tags/front-end/"},{"name":"javascript","slug":"javascript","permalink":"babopo.github.io/tags/javascript/"}]},{"title":"前端学习week16","date":"2019-08-18T13:07:12.000Z","path":"2019/08/18/前端学习week16/","text":"​ 本周学习了DOM和事件的操作，内容还是比较多的，DOM的各种属性非常多不可能全部记住，用的时候再查，重点是理解DOM的每一个文本/元素/注释等都是一个节点对象，全局下的document属性指向整个DOM树，同时也是其根节点，令外熟记一些常用的操作。事件方面主要是捕获和冒泡模型，另外定时器也是一个很好用的工具。leetcode方面没有在刷了，只做了周赛，感觉算法能力训练目前是到头了，就是这么菜了 DOM 根结点document.documentElement HTML文档中根节点是document对象即文档节点，html节点是一个元素节点且父节点是document，document的父节点为null 节点对象的nodeTyoe属性，用数字表示节点类型 文本节点是文档中的一段纯文本，是一个对象，不是字符串 DOM 会为标签之间的空白创建文本节点–空白匿名文本 nodeName和tagName返回的都是大写的标签名 nodeValue属性返回文本节点内容的字符串，特性节点的属性值，注释节点的注释内容，其他种类的节点一般返回null getElementxxx方法只搜索当前节点的内容，不包括当前节点本身 可以用于document对象，也可以用于element元素对象，用于调用该方法的元素的后代元素 getElementsByTagName这样的方法返回的节点列表(NodeList)是动态变化的，内容会随着DOM的修改而变化 若采用正序(for-loop/for-of)遍历的方法删除节点，会发生隔一个删除一个的情况 可以考虑用数组的slice方法使其返回值稳定不变，注意DOM方法得到的都是类数组，不能直接使用数组方法 逆序遍历 getElementById(“idName”) 若html文档中存在id属性，文档在渲染时会隐式在全局对象下自动创建一个以id属性名为属性名的全局变量指向这个id属性所处的节点(有点绕，即可以直接用id的属性名做作为节点对象的变量进行操作)(特殊情况：window中已存在该名称的属性和该属性值用作变量名不符合命名规范则无效) 标签初始化后property和attribute可能会解绑 在DOM中attribute特指标签的属性，property指的节点对象的属性 获取元素节点内容 innerText得到的字符串格式受css影响，textContent不受css影响，此外内容是相同的 innerText和outerText的返回值是一样的，都是该节点及其后代渲染的文本内容 innerHTML 返回标签内的所有内容字符串，可覆写任意内容 outerHTML 返回包括该标签及其内部所有内容的字符串， 赋值操作是用等号右边字符串解析出来的元素替换本来的元素 注意文本节点没有上面这四个属性，但是有textContent和nodeValue属性来获取内容 removeChild方法只能删除节点的直接子节点 特性节点 特性节点的父节点是null 特性节点是否存在子节点在不同浏览器中不同，所以不考虑 特性是节点对象，但不存在DOM树中 node.attributes得到的NamedNodeMap和NodeList一样都是动态变化的 在元素节点上操作属性大部分时候比在特性节点上方便，所以特性节点不常用 可以直接读取修改元素节点style属性下的各种样式属性，但注意读取和修改的都是内联样式 data-xxx形式的属性可以用element.dataset.xxx获取 selector选择器 querySelector()方法，参数是css选择器(可以用伪类，但是不能选择伪元素)，返回匹配的第一个结点，没有匹配返回null querySelectorAll()，返回类数组NodeList，没有匹配返回空的类数组 也是可以用于document对象，也可以用于element元素对象，但是在元素上调用时，选择器中可以包含该元素或其父元素，例如参数为”div div”时，第一个div可能为调用该方法的元素，只要匹配到的元素是其子元素即可(全局匹配) 和getElementxxx不同的是返回的虽然也是NodeList但不是动态对象 元素节点的matches方法， 参数为css选择器的字符串(和querySelector相同)，返回布尔值，也是全局匹配的 布局 offset偏移相关的属性 offsetParent 是元素的块级父元素 元素自身有fixed定位，offsetParent的结果为null 元素自身无fixed定位，且父级元素都未经过定位，offsetParent的结果为body 元素自身无fixed定位，且父级元素存在经过定位的元素，offsetParent的结果为离自身元素最近的经过定位的父级元素 body元素的parentNode是null 宽高是以border-box为基准，left和top分别是左外边框和上外边框到offsetParent的内边框偏移 所有偏移量都是只读的 每次访问都需要重新计算(不论布局是否发生变化) 返回值是css像素 客户区Client 宽度和高度是以元素的padding-box基准 Top和Left是上边框和左边框的宽度 同样都是只读属性，也会重新计算 getBoundingClientRect()返回一个对象，包含的上下左右位置是相对于视口的左上角 滚动大小scroll scrollHeight及scrollWidth返回元素的总高度和总宽度(包括溢出区域)，而客户区的属性返回的是页面可视区域的大小，不可覆写 Top/Left属性返回隐藏在上方/左方的像素高度，即滚动条位置，这两个属性是可写的，但是赋值为负时会静默失败 以上符合scrollHeight == scrollTop + clientHeight scrollTop赋值为0时可以回到顶部 window上有两个全局属性可获取页面的滚动像素值 pageXOffset 水平方向 pageYOffset 垂直方向 window.requestAnimationFrame() 参数为一个回调函数的函数名，使下一次浏览器重绘时调用这个回调函数，时间间隔一般是16ms(刷新频率60帧) 回调函数会被传入DOMHighResTimeStamp参数，DOMHighResTimeStamp指示当前被 requestAnimationFrame() 排序的回调函数被触发的时间 ，这个参数是一个双精度浮点数 这个函数的返回值是一个请求ID，表示当前执行的回调函数在回调列表中的位置，将这个值穿给window.cancelAnimationFrame()可以取消这次回调 简单理解就是这个函数的功能是将参数里的函数加入到一个回调队列，延后执行 tips：注意在调用前检测和重置其他限制条件，注意逻辑 事件 window.addEventListener() 每个dom节点都有这个方法，可以绑定多个函数，前两个参数为事件类型和处理函数，第三个参数为true时为捕获绑定(默认为false) 参数函数是事件触发时通过绑定的对象调用的，所以参数函数的this指向这个对象(箭头函数指向window) removeEventListener()移除绑定时第二个参数一定是指向要解绑的处理函数 节点的onclick属性功能相似，但只能绑定一个处理机 在html标签中的&lt;p onclick=&quot;foo()&quot;&gt;相当于 $0.onclick = function(){ with(document){ with(p){ foo() } } }` &lt;p class=&quot;code-caption&quot; data-lang=&quot;&quot; data-line_number=&quot;frontend&quot; data-trim_indent=&quot;backend&quot; data-label_position=&quot;outer&quot; data-labels_left=&quot;Code&quot; data-labels_right=&quot;:&quot; data-labels_copy=&quot;Copy Code&quot;&gt;&lt;span class=&quot;code-caption-label&quot;&gt;&lt;/span&gt;&lt;a class=&quot;code-caption-copy&quot;&gt;Copy Code&lt;/a&gt;&lt;/p&gt; 传给处理机的参数是一个事件对象，事件处理时window的event属性也会指向这个对象 捕获和冒泡 目标元素触发事件时，其外层元素也触发了该事件 捕获从外向内，冒泡从内向外，先执行捕获阶段再执行冒泡 所以触发一个元素的某事件且外层元素也绑定了该事件时，先从最外层执行捕获处理该事件至目标元素，再从目标元素向外层冒泡执行处理该事件 注意是同一个事件对象 目标元素不区分捕获和冒泡的顺序，先绑定先执行 stopPropagation()阻止事件向下一个元素传播，当前元素当前阶段的所有处理机都会执行 stopImmediatePropagation()当前元素剩下的函数也不执行 event对象的target属性，指向事件触发的节点，currentTarget属性指向当前事件传播到的位置 event.preventDefalut()阻止默认的事件 scroll，关闭窗口等不能阻止 beforeunload 事件， 关闭窗口前弹窗 contextmenu事件，右键菜单 键盘事件 event.keyCode属性，默认按下是大写 只有能获取焦点(有tabindex属性)的元素才能触发键盘事件 tabindex不是css属性，是一个dom属性 鼠标事件 eventd的which属性： 0无 1左键 2中键 3右键 不能显示组合，只能显示最先按下的键 buttons属性可以表示哪些键被按下，返回的是十进制的值，但是用三位二进制从高到低分别表示中右左三个键是否按下(例如返回5表示中键和左键同时按下)，可以分别和(0b001 0b010 0b100)按位与来判断对应的键是否按下 button属性，0左1中2右 mouseenter/leave替代以前的mouseover/out ，同时enter和leave都不会传播 滚动事件 addEventListener()的第三个可选参数可以为一个对象，内部属性有capture/once/passive passive: Boolean，设置为true时，表示 listener 永远不会调用 preventDefault()。如果 listener 仍然调用了这个函数，客户端将会忽略它并抛出一个控制台警告。浏览器可以在事件触发时就立即开始执行默认事件，不用执行完listener才发现没有preventDefault 焦点事件 触发焦点focus，失去焦点blur，这两个事件不会传播 用focusin，focusout替代，这两个事件会传播 让非表单元素获取焦点：先将tabIndex属性设置为-1，再调用focus()方法 表单元素有autofocus属性， 设置后页面加载完成自动聚焦， 非表单元素即使设置了tabindex也无效 加载事件 window.onload是在页面中所有原有资源加载完成的时候触发的（包括引用的图片，css等） 外部资源加载完成也会触发各自的load事件，load事件不会传播 注意如果页面从浏览器缓存加载，并不会触发load事件 浏览器在解析文件时是遇到就解析的，所以写在头部的js代码可能要放在onload事件中 script的标签是遇到就执行的，执行完毕才执行之后的代码，原因是代码中可能修改了dom，浏览器为保持一致性 script标签的async/defer属性，使当前script不立即执行，在全部加载完才执行 彻底搞懂 async &amp; defer DOMContentLoaded事件还在load事件之前，完成DOM树即触发，不管外部资源 会冒泡到window，但目标是document readystatechange事件 这个属性主要是有几个不同的状态document.readyState，但是行为和触发时间很难预测，应该不常用 页面关闭/跳转 触发beforeunload事件，默认弹出提示窗口是否关闭网页，这个事件不能用preventDefault阻止，且只有处理机在event.returnValue上赋值为真时生效，此外没有其他作用和修改方式 定时器 setTimeout，两个参数，第一个为待执行函数，第二个为延迟时间ms，返回值为设置的该定时器id(非常类似requestAnimationFrame) 浏览器页面处理是单线程的，当设定的时间再执行其他程序，则待执行程序延后至当前程序执行完毕 ，即一定要同步队列执行完毕后才会执行异步队列，且setTimeout延迟时间是其加入异步队列时就(才)开始计算的，因此当之后的同步程序执行时间超过设置的延迟时间，则同步程序执行完后会立即按照加入队列的顺序执行异步。 当延迟时间设为0时，也要等待当前函数调用栈(最外层)的程序全部执行完毕才执行定时器设置的函数 clearTimeout setTimeout的函数参数和普通函数中的回调函数参数是一样的，this指向window(当前活动对象) setInterval，以时间间隔重复执行，也返回一个id clearInterval 当使用setInterval()时，仅当没有该定时器的任何其他代码实例时，才将定时器代码添加到队列中，因为再次添加队列时之前的代码可能还没执行完成 setTimeout和setInterval加入的是同一个异步队列，所以用clearTimeout或者clearInterval都可以互相清除定时器 setTimeout(`console.log(1)`, 1) setTimeout(`console.log(2)`, 0) //以上代码在chrome输出顺序是1， 2 //因为chrome解析时会把0当做1 注意：HTML5标准规定，setTimeout在链式调用(嵌套)5层以上时最短时间间隔是4毫秒；setInterval的最短间隔时间就是4毫秒，也就是说，设置小于4毫秒的时间间隔会被调整到4毫秒 为了节电，对于那些不处于当前窗口的页面，浏览器会将时间间隔扩大到1000毫秒 最平滑的动画效果时间间隔是16.6毫秒(和显示屏刷新频率有关) 官方文档 零碎知识 浏览器会等待js代码执行完成之后再重新渲染 调试时代码是分段执行的 一句解决所有this的问题：在javascript引擎内部，obj和obj.foo储存在两个内存地址，简称为M1和M2。只有obj.foo()这样调用时，是从M1调用M2，因此this指向obj。由此可得，当不经过obj直接调用foo时，foo的this指向当前活动对象（一般是全局环境window） 数组的forEach/map/filter方法可以传入一个参数作为调用函数的this，不传则this为window 对于箭头函数，this 关键字是由词法作用域决定的，继承外层函数的this，指向的是它当前周围作用域（简单来说是包含箭头函数的常规函数，如果没有常规函数的话就是全局对象），和闭包比较，闭包返回的函数的this是暴露在外面的，如果闭包返回的是一个箭头函数，那么this继承的是包裹函数的this，否则箭头函数的this就是window 进程和线程： 不同进程之间不能共享内存 同一个进程的多个线程可以共享这个进程的内存 cpu的时间片轮转是以线程为基本单位","tags":[{"name":"front-end","slug":"front-end","permalink":"babopo.github.io/tags/front-end/"},{"name":"javascript","slug":"javascript","permalink":"babopo.github.io/tags/javascript/"}]},{"title":"前端学习week15","date":"2019-08-11T14:44:16.000Z","path":"2019/08/11/前端学习week15/","text":"​ 本周主要学习了js的模块化的基本概念CommonJs，以及一点点编译原理的知识，字符令牌(token)化处理(其实在js的正则中捕获分组就是将字符token化)和递归下降，其实递归下降的概念很好理解，就是分析一个表达语句的字符串，遇到不同的操作交给不同的函数处理，这个过程叫做下降，而操作的表达式又需要递归处理。另外的重点是es6中的生成器以及Symbol数据类型，概念比较好理解，通过了迭代器也解释了为什么for-of，扩展运算符等可以对数组字符串等进行操作，Symbol还有很多边边角角的概念就懒得看了。这周还纠结了一些作用域的概念(见最后)，还是很有必要弄清楚的。此外leetcode到了277，写复杂情况的题还是思路广度不太够 生成器 generator function * name(){ yield variable } &lt;p class=&quot;code-caption&quot; data-lang=&quot;&quot; data-line_number=&quot;frontend&quot; data-trim_indent=&quot;backend&quot; data-label_position=&quot;outer&quot; data-labels_left=&quot;Code&quot; data-labels_right=&quot;:&quot; data-labels_copy=&quot;Copy Code&quot;&gt;&lt;span class=&quot;code-caption-label&quot;&gt;&lt;/span&gt;&lt;a class=&quot;code-caption-copy&quot;&gt;Copy Code&lt;/a&gt;&lt;/p&gt; 生成器函数返回的是一个生成器对象(这个对象叫做迭代器)，初始化后并没有执行，调用next()才执行到下一次yield运算符位置，当前状态挂起 调用next()返回一个对象，包含value和done两个属性 yield操作符的返回值为下一次next()调用时next的参数(只能为值或表达式)， 没有参数则为undefined yield 只能在生成器函数内部使用，和return一样不能穿透函数边界，即不能在生成器包裹的普通函数内部使用 生成器对象包含value和done属性，函数运行结束时value为函数的返回值，done为true，未结束时value为当前yield位置后接表达式的值，done为false return()方法在当前位置立即结束，后面代码不再执行，value为return的参数 注意try-catch-finally中finally的代码是一定会执行的 //形如 function * gen() { try { yield 1 yield 2 } catch(e) { yield 3 } finally { yield 4 } } var iter = gen() iter.next() iter.return() //得到的对象value是4, done为false throw()方法，在当前yield位置抛出错误 yield * foo()进入生成器foo()，继续执行迭代器next()会进入foo()内执行至其内的yield 如果不加*，则迭代器对象的value就会变成执行foo的结果即生成了foo生成器生成的迭代器 for (var value of foo(para))遍历每次yield位置的生成器的value，中途break相当于调用了生成器的return()方法 应用： 常用来用作一个状态机 let state = function * (){ while(1){ yield &#39;A&#39;; yield &#39;B&#39;; yield &#39;C&#39;; } } &lt;p class=&quot;code-caption&quot; data-lang=&quot;&quot; data-line_number=&quot;frontend&quot; data-trim_indent=&quot;backend&quot; data-label_position=&quot;outer&quot; data-labels_left=&quot;Code&quot; data-labels_right=&quot;:&quot; data-labels_copy=&quot;Copy Code&quot;&gt;&lt;span class=&quot;code-caption-label&quot;&gt;&lt;/span&gt;&lt;a class=&quot;code-caption-copy&quot;&gt;Copy Code&lt;/a&gt;&lt;/p&gt; Symbol() es6新加入的原始类型，不是普通对象，可以作为对象的独一无二属性(也是它的主要用途) Symbol函数前不能用new，否则会报错，因为生成的是一个原始类型值不是对象 Symbol函数接的参数是对这个创建的值的描述，没有任何其他作用 Symbol属性不可枚举 注意Symbol值作为对象属性名不能用.访问，因为.后只能接字符串，但是方括号可以接表达式 此外只能用新增的Object.getOwnpropertySymbols()方法来检索Symbol值属性，for-in/for-of等全都不能 每个Symbol值都是独一无二的，即用===一定返回false 不能通过隐式类型转换，可以显式，例如toString()方法 只能隐式转换为布尔值的true，因为是非空值 可迭代对象具有Symbol.iterator属性，是一个函数，执行返回一个作用于附属对象的迭代器，在es6中所有的集合对象(数组， Set， Map)和字符串都是可迭代对象，都有默认的迭代器(数值类型默认没有)(可以利用这个特性检测对象是否为可迭代对象)，同样生成器就是给对象的这个属性赋值，所以生成器创建的迭代器都是可迭代对象 for-of循环每执行一次都会调用可迭代对象的迭代器的next()方法，并将迭代器返回的结果对象的value属性存储在一个变量中，循环将持续执行这一过程直到返回对象的done属性的值为true，所以undefined不会使用 如果将for-of语句用于不可迭代对象、null或undefined将会导致程序抛出错误 for-of执行前会检测对象是否为可迭代对象，是可迭代对象则先通过Symbol.iterator()方法来获取其迭代器，本身是迭代器则直接迭代 给不可迭代对象或其原型增加这个属性的生成器函数可以添加自定义其迭代器，利用这个方法可以使数值类型和普通对象可迭代 [...foo()]扩展运算符可以操作所有可迭代对象，得到所有yield后的返回值，即迭代器对象的value值，并按照默认顺序读取 现在扩展运算符也可操作普通对象{...{a: 1}}可以得到{a:1}，而且只能在普通对象内部使用 iterator是Symbol构造函数的一个属性，指向一个Symbol值，而这个Symbol值同时也是集合对象及字符串的构造函数原型属性中的属性，指向生成器函数 内建迭代器 集合对象(数组，Set，Map)都有三种内建迭代器 entries() 返回一个迭代器，其值为多个键值对 values() 返回一个迭代器，其值为集合的值 keys() 返回一个迭代器，其值为集合中的所有键名 分别调用以上生成器方法函数能返回对应不同的迭代器 对于数组来说，for-of和...迭代以上任何迭代器只会迭代数组的数字索引(for-in可以循环迭代属性名)，而对稀疏数组来说，用迭代器遍历数组也不会跳过空位，对应位置的value为undefined 在for-of循环中，如果没有显式指定则使用默认的迭代器。数组和Set集合的默认迭代器是values()方法，Map集合的默认迭代器是entries()方法 字符串迭代器 还记得之前学习数字和字符串编码方式时，由于历史原因，js的字符串编码采用的ucs-2，也即utf-16。而在之后由于字符的增加，对于编码长度超过一个字节的字符会采用双字节编码，但是es5使用方括号访问每个字符的方式是操作的编码单元，即一个字符，无法正确识别双字节字符。 es6中字符串成为了可迭代对象，默认的迭代器直接操作字符而不是编码单元，所以现在可以使用for-of或者...正确访问双字节字符 零碎知识 在es6中，关于变量作用域的一些疑问 Variables and scoping in ECMAScript 6 Js参数作用域 函数的参数及for循环的head 可以看作{}的上级作用域 loop head 中变量用let声明的话，{}内可以用let重复声明创建该作用域中的变量，但不能用var 且在loop循环中let 声明的变量，每次迭代都会在当前重新绑定这个变量(即每次改变变量的值后再用这个值重新声明并赋值这个变量，这也是为什么传统for循环不能用const，但是for…in可以用const)，而用var声明的变量只绑定一次，就是闭包 参数中的变量相当于用let声明，在函数体内不能再用let重复声明，但是可以用var重复声明作为该作用域中的变量（行为与loop head相反） if(false){}内的变量赋值和函数都失效(但是有声明提升)，但是不能出现语法错误 关于loop-head和参数作用域的一些问题 用Function()构造函数创建函数，前面的参数为创建函数的参数，用逗号分隔，最后一个参数为函数体，参数都是字符串 JavaScript 采用的是词法作用域，函数的作用域在函数定义的时候就决定了 var value = 1; function foo() { console.log(value); } function bar() { var value = 2; foo(); } bar(); //1 执行上下文（Execution context stack，ECS)：当执行一个函数的时候，就会创建一个执行上下文，并且压入执行上下文栈，当函数执行完毕的时候，就会将函数的执行上下文从栈中弹出。执行上下文栈底一定有一个全局执行上下文 in可以检测对象及其原型链中的不可枚举属性 polyfill 旧版浏览器完全实现功能的实现 includes,Promise,bind Shiv/Shim旧版历览器无法完全实现功能的实现 形如let a = b = 1这样的语句只声明了第一个变量 连等赋值是从右到左进行的 考虑以下情况： let a = {} a.x = a = {1:1} //最后a指向的是{1:1}，并没有x属性 //因为编译器在处理连等赋值时先读取变量指针地址，没有则创建这个指针，再改变指针的指向 //这时原来a指向的空对象会增加一个x属性指向现在的a指向的对象 javascript 连等赋值问题","tags":[{"name":"front-end","slug":"front-end","permalink":"babopo.github.io/tags/front-end/"},{"name":"javascript","slug":"javascript","permalink":"babopo.github.io/tags/javascript/"}]},{"title":"前端学习week14","date":"2019-08-04T14:38:29.000Z","path":"2019/08/04/前端学习week14/","text":"​ 本周主要学习了正则表达式的基础知识，细节和小知识点非常非常多，看记录的内容就知道了，主要的学习目的还是能看懂和理解正则表达式以及js常用的正则api及其原理，例如正则对象的exec，test以及字符串的match和replace，不强求写出优雅简洁的正则，毕竟智商有限。此外简单介绍了日期类型和es6的增强字符串-反引号 ​ leetcode方面到了265题，这周主要在做正则的题目，没怎么刷，重点是几道回溯法的练习，解数独，八皇后问题等，感觉自己对复杂一些的代码掌控力还不够，写起来比较乱，有思路也写不出来，还是要练习练习练习 正则表达式 正则表达式也是一种对象类型 构造函数RegExp 用构造函数创建注意反斜杠的规则和字符串相同 字面量创建，两边用斜杠包围 斜杠是结束标值，所以表达式包含斜杠时，需要在前面加反斜杠 source属性，包含创建正则表达式的字符串，不包括//及外面的flags lastIndex属性，可写属性，控制下一次匹配开始的位置，只有当使用设置了g的时候才能被更新和修改，且只对exec和test生效，匹配失败会被重置为0 中括号只匹配一个字符，匹配中括号中任一字符 可以用连字符-指定范围，按unicode顺序，单独的-表示它自己 .在中括号中没有其他含义只表示其自己，其他特殊字符也是，比如+ * ^脱字符出现在最前面表示取非，不在最前面没有其他含义，[^]表示匹配全集 +前面元素至少重复一次，*重复至少0次，?前面元素出现1次或0次，{}内加数字或范围表示重复具体次数，前面的元素加()使多个元素重复 表达式末尾i表示不区分大小写/xxx/i 表达式末尾g表示全局匹配输入字符串中所有能匹配的项默认匹配第一个项就结束匹配/xxx/g 如果匹配的字符串有交叉，例如用/abcabc/g匹配abcabcabc只会匹配第一个匹配项，不会匹配交叉的第二个 脱字符^ 用在开头表示输入字符串的起始位置，$表示字符串结束位置，/^xxx$/则输入字符串必须从头至尾满足条件 \\bxxxxx\\b 单词边界，包裹的元素是一个独立单词，字符串的起始结束位置都是数字/字母/下划线(即\\w表示的字符) (?:)匹配项不会作为分组，结果不会出现在exec的结果数组中 (?&lt;name&gt;)可以给分组命名，只有自命名的分组的匹配项会出现在exec的group属性中 零宽断言 匹配两个符号之间的一个位置而不是符号，宽度为0 可以对同一个位置执行多个零宽断言匹配 零宽断言不是分组 /(?=foo)/匹配到字符串中foo开始的位置 /(?!foo)/位置后面不能匹配foo /(?&lt;=)/位置左边匹配xxxxx 回顾断言中有重复符，则贪婪模式是从右向左满足 分组时和正常一样是从左向右分配和自动命名的的，但反向代理的\\n需要放在分组的左边才能生效，即分配时是从左往右，扫描匹配时是从右往左 /(?&lt;!)/ 例： ^ === /(?&lt;![^])/ $ === /(?![^])/ \\b === (?&lt;=\\w)(?=\\W)|(?&lt;=\\W)(?=\\w)|(?&lt;![^])|(?![^]) 管道符| 表示或，需要用括号来限制其选项范围 记住正则的实现是从前向后按步进行的，回溯只存在于当前匹配不成功的情况 反向引用 前面分组匹配结束时，自动命名的分组可以用\\n引用匹配项 任何情况下都是以正则表达式中开始括号的顺序作为分组的顺序，即使用了|运算符 自命名分组可以用\\k&lt;name&gt;反向引用，同时也可以用\\n 方法 test 接受字符串，返回布尔值，存在匹配项就返回true exec 无匹配返回null，否则返回匹配信息对象 返回的对象是字符串组成的数组，包含整体及所有圆括号的分组，重复分组则保留最后一次，重复0次的保留undefined，增加了index，groups，input属性 group属性是一个对象包含自命名分组及其匹配项的键值对 exec设置了全局g也只会先返回第一个匹配项(同时更新lastIndex属性)，继续执行会向后匹配，不设置g多次执行会重复匹配第一项 String.prototype.match()是字符串的方法 参数里的正则使用g，则返回所有完整匹配项的结果数组（不包含分组），形式和普通数组相同 不使用g则返回第一项完整的匹配及其相关的分组匹配，形式和exec一样 replace 字符串的方法，用第二个参数替换第一个正则参数匹配到的字符串，第二个参数可以为函数，第一个参数也可以是字符串 第二个参数为函数时，传入的参数依次为exec执行后的结果数组的元素，依次为整体匹配项，各分组捕获项，匹配的index，命名分组，输入的字符串 设置g可以全局匹配，实际是重复执行匹配直到全部匹配结束 $n是正则自带的分组匹配到的字符串表示方式，不能把它当做完全的字符串看待，只能做增加字符，换位等操作 \\n用在分组开始匹配之前相当于匹配任何位置,即分组还没开始匹配 /\\1/.test(&#39;&#39;) // false /\\1()/.test(&#39;&#39;) // true 注意正负回顾零宽断言时的这个规则 贪婪模式 模式重复运算符+ * ? {}默认是贪婪的，会匹配尽量多的字符直到不能匹配再回溯 在模式重复运算符后加?变为非贪婪，会匹配尽量少的字符，只有剩下的模式无法匹配才会继续匹配重复 使用重复时优先考虑非贪婪 日期类型 构造函数Date，默认创建当前时间对象 自定义时间：月份从0开始，日期从1开始，小时分钟等不设置默认为0 getTime方法返回1970年开始以毫秒表示的时间戳 ，也可以用时间戳创建对象 模板字面量 反引(``)号表示的增强版字符串 支持多行，保留所有空白 也可用\\n指示换行位置 变量占位符 新增特性，由${}将变量嵌入字符串，中间可以放任意的表达式，包括运算符函数调用等，注意用反斜杠转义可以使其失效 标签模板 String.raw`` 反引号内写入字符串不用考虑转义，所见即所得，输出字符串，任意形式的转义都会失效，保留原样输出 形如上面这个例子，String.raw模板标签，实际上它是一个函数，后接模板字面量相当于传参，在控制台我们可以看到它传入参数的形式 第一个参数是一个数组，包含以变量占位符为隔板分隔的各个子串(类似split)，此外该数组还包含一个不可枚举的raw属性包含的数组，内容形式和包含它的数组内容相同，不过字符串内容与输入时的状态完全相同(即转义都不生效且保留转义符，然而变量占位符依然生效)，这也解释了为什么上一个例子会保留输入原样输出(正是利用了raw) 第二及以后的参数为从前到后各变量占位符中表达式的值 零碎知识 源代码书写字符串的时候才要考虑转义 字符串的split方法，参数为正则表达式时，会在各匹配项对应的位置返回分组捕获的字符串不会出现整体匹配的字符串","tags":[{"name":"front-end","slug":"front-end","permalink":"babopo.github.io/tags/front-end/"},{"name":"javascript","slug":"javascript","permalink":"babopo.github.io/tags/javascript/"}]},{"title":"前端学习week13","date":"2019-07-28T15:00:44.000Z","path":"2019/07/28/前端学习week13/","text":"​ 本周学习了最后一个常用排序算法-堆排序以及一些哈希表的基本概念，理解其思想和使用情景即可。js基础学习了异常处理和严格模式。红黑树没看完，只看完了基本概念，下周补完。leetcode方面到了245，有所放缓，其实是划水太多，要抓紧了 堆，堆排序 堆(heap)是一种数据结构，也叫优先序列(PriorityQueue) 区别于”堆内存(heap memeory)”的堆 堆内存对应栈内存 堆内存是随机分配的 栈内存对应调用栈 栈空间指一片内存 调用栈指函数间互相调用及等待的逻辑概念 堆是一棵完全二叉树 每个结点都比其子节点大(小) 最大/最小堆 (最大/最小值一定处于堆顶) 主要支持两种操作 增加一个元素 取出其最值 操作不影响堆的性质 堆排序是将长度为n堆数组的第一个值交换到最后，再将前n-1个数的数组堆化，直到数组有序 堆尾增加一个元素： heapUp 堆头增加一个元素： heapDown 例：取出堆的最值，将堆尾元素放在头部重建为堆 将一个无序数组转换为堆： 将数组当做按层遍历的二叉树，从末尾最小的二叉树头结点（最后一个元素的父节点）做heapDown操作，循环至堆头 找出第k大的元素，构建一个大小为k的最小堆 异常处理 try(throw)–catch–finally catch捕获的看前面throw的是什么，默认的错误是一个对象，因为是Error()的实例 编译器先确定程序没有语法错误才开始执行 throw立即停止运行直到被catch Error()是构造函数 严格模式 &quot;use strict&quot; 静默错误现在会抛出异常 不允许不声明创建全局变量 只限定当前作用域下的代码，不限制调用的函数 直接调用方法/构造函数，this绑定undefined而不是window 函数形参名唯一 不能使用八进制字面量(即0开头的数字类型)，但可以写成0oxxx 不允许直接使用eval()在当前作用域中创建变量或函数 在严格模式下，eval()在运行时有自己的词法作用域，意味着其中的声明无法修改所在的作用域，但是可以获取eval()内语句块的返回值 不能覆写arguments的值 es6一些语法会自动开启es6模式，例：class 带有“非简单参数”的函数为不能包含 “use strict” 指令 默认参数值 剩余参数 参数解构 因为这些是es6新增的参数语法，”use strict”不认识，在es6模式下如class等没有问题 带有“非简单参数”的函数为什么不能包含 “use strict” 指令 哈希表(散列表)哈希函数 散列函数生成的值要尽可能随机且均匀分布 哈希冲突即不同key经过哈希函数计算出相同的值，很难通过完善算法的方式完美解决，所以需要其他的途径 开放寻址法 如果出现了冲突，就重新探测一个空闲位置将其插入 线性探测 步长为1 二次探测 步长为平方 双重散列 冲突则再哈希一次 装载因子： 填入表中的元素个数 / 散列表的长度 装载因子越大，空闲位置越少，散列表性能越低 动态扩容/缩容，设置阈值保持执行效率 链表法 每个slot对应一条链表，hash值相同则直接加入链表末尾 平衡二叉查找树严格的平衡二叉查找树是指这棵二叉查找树任意结点的左右子树高度差不能大于1，使树的高度保持以2为底logN 设计平衡二叉查找树的初衷是为了防止频繁的插入和删除操作造成的性能退化，常见的平衡二叉查找树： AVL树：严格符合以上定义，是高度平衡的二叉查找树 红黑树(R-B tree)：不严格符合高度差为1的定义，但是能思想是一样的，即保持左右子树高度大致相等，所以也认为是合格的平衡二叉查找树，很多种平衡二叉查找树都不严格符合定义 定义： 根结点是黑色 每个叶子是黑色的空结点NIL 相邻结点不能同时为红色，即红色结点被黑色结点隔开 *从任意结点到达其可到达的叶子结点路径经过的黑色结点的数量是相同的 红黑树是“近似平衡”的(即性能不会退化地太严重，树的高度稳定地趋近以2为底logN) 插入操作 插入结点必须是红色，新插入的结点放在叶子结点上 旋转 变色 删除操作 零碎知识 浅拷贝和深拷贝 浅拷贝只复制对象的第一层 深拷贝递归复制所有层级 直接调用eval()是在当前作用域下调用，凡是使用别名调用eval()则一律是在全局作用域下 函数表达式的函数名是常量绑定，只在该函数内部有效，在函数内对其赋值在非严格模式下会静默失败，严格模式下会报错 (function a() { a = 3 console.log(a) })() //会打印出整个函数体 //可以理解为a函数相当于const定义的常量 注意函数声明提升https://blog.csdn.net/sinat_35512245/article/details/53514804 函数表达式可以后面加括号立即调用，函数声明不可以 给函数声明整体加括号相当于将函数声明转换为函数表达式，就可以立即调用了 两种立即执行函数的写法( function(){…} )()和( function (){…} () ) call 比 apply的性能更好，因为传入的参数是函数需要的格式 对象中若有splice属性存放数组的splice方法以及length属性，会自动转为object []形式 dot notation比用[]读取对象的属性性能好 for的性能远高于forEach 因为for循环没有额外的函数调用栈和上下文 forEach里操作了toObject以及循环终止等逻辑更加复杂","tags":[{"name":"front-end","slug":"front-end","permalink":"babopo.github.io/tags/front-end/"},{"name":"javascript","slug":"javascript","permalink":"babopo.github.io/tags/javascript/"}]},{"title":"前端学习week12","date":"2019-07-21T12:34:15.000Z","path":"2019/07/21/前端学习week12/","text":"​ 学习时间正好三个月了， 本周学习了快排，这样排序算法就差堆排序没学了。本周的重点还是js的面向对象的概念，js除了几个基本数据类型(number,string,null,undefined)，其他的数组函数等都能视作对象，甚至基本数据类型也有包装对象的概念。要理解js的面向对象，原型和原型属性是非常重要的知识点，要理清数据类型的原型几个构造函数的原型属性之间的关系，接着是自定义构造函数。leetcode方面到了210题，但是感觉最近提升有限，似乎到瓶颈了，还是要多总结 排序 sort方法的函数值参数为什么用两个参数，而不是一个？ 一个参数局限性大，两个更灵活，sort内部实现根据箭头函数的返回值来对元素排序，可以自定义排序条件 排序算法的稳定性： 排序前后不改变相同元素的相对位置 稳定： 冒泡 归并 插入/BST 返回新数组的快排 不稳定： 选择排序 原地快排 快排 主要思想是先随机取一个位置的数，将大于，等于， 小于它的数分组，再递归 切分不平衡可能使排序效率较低，一个解决办法是排序前先将数组随机打乱 当数组中所有数都相同时，时间复杂度会退化为n * n，调用栈也会达到n层 小数组时快排比插入排序慢 原地快排将取样元素放在数组末尾作为哨兵来优化partition 深入理解对象 方法中的this指向当前方法所属的对象，相当于函数的隐含参数 eg: apply() bind() this 是对象中的一个特殊变量 箭头函数根据当前的词法作用域而不是根据this机制顺序来决定this，所以，箭头函数会继承外层函数调用的this绑定，而无论this绑定到什么，且不能改变箭头函数的this绑定，可以当做箭头函数没有this 箭头函数不能用做构造函数，即其没有原型属性 箭头函数没有arguments属性 原型 对象都包含一个原型，原型也是一个对象，原型也有原型。。。Object.prototype是所有对象原型的父原型 Object.prototype.__proto__结果为null 访问对象中不存在的属性，会在其原型中搜索，接着是原型的原型，以此类推 访问属性的优先级 对象自身 &gt; 原型 即对象和原型有同名属性有限调用对象自身的属性 Object.getPrototypeOf()获取对象的原型 Object.creat(prototype)以原型创建对象 传入null创建无原型对象 原型和原型属性 对象的原型：obj.__proto__ 原型属性： 每个函数（且一般只有函数才有）都有一个原型属性 f.prototype 原型属性是一个对象，对象内的属性包含构造器标识（即这个函数）， 以及实例能调用的方法 函数对象本身的属性可以在构造器标识内查看，这是实例不能调用的 即实例的constructor属性可以查看这个实例的构造函数 这个概念是针对构造函数来说的，可以理解为本来有的原型基础上的衍生原型（添加了自己定义的属性），就是它会作为这个构造函数的实例的原型 因此f.prototype.xxx可以给构造函数的原型属性添加属性，这样这个构造函数的实例就能使用这个属性 可枚举/不可枚举属性，默认创建的是可枚举（会出现在for/in循环中，不可枚举属性不会，但是可以用in返回true） 原型属性是一个对象， 创建的实例的原型指向这个对象，修改构造函数的原型属性指向的对象，在这之前创建的实例的原型指向不会变 Object.prototype.toString()判断包装类型 包装类型 每当读取一个基本类型值的时候，后台就会创建一个对应的基本包装类型的对象，从而让我们能够调用一些方法来操作这些数据 自动创建的基本包装类型的对象，则只存在于一行代码执行的瞬间，然后立即被销毁了。这就意味着，不能在运行时为基本类型值添加属性和方法。 构造函数 调用函数前用new表示调用其构造函数 new一定会返回对象，当构造函数返回的不是对象则会被忽略 注意用不用new的区别，不用new相当于给当前作用域的活动对象添加属性 通过new创建的对象称为构造对象的实例 instanceof判断实例是不是某个构造函数（或者继承的父构造函数）创建的 面向对象 表达一个事物是离散存放的 封装： 把表达一个事务的最终信息及可能的操作（即函数）放在一起 同一类对象有相同的一组属性和一组函数 继承：让一个类直接获取另一个类所有的属性和方法 多态：不关心得到的事物具体是什么类别，更关心这个事物是否有某方面特性(有特定的一组属性和方法) class Javascript 类 创建的方法不可枚举 class A { static a(){} static b(){} constructor(){} method1(){} method2(){} get length(){} set length(val){} } typeof A == function 零碎知识 判断类型 typeof 用来判断原始类型 Object.prototype.toString.call判断内置对象类型 instanceof判断自定义对象类型 new.target === f判断f是否正在被new调用 Object.defineProperty(obj, &#39;name&#39;, {})给对象/原型添加属性 {}内依次为value，get，set，enumerable， writable， configurable value和（get，set）只能出现一个 直接给原型赋值对象， name.protorype = {constructor: name, xxxxx} 用Array.prototype.slice().call(arguments)在函数中创建参数的数组（arguments是类数组不能直接用数组方法），也可以用[].slice().call(arguments)","tags":[{"name":"front-end","slug":"front-end","permalink":"babopo.github.io/tags/front-end/"},{"name":"javascript","slug":"javascript","permalink":"babopo.github.io/tags/javascript/"}]},{"title":"前端学习week11","date":"2019-07-14T14:47:24.000Z","path":"2019/07/14/前端学习week11/","text":"​ 本周主要学习了js高阶函数的用法，可以将函数作为参数传入另一个函数使用，熟悉几个自带的数组方法函数，另外简单介绍了一下JSON。数据结构学习了二叉树，前中后序遍历，搜索二叉树的性质，增删结点，加深理解还是要靠刷题。leetcode方面，本周到了160题，下周争取200，还是应该注重质量，算法方面动态规划是个难点，概念了解的差不多了，但是大部分题目感觉还是很难，另外这周一定要把算法部分的排序和二分查找部分看完 高阶函数 _实参占位符 以函数值为实参没有产生闭包 函数的length属性返回形参的个数，name属性返回函数名 传参 函数的apply方法，将数组或类数组作为单独参数传入，防止多余的参数被忽略 现在一般用省略号 数组以函数为参数的方法 forEach 一个函数参数， 只是对各元素进行操作，没有返回值，forEach不直接改变调用它的对象，但是对象可能会被callback改变 只遍历存在的项，empty不遍历 除了抛出异常无法阻止forEach filter 一个函数参数，返回包含通过测试的元素的新数组 map 一个函数参数，返回回调函数的结果的新数组 reduce 一个函数参数，数组第一项作为初始值，初始值变量分别和数组剩下的每个值会作为操作函数的参数，返回最后迭代后的值 初始值可选，如果没有提供初始值，则将使用数组中的第一个元素。 在没有初始值的空数组上调用 reduce 将报错 函数参数前一个形参是累计器，后一个是数组元素 实际上前三个方法传入的参数为三个，分别为 Current Value (cur) (当前值) Current Index (idx) (当前索引) Source Array (src) (源数组) reduce在最前面还有一个Accumulator (acc) (累计器) 给函数参数传入的参数也是这几个参数，所以需要注意接受多余的参数是什么，会造成什么后果，怎么利用 函数值参数可简写为箭头函数 只有一个参数时可以省略括号 只有一个return语句时可省略return和花括号 函数的方法： bind(null, xx,xx)，返回一个新的函数，相当于在原函数内给对应位置的参数附值绑定，返回的新函数就没有这个形参了，null后紧接着原函数的第一个参数，以此类推 function bind(f) { var fixedArgs = Array.from(arguments).slice(1) return function() { var args = Array.from(arguments) return f.apply(null, fixedArgs.concat(args)) } } apply方法，用数组来指定函数的参数 JSONJavascript Object Notation 属性名必须用双引号，只能包含简单的数据表达式，不能包含注释 parse 和 stringify函数 没有undefined 不能出现明文tab符 不能出现多余符号 二叉树 完全二叉树 前pre/中in/后序post遍历 traversal 排序二叉树BST 结点左结点的值小，右结点的值大 中序遍历，得到有序序列 是一种插入排序，利用这点可以很快地判断是否为BST，是BST很重要的一个性质 添加结点 删除结点 零碎知识 toString方法可以将数字转为2-36进制的字符串 sort()方法默认情况下按照升序排列数组项，sort()方法会调用toString()转型方法，然后比较得到的字符串，即使我们比较的是数字，他也会把数字转为字符串以后再排序 关于动态规划(dynamic programming)的理解 每个阶段只有一个状态-&gt;递推； 每个阶段的最优状态都是由上一个阶段的最优状态得到的-&gt;贪心； 每个阶段的最优状态是由之前所有阶段的状态的组合得到的-&gt;搜索； 每个阶段的最优状态可以从之前某个阶段的某个或某些状态直接得到而不管之前这个状态是如何得到的-&gt;动态规划。 动态规划的三个组成：最优子结构，边界， 状态转移 递归是自顶向下的，而动态规划的本质是自底向上的 解决动态规划/递归中的重复计算 “备忘录算法”：将递归中计算过的值存入哈希表 自底向上递推，动态存储下次计算需要的状态 归并排序 基本思想是将数组递归地分成两半分别排序，再将结果归并 优化： 小规模子数组可以使用插入排序 增加一个判断：arr[mid] &lt; arr[mid + 1]时可认为数组已经有序，跳过merge，直接连接 一般是自顶向下的方法，也可自底向上两两归并，四四归并。。。。这种方式适合处理链表原地排序 数组的includes方法可以正确判断NaN，indexOf不行 Array.from()将类数组对象转为数组 arguments 是一个对应于传递给函数的参数的类数组对象","tags":[{"name":"front-end","slug":"front-end","permalink":"babopo.github.io/tags/front-end/"},{"name":"javascript","slug":"javascript","permalink":"babopo.github.io/tags/javascript/"}]},{"title":"前端学习week10","date":"2019-07-07T12:35:01.000Z","path":"2019/07/07/前端学习week10/","text":"​ 本周主要学习了数组和对象这两种数据结构，在js中，除了集中原始值，其他数据结构都能视作对象，另外简单介绍了一下链表，js中的链表结构比较简单，操作也很方便。需要理解的是对象标识符指向对象的存储地址(这也比其他语言简单很多)，另外就是js数组和字符串的一些方法函数，需要在使用中加强记忆。 ​ leetcode刷到了100题，熟练度确实有点用，应该抽出点时间review，下周争取130+，另外看完算法的排序部分 UTF-8 变长编码 第一个字节的前几位表示这个字符占用多少个字节 一个字节01xxxxxx 两个字节110xxxxx 三个字节1110xxxx 四个字节11110xxx 之后的每个字节的都是10开头，因此不同字节长度实际存储该字符所占二进制位： 一个字节： 6 两个： 5 + 6 三个： 4 + 6 + 6 四个： 3 + 6 + 6 + 6 特点： 变长 兼容标准ASCII 容错 数组和对象 读取null和undefined的属性会报错 用.和[]都可以方问属性，但是点后直接跟属性名，方括号会计算其中的表达式并把返回值作为属性名 属性名是字符串 可以使用方括号访问数字或带空格的字符串作为属性名的属性 数组是值的有序集合，对象是值的具名集合 delete obj.a 一元运算符 删除对象中的a属性 str in obj 二元运算符 返回布尔值，对象中是否有这个属性 in用在数组中是检测这个位置是否为空，并不是是否存有这个值 indexOf只能检索大于等于0的整数下标，其他都返回-1 for (name in obj) 遍历对象的属性 ，属性名字符串传给name 这里的in不是运算符 对象的浅比较和深比较 == 和 === 比较的是对象是否是同一个引用 深比较是比较属性和值是否相同而不论是否是同一个引用，js没有深比较的api，需要自己实现 一些数组的方法 fill(item, start, end) 填充，不包括end位置，start和end都省略则填充empty flat() 展开一级，返回新数组 里面有对象不展开 include(value) 判断数组中是否有这个值，返回布尔值 不能判断对象，除非是同一个引用 给原始值添加对象和读取对象，不会报错但会读取undefined，可以用Object()创建原始类型(对象)的包装对象(一个真实的对象包装了一个原始类型) 不建议使用 字符串的trim()方法，删除开头和结尾的空白符号(空格，换行，制表等) arguments对象很像数组，有length属性， 但不包含任何数组方法， 是一个类数组对象 类数组对象：任何一个具有length属性以及对应非负整数属性的对象 类数组对象不能直接使用数组方法，但是可以Array.methods.call(obj, xxx)调用数组方法 Array.from() 方法从一个类似数组或可迭代对象中创建一个新的，浅拷贝的数组实例 ...省略号运算符 rest parameter 剩余参数，只能出现一次且只能出现在形参最后 spread operator 展开数组和对象，展开对象时只能用在创建对象和数组的字面量时使用，因为展开形式为对象中属性及对应值的表达式 可以给形参赋值作为缺省的默认值 零碎知识 递归四条准则 基准情形 不断推进 设计法则 合成效益法则 使用递归时注意递归过程中重复计算的问题，可以储存各计算结果当遇到这个计算时直接返回值 不要使用全局变量(除非刻意要用) 注意返回新对象还是在原对象上操作的一致性 document.write() 向文档解析流写入内容 文档一旦解析完成&lt;/html&gt;，解析流关闭 重新write会导致重新打开一个解析流，之前的内容完全覆盖 排序算法 希尔shell排序 希尔排序的思想是 将原数组中间隔h的子数组使用插入排序，循环减少h至h=1即排序完成 实际是插入排序的优化版，能将离本来位置较远的元素更快地移动到本来的位置 实际使用中是性能最好的初级排序","tags":[{"name":"front-end","slug":"front-end","permalink":"babopo.github.io/tags/front-end/"},{"name":"javascript","slug":"javascript","permalink":"babopo.github.io/tags/javascript/"}]},{"title":"前端学习week9","date":"2019-06-30T13:38:35.000Z","path":"2019/06/30/前端学习week9/","text":"​ 本周正式开始了一边学习js基础一边leetcode的刷题，才发现自己的数学基础真的很薄弱，果然以前欠的都是要还的，只能慢慢训练了，以后坚持每天刷两道题以上，每周复习一次之前刷过的题目，争取结课前能突破500。 ​ js方面，本周主要学习了初级函数的定义，一个重要的知识点是闭包，不同书对闭包的定义可能有出入，但是本质是大体一样的，就是每次函数调用都会创建一个新的作用域，这个作用域和同一个函数的其他作用域不会相互影响。其他就是一些细枝末节的东西，应当经常复习 函数 在if或循环中最好不要写函数申明 function a() {} //不同浏览器可能会出现问题 &lt;p class=&quot;code-caption&quot; data-lang=&quot;&quot; data-line_number=&quot;frontend&quot; data-trim_indent=&quot;backend&quot; data-label_position=&quot;outer&quot; data-labels_left=&quot;Code&quot; data-labels_right=&quot;:&quot; data-labels_copy=&quot;Copy Code&quot;&gt;&lt;span class=&quot;code-caption-label&quot;&gt;&lt;/span&gt;&lt;a class=&quot;code-caption-copy&quot;&gt;Copy Code&lt;/a&gt;&lt;/p&gt; 但是可以写函数表达式赋值 var a = function() {} 传参 都是值传递 arguments 得到所有传入实参的数组 传入的实参为对象时，可以修改对象的属性，这一点很像const声明的常数变量为对象时可以修改其对象 其他情况对传入的参数赋值等操作实际都是对arguments的项的操作，不能影响原来的变量 多余的参数会被忽略 少传的参数会被赋值为undefined 闭包 局部变量在每次函数调用时都会重新创建，且函数调用不会对其他函数调用内的局部变量产生影响 包装了局部变量的函数就叫做一个闭包 零碎知识 101..toString(2)第一个点为数字小数点 数组的splice方法有三个参数，分别为位置，删除的个数， 和要添加的元素，可以将要删除的个数置零用作向某位置插入元素 可以在循环最外面加标签的方法跳出多重循环 loop: for(xxxx) { for(xxxxx){ break loop } } &lt;p class=&quot;code-caption&quot; data-lang=&quot;&quot; data-line_number=&quot;frontend&quot; data-trim_indent=&quot;backend&quot; data-label_position=&quot;outer&quot; data-labels_left=&quot;Code&quot; data-labels_right=&quot;:&quot; data-labels_copy=&quot;Copy Code&quot;&gt;&lt;span class=&quot;code-caption-label&quot;&gt;&lt;/span&gt;&lt;a class=&quot;code-caption-copy&quot;&gt;Copy Code&lt;/a&gt;&lt;/p&gt; 数组的push, pop，unshift返回的是修改后数组的长度，shift返回的是取出的值，splice返回的是删除的数组 空数组取非的布尔值是false，但是空数组转换成数字是0，而且空数组==false返回的是true 函数表达式赋值声明 var a = function b () {} // b标识符可用于函数内的递归操作，一般省略 js的无符号右移&gt;&gt;&gt;即便没有发生实际位移，即位移位数为0，也会将前面的位数置0，并转为无符号数 非数值&gt;&gt;&gt;0会得到0 -1 &gt;&gt;&gt; 0会得到2 ** 32 unsigned = signed &gt;&gt;&gt; 0通过使用无符号右移运算符，位动位数为0，可以将32位有符号整数，转化为32位无符号整数。 signed = unsigned &lt;&lt; 0通过使用左移运算符，位动位数为0，可以将32位无符号整数，转化为32位有符号整数。 ??可用来代替||当不需要短路特性时 在不声明直接初始化的变量之前引用这个变量会直接报错，并不会声明提升 一般用判断长度的方法来判断数组是否为空，注意不能用array == []来判断，因为[]相当于new Array()相当于声明了一个新的空数组，程序会自动在堆中为其开辟一块内存空间，它和之前array的内存空间不是同一块，所以自然不相等 Object用等号比较的是内存地址，是否引用了同一个值","tags":[{"name":"front-end","slug":"front-end","permalink":"babopo.github.io/tags/front-end/"},{"name":"javascript","slug":"javascript","permalink":"babopo.github.io/tags/javascript/"}]},{"title":"前端学习week8","date":"2019-06-19T06:27:06.000Z","path":"2019/06/19/前端学习week8/","text":"​ 本周划水有点厉害，主要还是复习了一边js中数值类型的存储方式，即双精度浮点数(见上周内容)，需要注意的是双精度浮点数虽然能表示很大的数，但是有其能精确表示的数的范围，这是由其只有64位决定的，只有位运算的32位整型中负数是由补码表示的，js中只出现这两种存储格式，其他仅作了解。 另外linux真的不知道该怎么学，本来想利用空余时间学习点linux的知识，以后面试能吹点牛皮，然而那么多命令看过就忘了，只记得一点点基本概念。 函数 变量的声明忌讳直接在前面声明一大坨，即插即用即可(反正编译的时候会全部提到前面)，因此，js可以调用语句后面声明的变量和值。即声明提升(hoisting)：变量在声明它们的函数体以及这个函数体嵌套的任意函数体内都是有定义的，注意声明会提升但是赋值不会。函数声明也有这样的特性 注意局部变量和全局变量 js的全局变量是全局对象的属性，用var声明的不可配置，而赋值声明的可以配置删除 局部变量可以覆盖重定义全局变量，然而只在局部生效 零碎知识 var i = 0 i = i++ console.log(i) //会输出什么结果 //答案： 输出 0 //原理： 先将i = 0 的赋值操作入栈，再将i + 1 入栈再按顺序出栈，最后得到的结果是将i赋值为0 变量名由$，字母，数字，下划线组成，只有数字不能用作开头 涉及return、break、continue、throw语句的场景中。如果这四个关键字后紧跟着换行，javascript会在换行处填补分号 ++和–运算符单独一行时，会作为下一行的前缀解析 js是变量松散类型语言，可以给变量赋不同数据类型的值，但不建议这么做 var语句可以省略，直接对变量赋值会自动声明该变量，但在es5的严格模式下会报错，而且函数内未声明且直接赋值的变量会声明为全局变量，所以不推荐省略 由于undefined并不是一个关键字，其在IE8-浏览器中会被重写，在高版本函数作用域中也会被重写；所以可以用void 0 来替换undefined 不同的对象在底层都表示为二进制，在javascript中二进制前三位都为0会被判断为object类型，null的二进制表示是全0，所以执行typeof时返回’object’ 所以判断一个值是否为null类型的最佳方法是直接和null进行恒等比较 在Number()方法中空字符串和空白字符串都转换为0，而在Boolean方法中，空字符串””转换为false，而空白字符串” “转换为true 自动类型准换中布尔类型只有七个假值(falsy value)，这7个值包括undefined、null、+0、-0、NaN、false、””(空字符串) 转换为false，其他任何情况都转换为true Number(‘’)的结果是0，parseInt(‘’)和parseFloat(‘’)的结果是NaN null和undefined没有toString()方法，而String()函数在非undefined和null会调用toString()方法 一般使用空字符串”” + 某个值，将该值转换为字符串 字符串的substring(start, end)和slice(start, end)方法(substr() 已弃用) slice(start, end) 返回从start位置到end(不包括)的字符串 如果end为undefined或不存在，则返回从start位置到字符串结尾的所有字符 如果start是负数，则start = max(length + start,0) 如果end是负数，则end = max(length + end,0) start和end无法交换位置 start &lt; end时输出空字符串 start/end被传入NaN时相当于传入0 substring(start, end) 如果end为undefined或不存在，则返回从start位置到字符串结尾的所有字符 如果任一参数是NaN或负数，则被0取代 如果任一参数大于字符串长度，则被字符串长度取代 如果start 大于 end，则交换它们的值 数组的最大长度为2的32次方-1","tags":[{"name":"front-end","slug":"front-end","permalink":"babopo.github.io/tags/front-end/"},{"name":"javascript","slug":"javascript","permalink":"babopo.github.io/tags/javascript/"}]},{"title":"前端学习week7","date":"2019-06-16T03:04:48.000Z","path":"2019/06/16/前端学习week7/","text":"​ 本周将css的学习进行了收尾工作，介绍了目前还存活的css框架Bootstrap，重点在于grid layout系统是如何实现的。接下来进入了Javascript基础的学习，对于js的基础数据类型，这里坑比较多，按照比较受认可的《高程》的说法是五种数据类型，其中null和undefined分别为一种，特别注意的是number类型这里坑很多 Bootstrapcss框架 grid layout version 3.4 浮动实现 宽度百分比 version 4.3 flex 利用flex特性 Javascript值，类型，运算符five basic types of values in JavaScript: numbers, strings, Booleans, null, and undefined values. 使用typeof (null)返回的是object number js使用64位固定长度存储数字，其中一位表示正负，一位表示小数点位置。 浮点数在计算机中的存储方式 补充： 对于64位双精度的11位符号位，是采取移位方式存储的，范围为(-1023 - 1024)，即(2^11 -1)加上E的值 特例： 0 在浮点数中特殊存储为全0，-0首位为1。infinity：指数全1，尾数全0。NaN：指数全1，尾数第一位为1 How numbers are encoded in JavaScript 1位符号位，11位指数位(exponent)，52位数值位，最大的数为2**53 -1, 再大的数就要占用exponent位，此时+1不会影响数值，因为相当于向左移了一位，最后一位补零，而数值位只能有52位 存储的小数用二进制表示时可能会丢失精度(超过64位) 所有的数字类型,在JavaScript中,都是双倍精度的浮点数类型，每一个数字,都是使用64位(8字节)来存储 对于位运算, JavaScript会首先把浮点数转换成32位的整型来进行处理,而不是直接对浮点型进行操作.准确的来说,是转换成32位,大端序, 补码, 有符号的整型，因为整型不能表示小数，转换时会把小数部分抹去。转换时整数部分超过32位则保留右边32位转换过程是将52位数值位的前20位抹掉，32位有符号整型的第一位作为符号位，此时负数为补码形式存储。位运算之后再转为64位，负数补1，正数补0 了解 JavaScript 的 Number 类型 special numbers Infinity 超过能存储的最大值的数字 -Infinity NaN not a number 无意义的结果以及NaN参与运算的结果 stringsJavascript使用UCS-2编码，所有字符在这门语言中都是2个字节，如果是4个字节的字符，会当作两个双字节的字符处理http://www.ruanyifeng.com/blog/2014/12/unicode.html 单双引号没有区别 字符串只能放在一行，所以不能出现明文回车 由于方括号操作的是编码单元而非字符，因此无法正确访问双字节字符 Boolean 比较 字符串比较： 按照字母顺序第一个能比较的字符按ascii值比较决定大小 console.log(NaN == NaN) // → false //Infinity的比较也是false，因为无穷大不一定精确相同 逻辑 自动类型转换(隐式类型转换) == 两侧存在null或undefined时，只有两边都为null或undefined才为true 布尔类型转换： 0, NaN, “” 视为false === !== 严格比较，不会发生类型转换 boolean == string 永远为false +号运算符作为一元运算符时，Expression将进行ToNumber()操作 加号运算符详解 在new Date()前面使用一元加符号，可以把日期字符串，转换为日期毫秒数 a++ 会将a的数据类型转为number 逻辑运算符短路特性 当 || 和 &amp;&amp; 两侧表达式返回的不是布尔值时触发短路特性 || 左侧可以转为true时返回左边的值，用于添加右边的默认值fallback，当左边为false时返回默认值 &amp;&amp; 左侧可以转为false时返回左边的值，左边为true时返回默认值 只要左侧返回，右边会被直接忽略 Others 位运算 只有整数才能做位运算 | 按位或 &amp; 按位与 注意负数是补码形式 ^ 按位异或 ~ 按位非 &gt;&gt; 按位右移 保留符号位(负数左边补1，正数补0 &gt;&gt;&gt; 按位右移 不保留符号 (都补0) &lt;&lt; 按位左移 右边补0 逗号运算符：逗号运算符的作用是将若干表达式连接起来。它的优先级是所有运算符中最低的，结合方向是自左至右，返回最后一个表达式的值。请注意：并不是所有的逗号都要看成逗号运算符，如在函数调用时，各个参数是用逗号分隔开的，这里的逗号并不是逗号运算符。 void运算符：出现在操作数之前，操作数正常计算，但忽略结果返回undefined 程序结构 当一行的开头是+，-，/, [ , ( , ` ，前一行必须加分号 ，可以把分号写在这行开头，其他时候建议不写分号JS的自动分号插入机制 所有不在引号里且不为保留字和标识符的都是变量 变量名只能以$ , _ ,字母开头，可以包含数字，不能包含空格和其他ascii码范围内的符号 在控制台所有表达式都有一个返回值 注意isNaN()和Number.isNaN()的区别 为什要有这两个函数：js中NaN == NaN及NaN === NaN都是返回false的 Number.isNaN()是isNaN()的es6进化版本 es5中的isNaN()会先将参数进行Number()的数据类型转换，能转换成功的(如空字符串/布尔值/纯数字字符串)会返回false，NaN和转换成NaN的都会返回true Number.NaN()不会先做类型转换，所以只有NaN会返回true。(因为是数字类型构造函数的自由方法，应该可以理解为只会判断数字类型的NaN) Js语句和表达式的区别","tags":[{"name":"front-end","slug":"front-end","permalink":"babopo.github.io/tags/front-end/"},{"name":"css","slug":"css","permalink":"babopo.github.io/tags/css/"},{"name":"javascript","slug":"javascript","permalink":"babopo.github.io/tags/javascript/"}]},{"title":"写给新手看的stylus简单教程","date":"2019-06-12T15:05:53.000Z","path":"2019/06/12/写给新手看的stylus简单教程/","text":"​ 学css那肯定就离不开预处理，预处理的作用相当于在css上面再套了一层壳，用更简洁更高级的方式来写样式，剩下的就交给编译器编译成css代码，但要记住预处理只不过是工具而已，能不能写好是建立在css的基本功学扎实的基础之上的，特别是进入css3时代，原生css即能方便实现的功能越来越多，预处理显得又不那么重要了，但是后面学习使用框架时似乎能用到，那么还是好好学习一下，这篇文章的是写给像我一样刚接触css时看到预处理器的文档一脸懵逼不知道如何下手的同学，顺便记录一些能用上的奇技淫巧。 这里选择了相对冷门的stylus，因为写起来不需要花括号，分号甚至不需要声明的冒号，写起来相当优雅简单省事 嵌套嵌套是预处理器最有特色的东西了，在stylus中是利用缩进实现的层层嵌套，编译时会从最外层的选择器一直到最里层，但要注意的是嵌套随然好用，但是最好不要超过2层，因为css中尽量不要体现html中的结构 &amp;这个符号相当重要，它是缩进使用的，代表其被嵌套的父选择器，其实就是一种省略的写法。 其实有了嵌套和&amp;,就已经可以完成大部分的工作了。接下来算是一些高级点的用法 Mixin混合，其实就是其他编程语言中的函数，在需要调用的地方打上函数名，编译时会自动加入自定义的内容 @extends在其他选择器下使用@extend [name]可以将[name]选择器下的所有属性都加入。 循环循环生成多个选择器 for $num in (1..100) .a-{$num} color red &lt;p class=&quot;code-caption&quot; data-lang=&quot;&quot; data-line_number=&quot;frontend&quot; data-trim_indent=&quot;backend&quot; data-label_position=&quot;outer&quot; data-labels_left=&quot;Code&quot; data-labels_right=&quot;:&quot; data-labels_copy=&quot;Copy Code&quot;&gt;&lt;span class=&quot;code-caption-label&quot;&gt;&lt;/span&gt;&lt;a class=&quot;code-caption-copy&quot;&gt;Copy Code&lt;/a&gt;&lt;/p&gt; 以上代码生成 .a-1 { color: #f00; } .a-2 { color: #f00; } .a-3 { color: #f00; } 通过这种方式我们可以快捷生成多个用数字排序的选择器 主要有一下几个点： 变量前加$是为了与正常字符串区分，可以不加 拼接字符串使用{} 循环范围使用(1..10)两个小数点，且包含1和10","tags":[{"name":"front-end","slug":"front-end","permalink":"babopo.github.io/tags/front-end/"},{"name":"css","slug":"css","permalink":"babopo.github.io/tags/css/"},{"name":"stylus","slug":"stylus","permalink":"babopo.github.io/tags/stylus/"}]},{"title":"前端学习week6","date":"2019-06-06T14:30:47.000Z","path":"2019/06/06/前端学习week6/","text":"​ 本周继续学习了CSS3的一些重要属性，重点有以下几个：列布局，渐变，2D/3D变换，还有渐变及动画。列布局与flex相比的优势在于实现一些单元素的多列布局，更类似于报纸杂志等文字排版。渐变主要应用于背景图片的颜色渐变，注意与混色模式搭配可以生成一些很有意思的效果。transform，transition及animation搭配生成页面中的动画效果，注意变换是不影响布局的，渲染的元素会默认覆盖在其他正常元素之上，渐变及动画的区别在于渐变是用时间控制，而动画是用帧来控制，且动画可以实现无限循环的动画。CSS3的基本概念的学习到这里应该就告一段落了。 CSS3multiple column column-count: columns;将块元素折断 不能折断inline-block/inline 图片可以 break-inside: avoid-column; 可设置不折断 column-width不支持百分比与负值值 column-fill: ; balance 默认 auto 同时设置column-count和column-width，前者作为最大列数，后者为每列最小宽度，可以都转化为count，哪个小哪个生效 column-gap 支持百分比 column-rule 列间边框样式，不影响布局 border and box effects border-radius border-top-right-radius 先垂直方向再水平方向 百分比值/具体数值 大于元素高度或宽度时会等比缩小 百分值分别为高度和宽度的百分比 border-image opacity &amp; color 添加opacity属性会触发图形加速 未设置z-index且设置过opacity的图层会盖住其他内容，实际上是渲染成了一张图片 gradients linear-gradient值生成的是图片 用于background-image linear-gradient(deg/direction, color1 color-stop, color2 color-stop) color-stop写像素值是这个color-stop距开始的位置，若这个值小于前一个color-stop则会被重置为前一个的值 repeating-linear-gradient radial-gradient conic-gradient transformations 2D transform: func ; rotate() translateX/translateY/translate(X, Y) 取百分值为自身的宽高 scaleX/scaleY/scale(X, Y) value为缩放倍数，负值翻转，坐标轴的刻度也会缩放 skewX/skewY/skew(X, Y) 倾斜 matrix(a, b, c, d, X, Y) 坐标变换 ，前四位矩阵，后两位平移 https://www.zhangxinxu.com/wordpress/2012/06/css3-transform-matrix-%E7%9F%A9%E9%98%B5/ 不影响布局，但是会盖住其他元素 渐变时若函数名和数量相同，则每个函数值单独渐变，否则直接变化（未设置的值会被重置为默认值） 平移尽量使用transform，显卡图层直接渲染，速度快 transform-origin: value; 不动点 3D x-axis向右 y-axis向下 z-axis向外 z-axis随元素旋转变化 rotateX/rotateY/rotateZ rotate3d(x, y, z, angle) perspective 景深 “viewport” 沿z-axis与xoy平面的距离 一般设置为1000px左右 不能与rotate属性分开写，会覆盖失效，且必须写在第一位否则会被忽略 单独写在父元素中相当于给每一个子元素增加属性 值为0或none时相当于不观察该元素，元素投影在父元素上，0和none有一点区别但我不知道为什么 scaleZ martix3D perspective-origin: x, y;“viewport”原点在xoy平面位置 transform-style: preserve-3D 更符合实际，用在变换元素的父元素上 backface-visibility: hidden;更符合实际，使后面元素不可见 transition &amp; animation transition transition-property 默认为all transition-timing-function: value; 距离时间函数 ease/linear/ease-out/ease-in-out cubic-bezier(x1, y1, x2, y2) 应当抽时间好好学习一下贝塞尔函数https://www.zhangxinxu.com/wordpress/2014/06/deep-understand-svg-path-bezier-curves-command/ steps() transition-delay可以为负值，动画直接从中间开始 animation @keyframes from = 0% to = 100% animation-iteration-count 迭代次数 infinite animation-direction normal 重复时直接从结束帧跳到开始帧 alternate 重复时从结束帧反向播放 animation-timing-function steps() animation-fill-mode none / backwards 动画前为0%状态 / forwards 结束时保留100%状态/both animation-play-state: running/paused 实现切片轮播图： https://tympanus.net/Tutorials/CSS3SlidingImagePanels/?tdsourcetag=s_pctim_aiomsg 零碎知识 给body设置overflow: hidden不能触发BFC 原因：overflow:visible以外的块级元素将创建BFC，除非该值已经扩散到了视口。 https://segmentfault.com/q/1010000002645174 div么有内容，只有width且height为0时，transform-origin为最左侧 max-content/min-content https://www.zhangxinxu.com/wordpress/2016/05/css3-width-max-contnet-min-content-fit-content/ width属性的值 min-content的包裹性(块元素绝对定位，浮动，inline-block时的宽度)，max-content使所有内容不这行 background-blend-mode filter blur( x px) 模糊效果 一定要记住： 给元素绝对定位或者浮动会使其自动变为block 使用transition等变化时最好两边都申明属性，否则可能不出现或出现奇怪的效果 input:submit/buttom比input:text默认高一点，是因为按下动画 text-align对最后一行文字无效 忽略外层div使鼠标点击穿透： pointer-event: none; 给包含块设置 边框 和 内边距 可以使子元素包含在内而不与父元素产生外边距折叠 媒体查询不能引入css，也不建议这样做 display: content; 浏览器会将所有将 display 设置为 contents 的元素从可访问性树]中移除。这会导致该元素及其后续元素不再被屏幕阅读技术访问。 布局/位置和其他样式尽量分开处理，CSS组件应当减少受到html结构的影响https://blog.zfanw.com/css-architecture/ 绝对定位的宽高是根据包含块的(content+ padding)的和计算的(不包含border)，与box-sizing无关！！ 伪元素中怎么添加换行符 JavaScript 小记 js中用getElementById.value方法获取的值的运算可以用在末尾加|0的方法使其从string 变为 integer Switch case 使用严格比较（===） Switching 的细节 如果多种 case 匹配一个 case 值，则选择第一个 case。 如果未找到匹配的 case，程序将继续使用默认 label。 如果未找到默认 label，程序将继续 switch 后的语句。 除了空字符串””，其他字符串转化为布尔值都为真 JavaScript 使用 32 位按位运算数 JavaScript 将数字存储为 64 位浮点数，但所有按位运算都以 32 位二进制数执行。 在执行位运算之前，JavaScript 将数字转换为 32 位有符号整数。 执行按位操作后，结果将转换回 64 位 JavaScript 数。","tags":[{"name":"front-end","slug":"front-end","permalink":"babopo.github.io/tags/front-end/"},{"name":"css","slug":"css","permalink":"babopo.github.io/tags/css/"}]},{"title":"前端学习week5","date":"2019-06-01T08:51:07.000Z","path":"2019/06/01/前端学习week5/","text":"​ 本周学习了CSS3中的一些新属性，本周有三个重点，1. 媒体查询：主要应用于移动页面的自适应，理解设备像素和CSS像素(设备独立像素)的区别和关系。2. flex布局，flex的使用大大简化 了很多复杂页面布局的工作量，细节也相对较少，display: flex的元素自动升级为块元素，而内容item则没有行内和块元素之分，可以理解为结合了浮动和inline-block的特性。 3. @font-face规则，利用这个规则可以引入字体图标，可以减少图片资源的加载还能自定义字体名字。 CSS3media query 使用媒体查询的三种方式 CSS内的媒体查询不影响选择器优先级 DPR device pixel ratio physical pixel / css pixel 单位： DPI DPCM DPPX(常用) D: dot &lt;meta name=&quot;Viewport&quot; content=&quot;width=device-width&quot;&gt; 让手机浏览器以设备屏幕宽度的初始包含块渲染页面，不设置一般是1000左右，仅支持移动端 width后设置的是设备渲染的css像素宽度，不用写单位 css像素也叫做设备独立像素(device-independent pixels (dips)) http://www.ayqy.net/blog/%E5%AE%8C%E5%85%A8%E7%90%86%E8%A7%A3px-dpr-dpi-dip/ 手机上缩放页面永远不会回流，用户缩放的时候css像素(例如width)是不变的，只是改变了DPR 移动端布局 一般两种情况： 页面在不同设备上显示比例一致 使用vw单位 使用meta viewport标签定宽 以上旧版浏览器不支持时，使用rem单位，用js获取视口宽度，使用100vw/(dips页面宽度)作为1rem的大小html {font-size: 100vw/x} x为逻辑页面大小，但要注意字号大小小于12px时会被浏览器强行重置为12px，所以需要将单位放大至12px以上，相应的rem使用时缩减相应倍数 页面在更大的屏幕上显示更多内容 width=devic-width使用px以及流式布局(块元素自动占满宽度) 混合页面 布局使用rem，文字使用px，width=devic-width pseudo-class&amp;pseudo-element :target伪类：url中含有元素的id的值时选中 :not()伪类中不能出现层级选择器即&gt; ~ +以及空格等 且not伪类在选择器中权重为0，但是not伪类里面的东西参与优先级 ::first-letter伪元素会选中第一个文字字符前的所有符号字符 flexible box layout display: flex声名内部为flex，外部为块 inline-flex flex-container flex-direction 设置main-axis column /column-reverse row 默认值 justify-content 是item元素main-axis对齐 flex-start/flex-end center space-around/space-between align-items 在cross-axis上对齐 子元素本身在交叉轴的对齐 flex-start/flex-end center baseline stretch 默认值 设置为其他值时则失效 align-content 设置行间的空间，与justify-content值相同，只有一行时无效 子元素整体在交叉轴对齐 flex-wrap 设置cross-axis 发生折行 shrink失效 ，折行时不会发生外边距折叠 flex-flow ： direction | wrap flex-item flex-basis 对应行排列时的width或列排列时的height，比较灵活，item的理想大小 content &lt; width &lt; flex-basis (limited by max|min-width) 优先级 flex-grow: 对container剩余空间的分配拉伸，若所有item中的值之和不超过1，那还会剩下1减去和的比例部分未分配 flex-shrink 缩减对应比例权重使items fit container，默认为1，具体收缩的值为各item初始宽度乘以权重再在多出的宽度下分配，和不足1时与grow类似 align-self 交叉轴上的对齐 order 顺序默认为0 理解flex-item的min-content 看到zxx的文章https://www.zhangxinxu.com/wordpress/2016/05/css3-width-max-contnet-min-content-fit-content/ 说一下自己的理解：flex布局自带shrink为1，而flex-item有一个最小内容宽度，一般被子元素的内容撑起，例如只有文本内容且为文本样式为nowrap时，最小内容宽度为最长的单词长度，内容为替换元素图片且未设置图片的宽度时，最小内容宽度即为图片的宽度(DOM结构为container&gt;div&gt;img，div作为flex-item有包裹内容的性质)。当最小内容宽度的和大于container的宽度，此时flex-item也无法再被压缩，表现为溢出。一个有意思的情况是在图片作为item的内容的情况下，当给图片设置max-width: 100% ，相当于flex-item的最小内容宽度的限制取消了，此时会依照shrink的规则来对flex-item进行压缩。 当图片宽度比容器小的时候设置了max-width会怎样：flex布局可以理解成若item的shrink为0时先将元素按本来属性摆放，再按设置的shrink或grow等其他属性来伸长或压缩。所以会直接按图片的尺寸摆放 flex container在 column warp时宽度不能被items的内容撑开，可以在末尾使用伪元素来填充剩余的空间使形成完整的矩形 https://output.jsbin.com/topegiw 利用flex实现自适应的正方形阵列，利用了伪元素的padding百分比值为父元素宽度的特性撑起父元素高度及grow属性实现自适应大小的正方形，增加几个高度为0的正方形元素使当最后一个行未铺满正方形时其大小不会过分拉伸 子元素可以用margin:auto 实现两端对齐， 设为auto的margin会占用这个方向剩余的所有空间 web font @font-face { font-family custom name; src: url(); src: url() format(&#39;embedded-opentype&#39;), //ie8 above woff ttf ; font-style: ; font-weight: ; unicode-range: ; } /* custom name可以重复使用，引入斜体粗体等 @font-face分开写会造成第版本IE浏览器下加载多个字体请求。*/ font-size-adjust: number x的大小缩放 font-stretch 需要单独设计的字体文件 利用font引入icon 用图标，符号替代不需要的字符编码作为字体引入 unicode PUA(private user area) \\f000 之后，使用类名及伪元素组合可以给图标命名和防止读屏软件读出， svgtext effect &amp; typographic styles text-shadow text-overflow clip ellipsis 超出的文本用(…)表示，只能应用于单行文本 text-align :start/end 零碎知识 max-width可以设置为none而min-width不可以，可以给min-width设置为0达到想要的效果 如何调整input:text中placeholder文本的样式 使用::placeholder伪元素，但是不能调整垂直对齐，因为input内为 替换元素且为单行 border outline box-shadow 区别 border：占据空间 outline： 不占空间，只能为矩形，不能圆角，不能模糊，有outline-offset属性，从border外侧开始渲染 box-shadow：不占空间，形状跟随border，优于outline，从border内侧开始渲染，但是需要方框时可以用outline https://juejin.im/post/591e478b0ce4630069308278 FoUT (the Flash of Unstyled Text) 页面加载时间比引入的样式短，加载到样式时造成页面闪烁 解决方案： 把首屏的样式写入页面的style标签中 使用link标签放在页面上方而不是@import bacground-positon 百分值是图片水平或垂直方向的百分值位置对应元素的百分值位置 background-size的cover和contain不是数值属性，不能动画 background-origin的默认值是padding-box 不要忘记为替换元素（比如 img 、 object 、 video 、 iframe 等）设置一个 max-width ，值为 100% 。 无法给img等自闭合标签添加伪元素！因为伪元素是子元素","tags":[{"name":"front-end","slug":"front-end","permalink":"babopo.github.io/tags/front-end/"},{"name":"css","slug":"css","permalink":"babopo.github.io/tags/css/"}]},{"title":"前端学习week4","date":"2019-05-23T14:27:05.000Z","path":"2019/05/23/前端学习week4/","text":"​ 学习时间一个月了，到了一个结点，css2.1的规范学习也结束，下周将开始css3的学习。先回顾一下上周的知识：上周的重点是盒模型，行内元素以及行内块元素的规则，还有定位布局，注意文本的一些属性在不同的元素下表现形式会不一样，例如对齐规则在表格中就相对直观简单。本周主要学习了另外两种原始的布局方法：表格，浮动。表格需要注意的是表层和边框优先级的规则顺序：td&gt;row&gt;col&gt;table。浮动摆放位置的规则和清除浮动以及闭合浮动的概念和方法。 元素居中方法inline 水平方向text-align: center即可 垂直方向 使用伪元素 .inline::after { content: &quot;&quot;; display: inline-block; height: 100%; vertical-align: middle; } &lt;p class=&quot;code-caption&quot; data-lang=&quot;&quot; data-line_number=&quot;frontend&quot; data-trim_indent=&quot;backend&quot; data-label_position=&quot;outer&quot; data-labels_left=&quot;Code&quot; data-labels_right=&quot;:&quot; data-labels_copy=&quot;Copy Code&quot;&gt;&lt;span class=&quot;code-caption-label&quot;&gt;&lt;/span&gt;&lt;a class=&quot;code-caption-copy&quot;&gt;Copy Code&lt;/a&gt;&lt;/p&gt; 原理：画个图就明白了，vertical-align: middle的意思是使元素的中部与父元素的基线上的x中部对齐 可以利用表格的对齐特性 display: table-cell vertical-align: middle 多行文本垂直据中 div { min-height: 150px; line-height: 150px; } span { display: inline-box; line-height: normal; vertical-align: middle; } &lt;p class=&quot;code-caption&quot; data-lang=&quot;&quot; data-line_number=&quot;frontend&quot; data-trim_indent=&quot;backend&quot; data-label_position=&quot;outer&quot; data-labels_left=&quot;Code&quot; data-labels_right=&quot;:&quot; data-labels_copy=&quot;Copy Code&quot;&gt;&lt;span class=&quot;code-caption-label&quot;&gt;&lt;/span&gt;&lt;a class=&quot;code-caption-copy&quot;&gt;Copy Code&lt;/a&gt;&lt;/p&gt; 图片和文字排列时垂直居中，使图片和文字均为行内元素且设置为vertical-align: middle;即可 绝对定位居中 margin: auto; top: 0; left: 0; right: 0; bottom: 0; 见：https://www.zhangxinxu.com/wordpress/2013/11/margin-auto-absolute-%E7%BB%9D%E5%AF%B9%E5%AE%9A%E4%BD%8D-%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD/ 原理：当一个绝对定位元素，其对立定位方向属性同时有具体定位数值的时候，流体特性就发生了，即元素的外边距会扩大或缩小以适应父元素或画布的实际大小 过分受限自动填充父元素可用尺寸，注意正常流的margin:auto不能使垂直居中，而绝对定位中可以 flex子元素margin: auto或调整父元素的justify-content和align-items transform利用transform: translate();和position: relative 百分值的特性 唯一一种子元素大于父元素也能居中的方法 表布局 visibility中的collapse只对表格中的列生效，且列或列组的visibility只有这一个声明，整列隐藏。 匿名表对象 浏览器会自动补全遗漏的表格组件，可利用这个特性故意省略table，会自动补全一个&lt;div class=&quot;table&quot;&gt;，可以给表格增加滚动条 caption视为块级元素 合并单元格边框 表宽度是指两边框中线的距离 次像素 subpixel 边框优先级和表层的优先级是一样的，另外hidden优先级最高，none优先级最低，粗&gt;细，上&gt;下，左&gt;右 表层 所有颜色背景初始都是透明的，按顺序叠放，透过外层透明背景可以看到里层背景，td最高，table最低 表大小 高度永远自动计算 宽度 固定布局 自动布局 表格及单元格宽度由其包含的内容决定，要在整个表格后加载解析完成之后才能最终确定，如果某行的列宽和前面的不一致，则之前绘制好的行也必须重新绘制 table-layout 默认为auto即自动布局，使用fixed值时表格第一行渲染即确定单元格宽度，可以加速渲染 单元格width为百分比：参考https://csspod.com/table-width-algorithms/ 例：设置成1%？ 对齐 vertica-align: middle 单元格内容中间对齐，可利用这个特性实现垂直居中 base-line col无法使用hover伪类，可以使用伪元素利用表层特性实现行列高亮 回流和重绘https://www.cnblogs.com/chenjg/p/10099886.html reflow/relayout 页面样式变化涉及重新计算布局 尽量不要触发回流，控制在一定范围内 repaint 页面样式变化不涉及计算布局，只改变颜色背景阴影等 回流一定会触发重绘，而重绘不一定会回流 IE hack条件注释 浮动 可用来清除图片间的空隙 包含块是最近的块级祖先 给行内元素设置浮动会变成块元素 块元素会忽略浮动元素布局，但是行内元素会环绕浮动渲染 浮动不会影响前面块元素的布局 浮动框没有空间会向下向左滑动 朋友圈照片布局优化，调整li的数量观察效果 li:first-child:nth-last-child(3) 浮动和定位组合，只有position:relative生效，其他情况只有定位生效 浮动元素不会重叠 垂直方向不同包含块的浮动元素也不会重叠 水平方向的不同包含块的浮动元素会冲叠 浮动的负magin浮动块中内容的位置不会影响浮动布局盒子的位置，有点像定位中的relative。但是会改变布局盒子的大小，而浮动块的内容位置也是相对布局盒子的位置，当浮动布局盒子宽度为0时，位置会变为前面块元素的末尾，此时浮动块元素可以重叠，具体例子参见淘宝的双飞翼布局https://www.cnblogs.com/langzs/archive/2013/01/27/taobaoshuangfeiyi.html 清除浮动 清除浮动 clear 块级 让块框下移，使两边没有浮动元素 触发BFC，若块级元素在两个浮动之间，则变窄 闭合浮动 块框高度增大使包含其浮动的后代元素， 触发BFC： overflow 除visible以外的值 display: inline-block/table-cell/table/flow-root;position: absolute/fixed; float position: absolute/fixed 末尾使用一个行元素生成行框使其撑高 缺点：会有不需要的一段高度 末尾使用一个块元素clear:both使撑高，br亦可 优化：可使用after伪元素http://www.iyunlu.com/view/css-xhtml/55.html?tdsourcetag=s_pctim_aiomsg 常用示例： div::before, div::after { display: table; content: &#39;&#39;; } div::after { clear: both; } &lt;p class=&quot;code-caption&quot; data-lang=&quot;&quot; data-line_number=&quot;frontend&quot; data-trim_indent=&quot;backend&quot; data-label_position=&quot;outer&quot; data-labels_left=&quot;Code&quot; data-labels_right=&quot;:&quot; data-labels_copy=&quot;Copy Code&quot;&gt;&lt;span class=&quot;code-caption-label&quot;&gt;&lt;/span&gt;&lt;a class=&quot;code-caption-copy&quot;&gt;Copy Code&lt;/a&gt;&lt;/p&gt; 列表 浏览器大多使用padding来实现列表项缩进，所以可以改变padding来调整缩进 list-style-type属性会继承，但是用户代理的可能对样式表有定义。 计数器 counter-reset counter-increment 浏览器第一次使用时会reset 伪类中:content: counter(name) 计数器可以定义列表样式：counter(name, list-styletype) counters(name, “.”) 老计数器追加新计数器，并用 . 连接 计数器有作用域，counter-reset确定了计数器的作用域 零碎知识 p标签内不能写块元素，遇到块元素标签直接闭合 行内元素不能包含块元素，也会直接闭合 这是旧标准的说法，新的html5中删去了block和inline的概念，能否嵌套应当查看元素的categories和content model 伪元素生成的内容无法选中 all: initial将所有属性还原默认值 例：用于去除inline-block间的间隙 html { box-sizing: border-box; } *, ::after, ::before { box-sizing: inherit; } 将所有元素设置为border-box的优化写法 opacity不继承 圣杯布局和双飞翼布局区别 圣杯布局：借助的是其他非主要元素覆盖了其父元素的padding值所占据的宽度，同一个杯子，非主要元素其只是占据了全部容器的padding值部分； 双飞翼布局：给主要部分main-wrap添加一个外层元素main，其他非主要元素所占据的空间是主要部分(main-wrap)的margin空间，像鸟的两个翅膀，与主要部分main脱离 双飞翼布局多了一个DOM节点，但是布局也更稳定","tags":[{"name":"front-end","slug":"front-end","permalink":"babopo.github.io/tags/front-end/"},{"name":"css","slug":"css","permalink":"babopo.github.io/tags/css/"}]},{"title":"前端学习week3","date":"2019-05-18T04:01:03.000Z","path":"2019/05/18/前端学习week3/","text":"本周开始学习css的布局基础知识，基本视觉格式化从盒模型入手，介绍了块元素的盒模型及基本概念，水平方向和垂直方向的规则和要点很多，注意水平方向的width总和和垂直方向的margin折叠学习这些内容能方便预测页面中的基本布局，之后学习了背景图片的一些技巧和sprite图应用，接着是基本布局之一的定位，最后是行内元素的结构，注意行内框，行框，line-height的关系，内容很多很杂，需要梳理。 基本视觉格式化盒模型 所有元素都有盒模型，只不过行内元素的宽高上下外边距设置无效 无法通过元素的margin box部分与此元素交互 padding/border不能为负值 只有width/height/margin可以设置为auto box-sizing 默认为content-box 建议设置为border-box 利用border的特性使用css画出多种几何图形 http://www.webhek.com/post/40-css-shapes.html border默认为前景色 即文本的颜色 包含块：最近的块级祖先 常规流normal flow 水平属性 内容，左右外边距可以设置为auto 块级元素框水平总和等于父元素内容区width(不是width属性的值！！) 百分数也是 水平方向外边距不会折叠 没有auto 过分受限会把margin-right强制为auto(与文本书写方向有关) 一个auto 根据父元素计算出值 只有margin-left为auto时，不能计算出负值，会自动置0，负值给margin-right 两个auto(margin-left/right,width) margin-left/right 元素在父元素中居中 margin/width 设置为auto的外边距为0 三个auto 两个外边距会被设置为0 替换块级元素的宽度为auto时则为内容的固有宽度 边框宽度不能用百分比表示 利用min-width/max-width属性 垂直属性 浏览器渲染规则：自上而下，自外而内，静态渲染，一次到位 默认高度由内容决定 margin-top/bottom都为auto时会自动设为0，不会居中 height必须设置为auto或者非负值 常规流中，margin/padding的水平和垂直方向的百分数值都是基于包含块的内容区width计算的 若包含块height设置为auto且高度由内容撑大，子元素height设置的百分数会失效 特殊情况：包含块只设置了min-height，有高度但子元素高度百分比依然无效 解决方法： 将包含块设置具体高度 包含块的高度不由子元素撑大，例如子元素设置为绝对定位 外边距折叠 只在垂直方向 保留两者中较大的外边距 负margin和正margin相遇时两者相加得到新的外边距 两个负margin重叠也只保留绝对值较大的 多个margin接触时，正与负分别合并，最后正与负求和 常规流块元素没有边框和内边距且只包含块元素时，包裹子元素的 border-box，父子元素的margin会合并，但触发了BFC的元素，无论如何都会内容区包裹子元素的margin-box，父子元素的margin也不会合并 BFC 列表项 块级元素 隐藏元素 visibility: hidden 元素不可见，不可交互，但是仍占据布局中的位置 opacity: 0 元素透明，但是可交互 display: none 元素从布局中完全消失 颜色和背景 背景不继承 背景图片无法直接复制 背景颜色默认在border以内的区域包括border 背景图片： background-repeat background-size 元素的背景占据了元素的全部尺寸，包括内边距和边框，但不包括外边距。 以background-origin为基准 ，默认为padding-box，即背景图像一定是从padding开始摆放，如果不使用no-repeat，则背景图像会覆盖至包括边框 cover 图片由无穷大等比缩小到正好覆盖元素 contain 与cover相反 object-fit img/video的属性 background-attachment fixed 相对于视口定位。 可产生特殊的效果 background-position 值可以写关键字，配合数值 百分比：位置为box的百分比对准图片的百分比位置，注意图片比窗口大的时候增加百分比图片如何移动？ background-clip 定位 position static 默认 fixed 相对视口 上下/左右margin设置为auto可以居中 默认位置为原先在常规流中的位置 relative 相对自己原来的位置 常规流会保留原来的位置 absolute 相对定了位的最近祖先的padding-box(无定位祖先则相对第一屏) 宽度未设置时，最大到包含块的border，最小为一个单词长度，可设置white-space使不折行 sticky 不会离开包含块，结合了relative和fixed 的特性 z-index 默认0，后盖前 祖先后代都定位时，后代的z-index失效 transition 过度动画 cubic-bezier 与visibility组合时，注意visibility只要离开hidden状态就会visible，并不是渐变 行内元素 垂直方向内容区相连，有边框的话，边框会重叠显示 行内框是由行内元素产生，行框则是一行中所有的行内框构成 box-shadow是元素折断之后生效，border是折断之前生效，可以利用这个特性为多行文本的每行增加边框 行内元素垂直方向margin不影响布局 line-height值尽量写纯数字，用em容易产生奇怪的结果 只要行框形成就不会消失 给行内元素增加边框和padding不会影响行内框等布局，初始边框包围内容区 替换元素内容区包括外边距 line-height可视为确定了行框的最小高度 将行内元素的line-height设置小于normal失效：会假设行内元素旁白会有一个空的匿名文本，行高继承自块元素 inline原色无padding和border时，其底色区域的高度为当前字体line-height为normal时计算的值，与实际设置的line-height无关 替换元素line-height属性无效 vertical-align的百分值是根据line-height计算 当包含块中只有行内替换元素时，例如只有一张图片，行框的计算要加上图片的行内款和相邻空白节点的行内框(假设改行有匿名文本) 视觉格式化流程 按照以下步骤确定行中各元素行内框以及高度： 获取各行内非替换元素及不属于后代内元素的所有文本的 font-size值和 line-height值， line-height和 font-size差值为行间距值。 获取替换元素高度及上、下外边距，上、下内边距，上、下边框值相加。 对于内容区，需要确定各元素、匿名文本以及该行本身基线的位置，将其基线对齐。对于替换元素，需要底边放置该行基线上。 对于指定 vertical-align 值的元素，确定其垂直偏移量。并改变元素在上方或下方超出的距离。 确定各行内框的具体位置后再进行确定行框。行框高度为最高行内框顶端和最低行内框低端之间的距离。 inline-block inline-block的元素之间会产生空格间隙间隙影响布局，解决方法见：https://www.zhangxinxu.com/wordpress/2012/04/inline-block-space-remove-%E5%8E%BB%E9%99%A4%E9%97%B4%E8%B7%9D/ 相邻的block元素中间产生匿名空格，让元素分行即可 行内框为margin-box的外边缘 基线为最后一行文字的基线/无内容时以margin-box的下边缘为准 替换元素设置为display:inline无效，会被当做inline-block inline-block的基线会影响布局，其基线取决于元素本身的特性，在该元素中没有行内子元素（注意是DOM树的子元素，有块子元素不算或者块子元素中有行元素这个行元素算）的时候或者overflow不为visible，该inline-block的基线为margin-bottom的下边界。否则，以该元素中最后一个行框子元素的基线为该元素的基线。 假设两个inline-block并列，第二个又嵌套了一个inline-blok，会怎样布局 解答：按照上面的规则，inline-block的基线为margin-box的底部，第二个inline-block的基线变成被嵌套的inline-block的基线，所以第一个和被嵌套的底端对齐。 匿名盒子匿名文本看作被包含在匿名盒中继承父元素属性 匿名块盒子 如果有多个块盒子，而它们中间又没有行内元素，则会在这些盒子的前面和后面创建两个匿名块盒子 如果块容器盒里面有一个块级盒，那么我们强制让它里面只含有块级盒 匿名盒子无法被选择器选中，可继承的属性都为inherit，不可继承的为initial 匿名行内盒 任何被直接包含在一个块容器元素中（不在行内元素里面）的文本，必须视为一个匿名行内元素 不分行的就是行内盒，因为内部分块的叫块盒 块容器盒 该元素的直接子元素只能是块级盒，或只能是行内级盒 零碎知识 * { background-color: rgba(0, 0, 0, 0.08); } /*练习时css预写能方便看到各元素区域*/ &lt;p class=&quot;code-caption&quot; data-lang=&quot;&quot; data-line_number=&quot;frontend&quot; data-trim_indent=&quot;backend&quot; data-label_position=&quot;outer&quot; data-labels_left=&quot;Code&quot; data-labels_right=&quot;:&quot; data-labels_copy=&quot;Copy Code&quot;&gt;&lt;span class=&quot;code-caption-label&quot;&gt;&lt;/span&gt;&lt;a class=&quot;code-caption-copy&quot;&gt;Copy Code&lt;/a&gt;&lt;/p&gt; 伪元素可看作该元素的元素 伪元素不能交互 改变分隔线hr的颜色 hr { /* 如何改变hr的颜色 */ background-color: rgb(211, 213, 213); border: none; height: 1px; } /* 直接改变border-color会变成2px高度，因为有上下两边框 */ 设置html的width为100vw是包括滚动条的，设置为100%则不包括，默认即为100% html默认的overflow为auto 而要设置块元素height100%显示，必须设置其包含块的height，否则无效","tags":[{"name":"front-end","slug":"front-end","permalink":"babopo.github.io/tags/front-end/"},{"name":"css","slug":"css","permalink":"babopo.github.io/tags/css/"}]},{"title":"前端学习week2","date":"2019-05-11T13:30:06.000Z","path":"2019/05/11/前端学习week2/","text":"​ 本周继续学习了html中剩余的常用标签，特别是表单，列表和表格的用法；理解什么是语义化；并进入css的学习，本周的重点是css选择器的种类和优先级，介绍了颜色，长度等数值和单位的用法，以及字体和文本属性的声明。 html 常用标签 i 语义： 用来表示由于某些原因需要与普通文本区分的文本 strong em 语义都为强调，strong更强一些 pre 块级标签 有预定义格式的文本 标签内文本格式都会保留 与code(行内标签)标签配合显示高亮代码 列表 ol - ordered list ul - unordered list li - list item dl - desciption list dt - description term dd - description description 一个列表项由一个dt和多个dd为一组 一个dt对应多个dd dd和dt是同级元素，不是嵌套关系 可访问性 accessibility - a11y internationalizition - i18n 各个设备访问/各种人群 a r i a 属性 accessibly rich internet application 和role属性组合使用，提示浏览器当前元素是一个何种视觉元素 aria-xxx=”yyy” 提示浏览器单枪视觉元素的状态或其他信息 表单 form 最外层标签 属性 action 表单提交地址 target method 表单提交方式 get 将表单字段拼成querystring http://abc.com/?a=1&amp;b=2&amp;c=3 组合成：表单地址?”name=”表单内容1&amp;”name”=内容2&amp;… post enctype 编码方式 input type属性 file accept属性组合使用 可以接受的文件类型 &lt;input type=&quot;file&quot; name=&quot;&quot; id=&quot;&quot; accept=&quot;image/*,text/*&quot;&gt; MIME Type 媒体类型 &lt;input type=&quot;file&quot; name=&quot;&quot; id=&quot;&quot; accept=&quot;.jpg,.png,.gif,.jpeg,.webp,.exe&quot; value=&quot;c:/user/xieran/desktop/a.pdf&quot;&gt; multiple 选择多文件，布尔值 hidden 存放一些用户不可见、不可改的数据，在用户提交表单时，这些数据会一并发送出 隐藏的输入域 value设置其值 name设置名字 不能识别的值一律当text处理 其他属性 value datetime-local https://zh.wikipedia.org/wiki/ISO_8601 name 很重要，表单提交时，这个域/字段/框/FormControl的名字 同时，在radio和checkbox阵列里，name相同的元素被分在一组里 可以作为内联元素放入label标签 button label 通过for属性连接其他元素或直接嵌套，使文字可互动 select option value 选择了该项目后它所属的select元素的值 selected 默认被选中 disabled 表示该项被禁用 hidden 表示该项被隐藏 以上三个属性均无值 optgroup // hgroup colgroup 给option分组 用label属性表示这个分组的名字 无法被选中，只能选择option textarea 多行文本输入框 fieldset 字段组，把一组输入域放在一起 legend 只能作为 fieldset 的子元素，用来标识这组输入域的名字 name属性主要用于表单元素 id所有标签都能使用 map “映射”标签 name属性 若设置id属属性，id和name属性值必须一样 子元素area table tbody 可以多个 tr 一行 table row th 表头/居中加粗 table header td table data colsapn 跨行 rowspan跨列 不能跨不存在的行列 thead 表头行 tfoot 表尾行 caption 表名 col/colgroup 设置列的样式 放在tbody/thead之前，caption之后 从上到下，从左到右 iframe inline frame 不能省略结束标签，否则之后的内容会被当做fallback后备内容不在页面显示 name属性 _top , _parent 自定义 iframe的跳转也会被浏览器记录 html5标签不能用style标签引入css progress 进度条 https://www.zhangxinxu.com/wordpress/2013/02/html5-progress-element-style-control/ 语义化我的理解：应当用机器可读的语义来降低机器处理web内容的难度 语义化做的好的页面能方便人与机器理解 可维护性 搜索结果靠前（机器理解） 合适内容选用合适标签 合适的嵌套 元素合适的类名和id名称 标签分类 旧 块级 行内 https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Content_categories 下面是常见标签语义 p - 段落 h1,h2,h3,h4,h5,h6 - 层级标题 strong,em - 强调 ins - 插入 del - 删除 abbr - 缩写 code - 代码标识 cite - 引述来源作品的标题 q - 引用 blockquote - 一段或长篇引用 ul - 无序列表 ol - 有序列表 dl,dt,dd - 定义列表 zwj 零宽连字符 CSScascading style sheet 注释不能嵌套 层叠 冲突处理 样式继承 注意代码规范，减少git diff信息 替换元素 没有后代元素/标签/结点 指内容被其他不在文档里的内容替换的 非替换元素 内容直接出现在标签中间 元素显示角色 role display 块级元素 block display 属性可以改变显示方式 行内/行间/内联元素 inline 引入html style标签 link标签 media属性 显示介质 all 默认 print 打印 … 内联样式 DOM @import指令 @import &quot;xxxx.xx&quot;; 只能出现在开头，可以有多个 树状依赖，导致串行下载 选择器 声明的属性和值必须是支持的，否则会被用户代理忽略 标签/元素 类 id id只能是一个单词，中间不能有空格 属性选择器 [xx] {} [href$=&quot;.pdf&quot;] {}以.pdf结尾的href属性 [href$=&quot;.pdf&quot; i] {}以.pdf结尾的href属性，且不区分大小写(case insensitive) [href^=&quot;a&quot;] {}以a开头的href属性 [href*=&quot;abc&quot;] {}连续出现abc的href属性 [href~=&quot;abc&quot;] {}出现abc单词的href属性 类名以 bs- 开头的元素[class^=&quot;bs-&quot;], [class*=&quot; bs-&quot;] { background-color: yellow; } [lang|=&quot;en&quot;] {}相当于[lang=&quot;en&quot;], [lang^=&quot;en-&quot;] {} 层级选择器 后代选择器 div p {} 子元素选择器 div &gt; p {} 邻接选择器 div + p {}紧挨div的p 若有多个这样的组合则可选多个 div ~ p {}div后所有兄弟p 选择器分组 p,div,h1 {}; *通配选择符 复合 类选择器 .foo.bar {}选择foo&amp;&amp;bar 伪类选择器 pseudo class 链接伪类 :link :visited 安全问题大部分属性无法设置，也无法获取颜色 动态伪类 :hover :active :focus 顺序LVFHA 位置伪类 括号中n一定要写在前面 :first-child p:first-child 选择p，且p为第一个子节点 p :first-child 选择p里面的所有第一个子节点 :last-child :nth-child(1) 若有元素内嵌套多个标签，则嵌套的标签中对应位置也会被选择 :not() 单一条件 :first-of-type :only-of-type 优先级 从上至下，每有一项加一 0,0,0,0 内联样式 id 类/伪类/属性 元素/伪元素 优先级一样，后出现的更高 通配符*优先级为0 连接符 无优先级 ！important p {color: red !important;} 有与important冲突的属性，important都会占上风 important比内联样式优先级高 继承没有优先级，比通配符还小 同一个选择器内的属性，后出现的生效 属性的值不会合并 值和单位 颜色 十六进制表示法 hex 缩写 rgb hsl 长度 绝对 m，cm等 相对 px 为什么：屏幕的总像素数可以由用户指定，与ppi不是一回事 常用于边框和定位，图像大小 em 最常用 相对父元素字体大小 ex 字体中x字母一半的大小 rem font size of the root element 指相对于根元素，一般是html，的字体大小，常用于web app自适应布局 vw视口宽度，vh视口高度 视口包含滚动条 calc 字体 字体族不加引号 font-size默认继承的是父元素的计算值而非书写结果 font 文本属性 缩进 水平对齐 垂直对齐 适用内联元素 text-decoration 子元素无法去掉父元素留下的线 线的位置粗细样式都不能指定，解决方案为使用背景图片","tags":[{"name":"front-end","slug":"front-end","permalink":"babopo.github.io/tags/front-end/"},{"name":"css","slug":"css","permalink":"babopo.github.io/tags/css/"},{"name":"html","slug":"html","permalink":"babopo.github.io/tags/html/"}]},{"title":"前端学习week1","date":"2019-05-04T01:05:18.000Z","path":"2019/05/04/前端学习week1/","text":"一些前端的基本概念，没什么卵用 基础知识浏览器常见浏览器内核 webkit blink gecko trigent 二进制 模拟信号 连续的信号 数字信号 离散的信号 图片格式 jpg，jpeg 有损压缩，压缩率高 照片 png (portable network graphic) 无损压缩 适合有大块相同颜色区域的图像，不适合照片 支持透明(Alpha通道) gif 只有256色(原图小于256色时是无损压缩) 支持透明，但只支持全透明和不透明 bmp 无压缩，无损 多种颜色数量的格式 体积大，不适合网页 psd Photoshop专用格式 webp google开发的格式 有损压缩 各方面强过jpg 适合移动端 命令行 GUI与CLI GUI - Graphics User Interface CLI - Command Line Interface 两者区别只在于形式不一样 概念 prompt 命令 提示符 裸命令 例：pwd 显示当前工作目录 pipe 管道符，将前一个命令的Output作为下一个命令的Input 例如：xxx | grep abc 过滤出含abc的输出结果 编码知识 ASCII表 记忆：10-换行 48-0 65-A 97-a Unicode 通用字符集 utf-8 针对Unicode的一种变长字符编码 BOM BOM是用来判断文本文件是哪一种Unicode编码的标记，其本身是一个Unicode字符（”\\uFEFF”），位于文本文件头部。 HTML嵌套规则 树状(递归)结构 标签 语义化 secmentic 语义化是前端开发里面的一个专用术语，其优点在于标签语义化有助于构架良好的html结构，有利于搜索引擎的建立索引、抓取；另外，亦有利于页面在不同的设备上显示尽可能相同；此外，亦有利于构建清晰的机构，有利于团队的开发、维护。 即：合适的内容用合适的标签 事实上，即使是有些非自闭合标签（如p，li），在一些情况下也是可以省略结束标签的，而且，是完全符合html标准的 参考 https://www.w3.org/TR/html-markup/p.html https://developer.mozilla.org/en-US/docs/Web/HTML/Content_categories 缩进 indent属性 属性名大小写不敏感，属性值大小写敏感 当属性值没有空格和引号等特殊字符时，属性值完全可以不用引号包围 当属性值有复杂的引号时，考虑转义字符 一些通用/全局属性(Global Attributes) id name 标签名，主要用再表单类标签 title style 给标签内指定内联样式 class data-* html5中新属性，储存页面的私有自定义数据，会被用户代理自动忽略 例： &lt;li data-animal-type=&quot;鸟类&quot;&gt;喜鹊&lt;/li&gt; html entity 字符实体输入符号时，可能会与标签混在一起 两种转义(escape)格式 &entityName; &#entityNumber; 参考 https://dev.w3.org/html5/html-author/charref http://www.w3school.com.cn/html/html_entities.asp http://www.w3school.com.cn/tags/html_ref_entities.html 空白字符忽略 用户代理默认忽略文字间多余一个的空格，换行符全部忽略 可以用css改变忽略 可以用字符实体让空格不被忽略 例如&amp;nbsp;，但这不是真正的空格 常用标签 html 只能有一个 head https://github.com/joshbuchea/HEAD head内的内容不会显示在页面上 meta 元信息 title标签 仅纯文本 如果不出现在head内会自动移到head 出现多个的话仅第一个生效 页面图标 也可以不用一个标签设置，浏览器会自动读取网站根目录下的favicon.ico这个文件 body 如果在body或者html标签的结束标签之后又出现了其它的标签，则之前的结束标签就会被认为无效，浏览器会自动添加结束标签 base 基准 在标签之前加载的标签不会使用这个基准地址 &lt;base href=&quot;页面中所有相对路径的基准地址&quot; target=&quot;全局设置页面中所有链接的打开位置&quot;&gt; 必须以/即目录结尾，否则会把最后一个/的位置作为基准路径 target属性 _blank 新标签 _self 默认值 _parent 父窗体显示 _top 顶层窗体显示 h1-h6 一般页面不超过一个h1 seo (Search Engine Optimism) p a 语义是一个链接 绝对路径 相对路径 空的href连接到当前页面 类似的，img标签的空src属性也连接到当前页面 https://www.nczonline.net/blog/2009/11/30/empty-image-src-can-destroy-your-site/ download 属性 html5 表示点击链接将下载链接对应文件，而不是跳转，下载的文件以download属性的值来命名 只能下载自己网站的资源 这个属性能让点击下载完全由前端实现 img alt属性 alternate span 和 div 通用标签，是没有语义的标签 Git使用常用命令： git config git init 初始化本地仓库 git status 当前仓库状态 -s紧凑显示 git add xx 将修改/新文件提交到stage区 git commit -m “提交信息” 提交暂存区文件 git diff 显示详细文件修改状态，-staged显示暂存区文件改动 git log git merge git clone [url] git clone https://github.com/libgit2/libgit2 mylibgit 可将本地仓库名改为mylibgit git remote git push/pull git fetch git checkout git branch https://&lt;username&gt;.github.io/可以访问到&lt;username&gt;.github.io这个仓库里的资源 https://&lt;username&gt;.github.io/&lt;repo_name&gt;可以访问到repo_name这个仓库里的资源","tags":[{"name":"front-end","slug":"front-end","permalink":"babopo.github.io/tags/front-end/"}]},{"title":"搭建RSS自动推送服务","date":"2018-03-25T12:07:33.000Z","path":"2018/03/25/搭建RSS自动推送服务/","text":"利用Google app engine搭建自动推送RSS至kindle的服务 原repo：KindleEar 因为网络环境原因一直没有成功。心灰意冷下看到这篇文章： KindleEar 搭建教程：推送 RSS 订阅到 Kindle 记录非常详细，几乎涵盖了所有问题，故转载","tags":[{"name":"kindle","slug":"kindle","permalink":"babopo.github.io/tags/kindle/"},{"name":"rss","slug":"rss","permalink":"babopo.github.io/tags/rss/"}]},{"title":"win10下配置st3+Texlive+sumartraPDF的LaTeX环境","date":"2017-05-11T02:24:42.000Z","path":"2017/05/11/win10下配置st3-Texlive-sumartraPDF的LaTeX环境/","text":"安装sublime配置方便而Tex live相较Ctex更灵活且自定义程度高 sumatraPDF可配置为默认的pdf预览器，并内置了反向查找的功能，具体步骤略。 配置 在sublime中安装好LaTeXtools插件后，找出配置文件LaTeXTools.sublime-settings 将Tex live和sumatraPDF的安装路径添加环境变量后，找的settings中的texpath，distro和sumatra项按照提示修改，再找到builder项改为simple，即配置完成。 反向代理：打开sumartaPDf，在选项的对应处输入&quot;C:\\Program Files\\Sublime Text 3\\sublime_text.exe&quot; &quot;%f:%l&quot; 并执行即可。 在编辑完文档后按ctrl+b即可保存并输出pdf。","tags":[{"name":"LaTeX","slug":"LaTeX","permalink":"babopo.github.io/tags/LaTeX/"},{"name":"sublime","slug":"sublime","permalink":"babopo.github.io/tags/sublime/"}]},{"title":"Qt学习笔记","date":"2017-05-09T17:29:44.000Z","path":"2017/05/10/Qt学习笔记/","text":"想做一个GUI对验证码识别程序做同意的处理，又开了个新坑，并没有任何Qt的基础，Python相对C++比较简单，因此使用PyQt来做，本文为快速制作一个简陋的GUI程序的学习过程。 配置环境参见另一文中的末尾Windows下Pycharm+Anaconda+Opencv图像处理环境配置 设计过程可以参考另一系列教程PyQt5学习笔记01—-第一个窗口已经写的非常详细了 设计结果： 下面说说自己0基础学习时的问题： 由QT Designer设计好的UI执行Pyuic生成的ui代码会覆盖之前的，所以我们需要创建一个新的主程序通过调用UI程序来实现代码与界面分离，在主程序中添加功能。 主程序中新建一个类例如： Copy Code ``` python class MainWindow(QtWidgets.QMainWindow, Ui_MainWindow): def __init__(self): super(recognizer, self).__init__() self.setupUi(self) ``` 其中def __init__(self)为窗口初始化的部分，信号连接，字体等设置放在这里面 自定义的槽函数也放置在class中 调用label来显示文字及图像信息 Copy Code ``` python self.label.XXXXXXXXX ``` 可以设置全局变量来记录之前打开的文件路径，程序结果等。 使用cxfreeze来打包生成可执行文件(to be continued) cxfreeze打包会生成很多库文件，不方便使用，可用pyinstaller打包成单一可执行文件","tags":[{"name":"PyQt","slug":"PyQt","permalink":"babopo.github.io/tags/PyQt/"},{"name":"python","slug":"python","permalink":"babopo.github.io/tags/python/"}]},{"title":"验证码识别研究","date":"2017-04-18T15:08:35.000Z","path":"2017/04/18/验证码识别技术研究/","text":"研究背景验证码(CAPTCHA) 最早作为卡内基梅隆大学的一个科研项目，Yahoo! 是CAPTCHA 的第一个用户。CAPTCHA 是“Completely Automated Public Turing test to tell Computers and Humans Apart”(全自动区分计算机和人类的图灵测试)的缩写，是一种区分用户是人类还是计算机的公共自动程序。在一个验证码测试中，由计算机生成一个问题并评判用户的答案，这个问题必须只有人类才能解答。由于计算机无法解答，回答出该问题的用户就会被认为是人类 。CAPTCHA 在网络上的大规模使用起源于 1999-2000 年 Yahoo 网站的账号注册。目前大部分网站都引入了验证码机制来加强网络的安全验证。通过对验证码识别的研究，能够及时发现验证码存在的安全漏洞，对设计出更加安全的验证码有参考价值，对图像处理，模式识别等相关领域也具有重要意义。 验证码识别的具体过程识别流程一般为： 本课题主要介绍验证码识别中常用的数字图像处理技术，研究对象为卡提诺社区的验证码，给出算法流程和识别结果，并对结果进行分析。 验证码示例及特点：从原网页下载了一万张待标注的验证码： 由观察可得此类验证码的特点： 每幅验证码字符由4位数字和英文字母组成，且字体种类不多 每个字符的颜色与背景的噪声颜色都不相同 字符没有粘连，便于字符分割 由以上特点设计的识别流程如下： 识别流程根据设计好的识别方案，从之前下载的验证码中选取了200张作为实验数据及模式识别的样本，具体流程如下: 颜色聚类验证码图像中字符间颜色不同且均匀，可通过颜色聚类的方法将字符分离。 主要使用K-means算法，原理： 从数据集合中选取K个点作为各簇的中心，计算集合中各元素到各簇心的距离，使距离最近的元素为一类，再计算各类的中心作为新的簇心，重复上述过程，直到簇心的位置不变。 将获取的RGB图换值LAB空间，由于LAB空间色域广且各分量间联系较小，更适合颜色聚类。 RGB原图： LAB空间： 将图像每个像素值的L,A,B三个分量为一组作为特征向量，用K-means进行颜色聚类，由于背景的噪声颜色较复杂，因此K值取的较大，取K = 40。 颜色聚类后(已按类标记)： 类图处理由于颜色聚类后得到的矩阵是对原图不同类的标记，因此将每一类的标记点置黑，其他点置白，可以得到K张类图，其中4张包含字符的类图，(K - 4)张包含各类的颜色的噪声图，省去了预处理中灰度化的步骤。 因为K张类图都有一定数量的像素数，且背景噪声中可能包含与待识别字符颜色相同的零星噪点，难以直接获得包含字符的类图。通过人工挑选出包含字符的类图，经过多次实验，字符的像素点数量大致在[70,500]区间。 对之前的K张类图做4邻域的连通域去噪，步骤： 扫描整张图像，将不同4邻域的连通域标记为不同数字，统计各连通域的像素点数，将小于70或大于500的连通域置白。 处理后得到的各类图像种类：空白的噪声图像，只包含字符的图像，包含与字符像素点数类似的噪声图像。 投影分割经由上述步骤获得的图像， 人工选取包含字符的图像，经过多次实验，得到字符像素长度和高度的大致区间为[7,25],[8,28]。 计算每一列黑像素点的总数，形成竖直投影波形，根据投影波形的过零点确定图像像素区域的边界得到宽度；同理计算每行的黑点数，可得到像素区域高度。将在区间外的类图剔除，最后得到的即为原图中的四个字符图像，由字符最左端的像素位置可确定四个字符在原图中的顺序。 但也可能存在与待识别的字符像素数及长宽都类似的噪声，如下图所示： 特征提取由于以上得到的各个字符大小不尽相同，为统一字符特征，将字符的大小已近邻插值的方式归一化至$28*28$的大小. 将作为实验数据的200个验证码分离出的字符手动分类，得到由24种字符组成的样本库： $$\\Omega = {2,3,4,6,7,8,9,B,C,E,F,G,H,J,K,M,P,Q,R,T,V,W,X,Y}$$ 其中部分字符有不同的字体，部分英文字符有大小写，但不影响识别且为简化识别步骤，故将其分为同一类。 对字符主要提取4*4的粗网格统计特征： 计算每个网格内的像素值占总像素值的比列，将这16个数据作为一组特征向量储存，以二进制储存对应的类别编号。 为提高识别率，增加了边缘特征： 对作图所示的字符使用Canny边缘检测得到字符的边界，如右图所示，统计左图黑点数及右图白点数，将比值作为特征向量的第17个数据加入。 字符识别及结果分析：对单个字符的识别采用 K 近邻(KNN)算法，该方法首先储存训练样本，计算测试样本和每个训练样本特征向量的欧式距离，若在所有的训练样本中，得到与测试样本最接近的的 K 个的样本出现频率最高的类别，则该样本也属于这个类别。多次实验后取K为4。 之前投影分割步骤中提到的出现与待识别字符大小及像素点均类似的噪声，使用KNN计算后得到的与样本最小距离偏较大，多次实验后，得到大致阈值。若KNN步骤中最小 距离大于该值的对象则舍弃，以此去除该类噪声。 另取100张验证码人工标注后以之前的样本库用KNN识别，正确的有92幅，识别率为0.92。出现错误的结果原因基本为字符缺少，应为预处理步骤阈值等需要调整。 已用程序标注好所有一万张验证码。 接下来的工作 校验程序标注的验证码 解决仍存在识别结果错误的问题 用Python重写程序以提高程序效率 st=>start: Start pre=>operation: 预处理 sp=>operation: 字符分割 re=>operation: 字符识别 e=>end st->pre->sp->re->e{\"scale\":1,\"line-width\":2,\"line-length\":50,\"text-margin\":10,\"font-size\":12} var code = document.getElementById(\"flowchart-0-code\").value; var options = JSON.parse(decodeURIComponent(document.getElementById(\"flowchart-0-options\").value)); var diagram = flowchart.parse(code); diagram.drawSVG(\"flowchart-0\", options);st=>start: Start a=>operation: 颜色聚类 b=>operation: 噪声处理 c=>operation: 投影分割 d=>operation: 模式识别 e=>end st->a->b->c->d->e{\"scale\":1,\"line-width\":2,\"line-length\":50,\"text-margin\":10,\"font-size\":12} var code = document.getElementById(\"flowchart-1-code\").value; var options = JSON.parse(decodeURIComponent(document.getElementById(\"flowchart-1-options\").value)); var diagram = flowchart.parse(code); diagram.drawSVG(\"flowchart-1\", options);","tags":[{"name":"Opencv","slug":"Opencv","permalink":"babopo.github.io/tags/Opencv/"},{"name":"Matlab","slug":"Matlab","permalink":"babopo.github.io/tags/Matlab/"},{"name":"图像处理","slug":"图像处理","permalink":"babopo.github.io/tags/图像处理/"}]},{"title":"Windows下Pycharm+Anaconda+Opencv图像处理环境配置","date":"2017-04-14T14:29:59.000Z","path":"2017/04/14/python-opencv/","text":"软件下载略 opencv 的库可以从这里下载： Unofficial Windows Binaries for Python Extension Packages 复制入/lib/site-packages Copy Code ``` python pip install *.whl ``` 进行安装 Anaconda是一个成熟的python科学计算发行版，包含很多常用的库，省去了很多麻烦 可以在这里获取licenses，并放入user/.continuum： licenses 有自己的控制台命令 Copy Code ``` conda conda -h ``` 可以查看帮助 Pycharm是功能强大的python IDE，虽然Anaconda有捆绑Spyder，但这款功能更强 PyQt5的配置由于需要编写GUI，与设计数据库的方式很类似，配置可参考Python3 PyQt5 pycharm 环境搭建 在from PyQt5 import 包时报错，原因是Python3.6(Anaconda)目录下缺少python3.dll文件，从官网下载embeddable包复制即可，参考python3.6.0(Anaconda)安装PyQt5，“DLL load failed: 找不到指定的模块 需要调用资源配置在pyrcc中配置，与配置pyuic类似，pyrcc5.exe文件再anaconda/scripts目录下","tags":[{"name":"PyQt","slug":"PyQt","permalink":"babopo.github.io/tags/PyQt/"},{"name":"Python","slug":"Python","permalink":"babopo.github.io/tags/Python/"},{"name":"Opencv","slug":"Opencv","permalink":"babopo.github.io/tags/Opencv/"}]},{"title":"Windows下配置Hexo+GitHub博客基本步骤及遇到的问题","date":"2017-04-14T12:48:20.000Z","path":"2017/04/14/Windows下配置Hexo-GitHub博客基本步骤及遇到的问题/","text":"初衷是想找一个成本低廉又能保存一些技术学习笔记的地方，免费的OneNote对代码输入非常不友好，因此想到这样一个折中的搭建个人博客的方法，hexo用于搭建静态博客非常方便，同时能使用markdown编辑文章，而GitHub的门槛也非常低，网上教程也很多，步骤和自己遇到的一些问题如下： 安装Node.js及Git从主页下载即可，配置好git 安装hexo打开终端，输入 Copy Code ``` bash npm install -g hexo ``` 等待安装完成，无法安装可设置npm代理 Copy Code ``` bash npm config set registry http://registry.cnpmjs.org ``` 创建Hexo文件夹在预备作为储存博客页面的文件夹内打开终端，依次输入 Copy Code ``` bash 1. hexo init #会自动创建git repo 2. npm install ``` 查看是否创建成功 Copy Code ``` bash 1. hexo generate #生成静态页面 2. hexo server #在本地启动 少用，由于路径的原因，会产生各种问题 ``` 浏览器输入默认的local:4000端口即可查看页面 创建GitHub repo注意repo名应当为username.github.io否则部署后会有问题 获取SSH密钥并添加打开终端，键入 Copy Code ``` bash ssh-keygen -t rsa -C \"xxx@xx\" #后为github账号注册时的邮箱地址 ``` 在User\\name \\ .ssh\\路径下找到id_rsa.pub 复制密钥，添加入GitHub的setting中即可 测试是否添加成功：打开终端，输入： Copy Code ``` bash ssh -T git@github.com ``` 成功添加会提示相应字样 ps：代理等原因会影响连接，例如 Copy Code ``` bash $ ssh -vT git@github.com OpenSSH_7.3p1, OpenSSL 1.0.2k 26 Jan 2017 debug1: Reading configuration data /etc/ssh/ssh_config debug1: Connecting to github.com [93.46.8.89] port 22. debug1: Connection established. debug1: identity file /c/Users/Limbo/.ssh/id_rsa type 1 debug1: key_load_public: No such file or directory debug1: identity file /c/Users/Limbo/.ssh/id_rsa-cert type -1 debug1: key_load_public: No such file or directory debug1: identity file /c/Users/Limbo/.ssh/id_dsa type -1 debug1: key_load_public: No such file or directory debug1: identity file /c/Users/Limbo/.ssh/id_dsa-cert type -1 debug1: key_load_public: No such file or directory debug1: identity file /c/Users/Limbo/.ssh/id_ecdsa type -1 debug1: key_load_public: No such file or directory debug1: identity file /c/Users/Limbo/.ssh/id_ecdsa-cert type -1 debug1: key_load_public: No such file or directory debug1: identity file /c/Users/Limbo/.ssh/id_ed25519 type -1 debug1: key_load_public: No such file or directory debug1: identity file /c/Users/Limbo/.ssh/id_ed25519-cert type -1 debug1: Enabling compatibility mode for protocol 2.0 debug1: Local version string SSH-2.0-OpenSSH_7.3 ssh_exchange_identification: Connection closed by remote host ``` 关闭代理即可 Hexo的配置和部署_config.yml为全局配置文件，在Deployment区域，修改为： Copy Code ``` bash deploy: type: git repo: github: git@github.com:username/username.github.io.git,master ``` 若要关联自己的域名令需添加CNAME文件 终端部署命令： Copy Code ``` bash hexo clean #清楚缓存 hexo generate hexo deploy ``` 在此之前可能需要输入 Copy Code ``` bash npm install hexo-deployer-git --save ``` 安装部署插件 至此，基本的配置工作已完成。 Copy Code ``` bash hexo new \"title\" ``` 可在source\\ _posts下生成“title”标题的新md文件 由于国内的特殊网络环境，访问已搭建好的页面需要输入https://username.github.io Hexo主题推荐一个主题yilia 也是本站正使用的，Reademe很详细也不再此赘述 绑定个人域名如果你有闲置的域名，可以将其绑定至刚配置好的博客页 在域名管理页的DNS控制中添加域名解析类型为A指向IP地址(在控制台中ping一下搭好的博客地址可以得到)或者添加CNAME指向域名，选择其一即可，不能同时添加 在source目录下添加名为CNAME的文件(无后缀)，内容为你要绑定的域名 修改_config.yml中的url为要绑定的域名，部署即可 关于写作在文章中加入&lt;!-- more --&gt;可以将文章截断显示在主页，防止文章过长 文章头的reward和comments分别为打赏和评论，值为True/False Copy Code ``` bash hexo new page xxx ``` 可以新建一个名为xxx的页面，以此做了一个留言板 以下是对yilia主题的修改，增加一些功能 跟帖及留言添加评论以及留言的功能，的功能，按照lawlite的方法并没有成功，因此改用来必力的跟帖 从来比力网站获取web代码后，在themes\\yilia\\layout\\ _partial下的article.ejs最后添加即可 例如： Copy Code ``` html (function(d, s) { var j, e = d.getElementsByTagName(s)[0]; if (typeof LivereTower === &#39;function&#39;) { return; } j = d.createElement(s); j.src = &#39;https://cdn-city.livere.com/js/embed.dist.js&#39;; j.async = true; e.parentNode.insertBefore(j, e); })(document, ‘script’); 为正常使用来必力评论功能请激活JavaScript ``` 最外层的标签可以取消在主页和控制文章中显示跟帖 网站访问量功能在不蒜子获取代码后放入themes\\yilia\\layout\\ _partial下的footer.ejs中即可 在文章中插入音乐由于是在github上搭建的博客，直接从网易云获取的外链不支持https，从知乎搜索到一个解决办法 Copy Code ``` bash npm install --save hexo-tag-aplayer ``` 安装播放器插件 在A Flask Music Project. Demo项目中找到音乐链接，修改相应参数即可 在网易云音乐中找到对应曲目，然后生成外链。 代码如下： Copy Code ``` html ``` 效果如下：","tags":[{"name":"blog","slug":"blog","permalink":"babopo.github.io/tags/blog/"},{"name":"hexo","slug":"hexo","permalink":"babopo.github.io/tags/hexo/"},{"name":"git","slug":"git","permalink":"babopo.github.io/tags/git/"}]},{"title":"Hello World","date":"2017-04-14T03:24:52.222Z","path":"2017/04/14/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new postCopy Code ``` bash $ hexo new \"My New Post\" ``` More info: Writing Run serverCopy Code ``` bash $ hexo server ``` More info: Server Generate static filesCopy Code ``` bash $ hexo generate ``` More info: Generating Deploy to remote sitesCopy Code ``` bash $ hexo deploy ``` More info: Deployment","tags":[{"name":"Hello world","slug":"Hello-world","permalink":"babopo.github.io/tags/Hello-world/"},{"name":"随笔","slug":"随笔","permalink":"babopo.github.io/tags/随笔/"}]}]